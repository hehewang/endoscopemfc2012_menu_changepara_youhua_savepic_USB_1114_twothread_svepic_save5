; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

	TITLE	E:\work_wm\HXIJY_code\endoscopemfc2012_menu_changepara_youhua_savepic_USB_1114_twothread_svepic_save5\src\EndoScopeMFC\DataType.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?g_bStop@@3HA					; g_bStop
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?g_pShowDlg@@3PAVCWnd@@A			; g_pShowDlg
PUBLIC	?g_bConnect@@3HA				; g_bConnect
PUBLIC	?g_bVideo@@3HA					; g_bVideo
PUBLIC	?g_bOneB@@3HA					; g_bOneB
PUBLIC	?g_bOneR@@3HA					; g_bOneR
PUBLIC	?g_bOneSharpen@@3HA				; g_bOneSharpen
PUBLIC	?g_bIsUpan@@3HA					; g_bIsUpan
PUBLIC	?g_bIsLightOpen@@3HA				; g_bIsLightOpen
PUBLIC	?g_bWhiteBalance@@3HA				; g_bWhiteBalance
PUBLIC	?g_bExposure@@3HA				; g_bExposure
PUBLIC	?g_thred@@3HA					; g_thred
PUBLIC	?g_iMenu@@3HA					; g_iMenu
PUBLIC	?g_fGainB@@3NA					; g_fGainB
PUBLIC	?g_fGainR@@3NA					; g_fGainR
PUBLIC	?g_lamdag@@3NA					; g_lamdag
PUBLIC	?g_lamdab@@3NA					; g_lamdab
PUBLIC	?g_lamdar@@3NA					; g_lamdar
PUBLIC	?g_nPort@@3HA					; g_nPort
PUBLIC	?g_nCCOM@@3HA					; g_nCCOM
PUBLIC	?g_nLCOM@@3HA					; g_nLCOM
PUBLIC	?g_nVCOM@@3HA					; g_nVCOM
PUBLIC	?g_nShowShape@@3HA				; g_nShowShape
PUBLIC	?g_nChange255@@3HA				; g_nChange255
PUBLIC	?g_nChangePixel@@3HA				; g_nChangePixel
PUBLIC	?g_nThreshNew@@3HA				; g_nThreshNew
PUBLIC	?g_nThresh@@3HA					; g_nThresh
PUBLIC	?g_nMetering@@3HA				; g_nMetering
PUBLIC	?g_nBlue@@3HA					; g_nBlue
PUBLIC	?g_nRed@@3HA					; g_nRed
PUBLIC	?g_nLBrightness@@3HA				; g_nLBrightness
PUBLIC	?g_nWhitebalance@@3HA				; g_nWhitebalance
PUBLIC	?g_nGain@@3HA					; g_nGain
PUBLIC	?g_nExposure@@3HA				; g_nExposure
PUBLIC	?g_nSaturation@@3HA				; g_nSaturation
PUBLIC	?g_nContrast@@3HA				; g_nContrast
PUBLIC	?g_nBrightness@@3HA				; g_nBrightness
PUBLIC	?g_nSharpness@@3HA				; g_nSharpness
PUBLIC	?g_FPS@@3HA					; g_FPS
EXTRN	__imp_?Trim@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV12@XZ:PROC
EXTRN	__imp_?Right@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z:PROC
EXTRN	__imp_??0_Container_base12@std@@QAE@XZ:PROC
EXTRN	__imp_??1_Container_base12@std@@QAE@XZ:PROC
EXTRN	__imp___recalloc:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp_?_Orphan_all@_Container_base12@std@@QAEXXZ:PROC
EXTRN	__imp_?AfxThrowInvalidArgException@@YGXXZ:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	__imp_?Append@?$CSimpleStringT@D$00@ATL@@QAEXPBD@Z:PROC
EXTRN	__imp_?GetString@?$CSimpleStringT@D$00@ATL@@QBEPBDXZ:PROC
EXTRN	__imp__memcpy_s:PROC
EXTRN	__imp_?AfxThrowMemoryException@@YGXXZ:PROC
EXTRN	__imp_?AfxThrowOleException@@YGXJ@Z:PROC
?g_bStop@@3HA DD 01H DUP (?)				; g_bStop
?g_pShowDlg@@3PAVCWnd@@A DD 01H DUP (?)			; g_pShowDlg
?g_bConnect@@3HA DD 01H DUP (?)				; g_bConnect
?g_bVideo@@3HA DD 01H DUP (?)				; g_bVideo
?g_bOneB@@3HA DD 01H DUP (?)				; g_bOneB
?g_bOneR@@3HA DD 01H DUP (?)				; g_bOneR
?g_bOneSharpen@@3HA DD 01H DUP (?)			; g_bOneSharpen
?g_bIsUpan@@3HA DD 01H DUP (?)				; g_bIsUpan
?g_bIsLightOpen@@3HA DD 01H DUP (?)			; g_bIsLightOpen
?g_bWhiteBalance@@3HA DD 01H DUP (?)			; g_bWhiteBalance
?g_bExposure@@3HA DD 01H DUP (?)			; g_bExposure
?g_thred@@3HA DD 01H DUP (?)				; g_thred
?g_iMenu@@3HA DD 01H DUP (?)				; g_iMenu
	ALIGN	8

?g_fGainB@@3NA DQ 01H DUP (?)				; g_fGainB
?g_fGainR@@3NA DQ 01H DUP (?)				; g_fGainR
?g_nLCOM@@3HA DD 01H DUP (?)				; g_nLCOM
?g_nVCOM@@3HA DD 01H DUP (?)				; g_nVCOM
?g_nShowShape@@3HA DD 01H DUP (?)			; g_nShowShape
?g_nChange255@@3HA DD 01H DUP (?)			; g_nChange255
?g_nMetering@@3HA DD 01H DUP (?)			; g_nMetering
?g_nBlue@@3HA DD 01H DUP (?)				; g_nBlue
?g_nRed@@3HA DD	01H DUP (?)				; g_nRed
?g_nWhitebalance@@3HA DD 01H DUP (?)			; g_nWhitebalance
?g_nGain@@3HA DD 01H DUP (?)				; g_nGain
?g_nExposure@@3HA DD 01H DUP (?)			; g_nExposure
?g_nContrast@@3HA DD 01H DUP (?)			; g_nContrast
?g_nBrightness@@3HA DD 01H DUP (?)			; g_nBrightness
?g_nSharpness@@3HA DD 01H DUP (?)			; g_nSharpness
?g_FPS@@3HA DD	01H DUP (?)				; g_FPS
_BSS	ENDS
?g_lamdag@@3NA DQ 03ff0000000000000r		; 1	; g_lamdag
?g_lamdab@@3NA DQ 03ff0000000000000r		; 1	; g_lamdab
?g_lamdar@@3NA DQ 03ff0000000000000r		; 1	; g_lamdar
?g_nPort@@3HA DD 022b7H					; g_nPort
?g_nCCOM@@3HA DD 02H					; g_nCCOM
?g_nChangePixel@@3HA DD 03H				; g_nChangePixel
?g_nThreshNew@@3HA DD 0ffH				; g_nThreshNew
?g_nThresh@@3HA DD 0ffH					; g_nThresh
?g_nLBrightness@@3HA DD 05H				; g_nLBrightness
?g_nSaturation@@3HA DD 05H				; g_nSaturation
_DATA	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ DB 'deque<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
$SG4294963869 DB 00H
$SG4294963866 DB 00H
$SG4294963864 DB 00H
$SG4294963863 DB 00H
$SG4294963862 DB 00H
$SG4294963861 DB 00H
$SG4294963860 DB 00H
$SG4294963859 DB 00H
$SG4294963858 DB 00H
	ORG $+1
$SG4294963868 DB 'DATA\', 00H
	ORG $+2
$SG4294963867 DB 'D:\Temp\', 00H
	ORG $+3
$SG4294963865 DB '192.168.1.145', 00H
	ORG $+2
$SG4294963857 DB '\config.ini', 00H
$SG4294963856 DB 'D:\', 0c4H, 0daH, 0bfH, 0faH, 0beH, 0b5H, 0caH, 0fdH, 0beH
	DB	0ddH, '\', 00H
	ORG $+1
$SG4294963855 DB 'PATH', 00H
	ORG $+3
$SG4294963854 DB 'PARAMETER', 00H
	ORG $+2
$SG4294963853 DB '\', 00H
	ORG $+2
$SG4294963852 DB '\', 00H
	ORG $+2
$SG4294963851 DB 'BRIGHTNESS', 00H
	ORG $+1
$SG4294963850 DB 'PARAMETER', 00H
	ORG $+2
$SG4294963849 DB 'CONTRAST', 00H
	ORG $+3
$SG4294963848 DB 'PARAMETER', 00H
	ORG $+2
$SG4294963847 DB 'SATURATION', 00H
	ORG $+1
$SG4294963846 DB 'PARAMETER', 00H
	ORG $+2
$SG4294963845 DB 'EXPOSURE', 00H
	ORG $+3
$SG4294963844 DB 'PARAMETER', 00H
	ORG $+2
$SG4294963843 DB 'GAIN', 00H
	ORG $+3
$SG4294963842 DB 'PARAMETER', 00H
	ORG $+2
$SG4294963841 DB 'ADJBRIGHT', 00H
	ORG $+2
$SG4294963840 DB 'PARAMETER', 00H
	ORG $+2
$SG4294963839 DB 'WHITEBALANCE', 00H
	ORG $+3
$SG4294963838 DB 'PARAMETER', 00H
	ORG $+2
$SG4294963837 DB 'WHITEBALANCEVAL', 00H
$SG4294963836 DB 'PARAMETER', 00H
	ORG $+2
$SG4294963835 DB 'HUE_B', 00H
	ORG $+2
$SG4294963834 DB 'PARAMETER', 00H
	ORG $+2
$SG4294963833 DB 'HUE_R', 00H
	ORG $+2
$SG4294963832 DB 'PARAMETER', 00H
	ORG $+2
$SG4294963831 DB 'CONTUOR', 00H
$SG4294963830 DB 'PARAMETER', 00H
	ORG $+2
$SG4294963829 DB 'AUTOEXPOSURE', 00H
	ORG $+3
$SG4294963828 DB 'PARAMETER', 00H
	ORG $+2
$SG4294963827 DB 'THRETH', 00H
	ORG $+1
$SG4294963826 DB 'PARAMETER', 00H
	ORG $+2
$SG4294963825 DB 'GAIN_R', 00H
	ORG $+1
$SG4294963824 DB 'PARAMETER', 00H
	ORG $+2
$SG4294963823 DB 'GAIN_B', 00H
	ORG $+1
$SG4294963822 DB 'PARAMETER', 00H
	ORG $+2
$SG4294963821 DB 'MENU', 00H
	ORG $+3
$SG4294963820 DB 'PARAMETER', 00H
	ORG $+2
$SG4294963819 DB 'LAMDAR', 00H
	ORG $+1
$SG4294963818 DB 'PARAMETER', 00H
	ORG $+2
$SG4294963817 DB 'LAMDAG', 00H
	ORG $+1
$SG4294963816 DB 'PARAMETER', 00H
	ORG $+2
$SG4294963815 DB 'LAMDAB', 00H
	ORG $+1
$SG4294963814 DB 'PARAMETER', 00H
	ORG $+2
$SG4294963813 DB 'CHANGEPIXEL', 00H
$SG4294963812 DB 'PARAMETER', 00H
	ORG $+2
$SG4294963811 DB 'THRETH2', 00H
$SG4294963810 DB 'PARAMETER', 00H
	ORG $+2
$SG4294963809 DB 'CHANGE255', 00H
	ORG $+2
$SG4294963808 DB 'PARAMETER', 00H
	ORG $+2
$SG4294963807 DB 'THRETHNEW', 00H
	ORG $+2
$SG4294963806 DB 'PARAMETER', 00H
	ORG $+2
$SG4294963805 DB 'VCOMNUM', 00H
$SG4294963804 DB 'COM', 00H
$SG4294963803 DB 'LCOMNUM', 00H
$SG4294963802 DB 'COM', 00H
$SG4294963801 DB 'CCOMNUM', 00H
$SG4294963800 DB 'COM', 00H
$SG4294963799 DB 'ISCONNECT', 00H
	ORG $+2
$SG4294963798 DB 'SOCKET', 00H
	ORG $+1
$SG4294963797 DB '192.168.1.248', 00H
	ORG $+2
$SG4294963796 DB 'SERVERIP', 00H
	ORG $+3
$SG4294963795 DB 'SOCKET', 00H
	ORG $+1
$SG4294963794 DB 'SERVERPORT', 00H
	ORG $+1
$SG4294963793 DB 'SOCKET', 00H
	ORG $+1
$SG4294963792 DB '%lf', 00H
$SG4294963791 DB 'PARAMETER', 00H
	ORG $+2
$SG4294963790 DB 'insert into RecData (', 0b2H, 0d9H, 0d7H, 0f7H, ', ', 0b2H
	DB	0d9H, 0d7H, 0f7H, 0d6H, 0b5H, ') Values(''%s'', ''%lf'')', 00H
PUBLIC	?AtlThrowImpl@ATL@@YGXJ@Z			; ATL::AtlThrowImpl
PUBLIC	??$AtlConvFreeMemory@D@ATL@@YAXPAD0H@Z		; ATL::AtlConvFreeMemory<char>
PUBLIC	?AfxCrtErrorCheck@@YAHH@Z			; AfxCrtErrorCheck
PUBLIC	??$AtlConvAllocMemory@D@ATL@@YAXPAPADHPADH@Z	; ATL::AtlConvAllocMemory<char>
PUBLIC	?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z		; ATL::Checked::memcpy_s
PUBLIC	??0_Container_proxy@std@@QAE@XZ			; std::_Container_proxy::_Container_proxy
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@AAPAU21@@Z ; std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >::construct<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *,std::_Tree_node<std::pair<unsigned int const ,double>,void *> * &>
PUBLIC	??$destroy@U?$pair@$$CBIN@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBIN@1@@Z ; std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >::destroy<std::pair<unsigned int const ,double> >
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$_Fill_n@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IPAV12@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@IABQAV10@@Z ; std::_Fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@@Z ; std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >::destroy<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *>
PUBLIC	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
PUBLIC	??$destroy@PAE@?$allocator@PAE@std@@QAEXPAPAE@Z	; std::allocator<unsigned char *>::destroy<unsigned char *>
PUBLIC	??$destroy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$destroy@PAPAE@?$allocator@PAE@std@@QAEXPAPAPAE@Z ; std::allocator<unsigned char *>::destroy<unsigned char * *>
PUBLIC	?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ ; std::allocator<char>::select_on_container_copy_construction
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@AAPAU31@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::construct<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *,std::_Tree_node<std::pair<unsigned int const ,double>,void *> * &>
PUBLIC	??$forward@AAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<unsigned int const ,double>,void *> * &>
PUBLIC	??$destroy@U?$pair@$$CBIN@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@1@PAU?$pair@$$CBIN@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::destroy<std::pair<unsigned int const ,double> >
PUBLIC	??$_Move@AAD@std@@YA$$QADAAD@Z			; std::_Move<char &>
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >
PUBLIC	??$_Uninit_def_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IPAV12@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Val_type@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@@Z ; std::_Val_type<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *>
PUBLIC	??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::destroy<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *>
PUBLIC	??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
PUBLIC	??$destroy@PAE@?$allocator_traits@V?$allocator@PAE@std@@@std@@SAXAAV?$allocator@PAE@1@PAPAE@Z ; std::allocator_traits<std::allocator<unsigned char *> >::destroy<unsigned char *>
PUBLIC	??$destroy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *><std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
PUBLIC	??$forward@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
PUBLIC	??$destroy@PAPAE@?$allocator_traits@V?$allocator@PAE@std@@@std@@SAXAAV?$allocator@PAE@1@PAPAPAE@Z ; std::allocator_traits<std::allocator<unsigned char *> >::destroy<unsigned char * *>
PUBLIC	??$?0PAE@?$allocator@PAPAE@std@@QAE@ABV?$allocator@PAE@1@@Z ; std::allocator<unsigned char * *>::allocator<unsigned char * *><unsigned char *>
PUBLIC	??$_Allocate@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@0@IPAU10@@Z ; std::_Allocate<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >
PUBLIC	??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::construct<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *,std::_Tree_node<std::pair<unsigned int const ,double>,void *> * &>
PUBLIC	??$_Allocate@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAPAV10@@Z ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$destroy@U?$pair@$$CBIN@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBIN@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::destroy<std::pair<unsigned int const ,double> >
PUBLIC	??$addressof@U?$pair@$$CBIN@std@@@std@@YAPAU?$pair@$$CBIN@0@AAU10@@Z ; std::addressof<std::pair<unsigned int const ,double> >
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >
PUBLIC	??$_Uninitialized_default_fill_n@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,unsigned int,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >
PUBLIC	??$_Uninitialized_copy@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAV12@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ; std::_Uninitialized_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >
PUBLIC	??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::destroy<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *>
PUBLIC	??$addressof@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *>
PUBLIC	??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
PUBLIC	??$destroy@PAE@?$_Wrap_alloc@V?$allocator@PAE@std@@@std@@QAEXPAPAE@Z ; std::_Wrap_alloc<std::allocator<unsigned char *> >::destroy<unsigned char *>
PUBLIC	??$destroy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> >::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> ><std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
PUBLIC	??$destroy@PAPAE@?$_Wrap_alloc@V?$allocator@PAE@std@@@std@@QAEXPAPAPAE@Z ; std::_Wrap_alloc<std::allocator<unsigned char *> >::destroy<unsigned char * *>
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@PAE@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAPAE@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@PAE@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<unsigned char * *> >::_Wrap_alloc<std::allocator<unsigned char * *> ><std::_Wrap_alloc<std::allocator<unsigned char *> > >
PUBLIC	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >::allocate
PUBLIC	?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::allocate
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >,std::_Iterator_base0>::operator++
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >,std::_Iterator_base0>
PUBLIC	?max_size@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >
PUBLIC	?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Buyheadnode
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >,std::_Iterator_base0>::_Mynode
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::operator++
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >
PUBLIC	?allocate@?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::allocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Min
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Max
PUBLIC	?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAU?$pair@$$CBIN@2@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Myval
PUBLIC	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Isnil
PUBLIC	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >
PUBLIC	??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIN@std@@@1@@Z ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Rrotate
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Root
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Rmost
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Lrotate
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Erase
PUBLIC	?__autoclassinit@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEXI@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >,std::_Iterator_base0>::__autoclassinit
PUBLIC	?__autoclassinit@?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAEXI@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::__autoclassinit
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> >
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::operator!=
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::operator==
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::operator++
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >
PUBLIC	??0?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?deallocate@?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::deallocate
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> >::allocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Alloc_proxy
PUBLIC	?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
PUBLIC	?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
PUBLIC	?_Xlen@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
PUBLIC	?max_size@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
PUBLIC	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
PUBLIC	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
PUBLIC	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::deallocate
PUBLIC	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Getal
PUBLIC	??0?$_Tree_buy@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBIN@std@@@1@@Z ; std::_Tree_buy<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > >::_Tree_buy<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > >
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Lmost
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::clear
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::erase
PUBLIC	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@PAE@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<unsigned char *> >::_Getblock
PUBLIC	??0?$_Deque_val@U?$_Deque_simple_types@PAE@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<unsigned char *> >::_Deque_val<std::_Deque_simple_types<unsigned char *> >
PUBLIC	?deallocate@?$allocator@PAPAE@std@@QAEXPAPAPAEI@Z ; std::allocator<unsigned char * *>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAE@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<unsigned char *> >::_Wrap_alloc<std::allocator<unsigned char *> >
PUBLIC	?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >::_Alloc_proxy
PUBLIC	?deallocate@?$allocator@PAE@std@@QAEXPAPAEI@Z	; std::allocator<unsigned char *>::deallocate
PUBLIC	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getblock
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> >::deallocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deallocate
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocate
PUBLIC	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
PUBLIC	?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Free_proxy
PUBLIC	??0?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?_Growmap@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Growmap
PUBLIC	?pop_back@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::pop_back
PUBLIC	?empty@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty
PUBLIC	?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Freeheadnode
PUBLIC	??0?$_Tree_comp@$0A@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIN@std@@@1@@Z ; std::_Tree_comp<0,std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Tree_comp<0,std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::erase
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::end
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::begin
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAPAE@std@@@std@@QAEXPAPAPAEI@Z ; std::_Wrap_alloc<std::allocator<unsigned char * *> >::deallocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAE@std@@@std@@QAEXPAPAEI@Z ; std::_Wrap_alloc<std::allocator<unsigned char *> >::deallocate
PUBLIC	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAE@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >::_Getal
PUBLIC	?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >::_Free_proxy
PUBLIC	??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z ; std::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >
PUBLIC	??0?$allocator@PAE@std@@QAE@XZ			; std::allocator<unsigned char *>::allocator<unsigned char *>
PUBLIC	?pop_back@?$deque@PAEV?$allocator@PAE@std@@@std@@QAEXXZ ; std::deque<unsigned char *,std::allocator<unsigned char *> >::pop_back
PUBLIC	?empty@?$deque@PAEV?$allocator@PAE@std@@@std@@QBE_NXZ ; std::deque<unsigned char *,std::allocator<unsigned char *> >::empty
PUBLIC	??1?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??1?$_Deque_val@U?$_Deque_simple_types@PAE@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<unsigned char *> >::~_Deque_val<std::_Deque_simple_types<unsigned char *> >
PUBLIC	?Init@?$CA2AEX@$0IA@@ATL@@AAEXPBD@Z		; ATL::CA2AEX<128>::Init
PUBLIC	??1?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	?_Tidy@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
PUBLIC	?push_back@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
PUBLIC	??0?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAE@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >
PUBLIC	??0?$allocator@U?$pair@$$CBIN@std@@@std@@QAE@XZ	; std::allocator<std::pair<unsigned int const ,double> >::allocator<std::pair<unsigned int const ,double> >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Tidy
PUBLIC	??0?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIN@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >
PUBLIC	??1?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >::~_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >
PUBLIC	?_Tidy@?$deque@PAEV?$allocator@PAE@std@@@std@@IAEXXZ ; std::deque<unsigned char *,std::allocator<unsigned char *> >::_Tidy
PUBLIC	??0?$deque@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ; std::deque<unsigned char *,std::allocator<unsigned char *> >::deque<unsigned char *,std::allocator<unsigned char *> >
PUBLIC	??1?$_Tree_buy@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAE@XZ ; std::_Tree_buy<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > >::~_Tree_buy<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > >
PUBLIC	??1?$_Tree_comp@$0A@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_comp<0,std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::~_Tree_comp<0,std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >
PUBLIC	??B?$CA2AEX@$0IA@@ATL@@QBEPADXZ			; ATL::CA2AEX<128>::operator char *
PUBLIC	??1?$CA2AEX@$0IA@@ATL@@QAE@XZ			; ATL::CA2AEX<128>::~CA2AEX<128>
PUBLIC	??0?$CA2AEX@$0IA@@ATL@@QAE@PBD@Z		; ATL::CA2AEX<128>::CA2AEX<128>
PUBLIC	??1?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?push@?$queue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::queue<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::push
PUBLIC	??0?$queue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAE@XZ ; std::queue<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::queue<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??1?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >
PUBLIC	??0?$map@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAE@XZ ; std::map<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> > >::map<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> > >
PUBLIC	??1?$deque@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ; std::deque<unsigned char *,std::allocator<unsigned char *> >::~deque<unsigned char *,std::allocator<unsigned char *> >
PUBLIC	??0?$queue@PAEV?$deque@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@XZ ; std::queue<unsigned char *,std::deque<unsigned char *,std::allocator<unsigned char *> > >::queue<unsigned char *,std::deque<unsigned char *,std::allocator<unsigned char *> > >
PUBLIC	??9ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z ; ATL::operator!=
PUBLIC	?ReturnPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; ReturnPath
PUBLIC	?SetConfig@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@N@Z ; SetConfig
PUBLIC	?ReadConfig@@YA_NXZ				; ReadConfig
PUBLIC	?__autoclassinit@?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXI@Z ; std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::__autoclassinit
PUBLIC	?__autoclassinit@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXI@Z ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::__autoclassinit
PUBLIC	?__autoclassinit@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::__autoclassinit
PUBLIC	??1?$queue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAE@XZ ; std::queue<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~queue<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	?__autoclassinit@?$queue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAEXI@Z ; std::queue<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::__autoclassinit
PUBLIC	?__autoclassinit@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@QAEXI@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::__autoclassinit
PUBLIC	?__autoclassinit@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEXI@Z ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::__autoclassinit
PUBLIC	?__autoclassinit@?$_Tree_buy@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAEXI@Z ; std::_Tree_buy<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > >::__autoclassinit
PUBLIC	?__autoclassinit@?$_Tree_comp@$0A@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAEXI@Z ; std::_Tree_comp<0,std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::__autoclassinit
PUBLIC	?__autoclassinit@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAEXI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::__autoclassinit
PUBLIC	??1?$map@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAE@XZ ; std::map<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> > >::~map<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> > >
PUBLIC	?__autoclassinit@?$map@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAEXI@Z ; std::map<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> > >::__autoclassinit
PUBLIC	?__autoclassinit@?$_Deque_val@U?$_Deque_simple_types@PAE@std@@@std@@QAEXI@Z ; std::_Deque_val<std::_Deque_simple_types<unsigned char *> >::__autoclassinit
PUBLIC	?__autoclassinit@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXI@Z ; std::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >::__autoclassinit
PUBLIC	?__autoclassinit@?$deque@PAEV?$allocator@PAE@std@@@std@@QAEXI@Z ; std::deque<unsigned char *,std::allocator<unsigned char *> >::__autoclassinit
PUBLIC	??1?$queue@PAEV?$deque@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@XZ ; std::queue<unsigned char *,std::deque<unsigned char *,std::allocator<unsigned char *> > >::~queue<unsigned char *,std::deque<unsigned char *,std::allocator<unsigned char *> > >
PUBLIC	?__autoclassinit@?$queue@PAEV?$deque@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXI@Z ; std::queue<unsigned char *,std::deque<unsigned char *,std::allocator<unsigned char *> > >::__autoclassinit
PUBLIC	?g_decDriver@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_decDriver
PUBLIC	?g_strSaveDir@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_strSaveDir
PUBLIC	?g_strTmpDir@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_strTmpDir
PUBLIC	?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
PUBLIC	?g_strIP@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_strIP
PUBLIC	?g_strName@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_strName
PUBLIC	?g_strID@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_strID
PUBLIC	?g_strPatientInfo@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_strPatientInfo
PUBLIC	?strAvg@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; strAvg
PUBLIC	?strPeek@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; strPeek
PUBLIC	?g_Video_list@@3V?$queue@PAEV?$deque@PAEV?$allocator@PAE@std@@@std@@@std@@A ; g_Video_list
PUBLIC	?g_Map_Sharpness@@3V?$map@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@A ; g_Map_Sharpness
PUBLIC	?g_Operate_list@@3V?$queue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@A ; g_Operate_list
?g_decDriver@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A DD 01H DUP (?) ; g_decDriver
?g_strSaveDir@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A DD 01H DUP (?) ; g_strSaveDir
?g_strTmpDir@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A DD 01H DUP (?) ; g_strTmpDir
?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A DD 01H DUP (?) ; g_ConfigPath
?g_strIP@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A DD 01H DUP (?) ; g_strIP
?g_strName@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A DD 01H DUP (?) ; g_strName
?g_strID@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A DD 01H DUP (?) ; g_strID
?g_strPatientInfo@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A DD 01H DUP (?) ; g_strPatientInfo
?strAvg@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A DD 01H DUP (?) ; strAvg
?strPeek@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A DD 01H DUP (?) ; strPeek
?g_Video_list@@3V?$queue@PAEV?$deque@PAEV?$allocator@PAE@std@@@std@@@std@@A DB 014H DUP (?) ; g_Video_list
	ALIGN	8

?g_Map_Sharpness@@3V?$map@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@A DQ 01H DUP (?) ; g_Map_Sharpness
?g_Operate_list@@3V?$queue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@A DB 014H DUP (?) ; g_Operate_list
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ReadConfig@@YA_NXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?ReadConfig@@YA_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ReadConfig@@YA_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ReadConfig@@YA_NXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ReadConfig@@YA_NXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ReadConfig@@YA_NXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?ReadConfig@@YA_NXZ$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?SetConfig@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@N@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?SetConfig@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SetConfig@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetConfig@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SetConfig@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?SetConfig@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@N@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?SetConfig@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@N@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?SetConfig@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@N@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$?SetConfig@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@N@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ReturnPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ReturnPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ReturnPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ReturnPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ReturnPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ$2
__catchsym$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@AAPAU21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@AAPAU21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@AAPAU21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@AAPAU21@@Z$0
_g_decDriver$initializer$ DD FLAT:??__Eg_decDriver@@YAXXZ
_g_strSaveDir$initializer$ DD FLAT:??__Eg_strSaveDir@@YAXXZ
_g_strTmpDir$initializer$ DD FLAT:??__Eg_strTmpDir@@YAXXZ
_g_ConfigPath$initializer$ DD FLAT:??__Eg_ConfigPath@@YAXXZ
_g_strIP$initializer$ DD FLAT:??__Eg_strIP@@YAXXZ
_g_strName$initializer$ DD FLAT:??__Eg_strName@@YAXXZ
_g_strID$initializer$ DD FLAT:??__Eg_strID@@YAXXZ
_g_strPatientInfo$initializer$ DD FLAT:??__Eg_strPatientInfo@@YAXXZ
_strAvg$initializer$ DD FLAT:??__EstrAvg@@YAXXZ
_strPeek$initializer$ DD FLAT:??__EstrPeek@@YAXXZ
_g_Video_list$initializer$ DD FLAT:??__Eg_Video_list@@YAXXZ
_g_Map_Sharpness$initializer$ DD FLAT:??__Eg_Map_Sharpness@@YAXXZ
_g_Operate_list$initializer$ DD FLAT:??__Eg_Operate_list@@YAXXZ
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\datatype.cpp
;	COMDAT ??__Eg_decDriver@@YAXXZ
text$yc	SEGMENT
??__Eg_decDriver@@YAXXZ PROC				; `dynamic initializer for 'g_decDriver'', COMDAT

; 65   : CString g_decDriver = _T( "" );			//u

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG4294963869
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_decDriver@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_decDriver
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_decDriver@@YAXXZ ; `dynamic atexit destructor for 'g_decDriver''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??__Eg_decDriver@@YAXXZ ENDP				; `dynamic initializer for 'g_decDriver''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fg_decDriver@@YAXXZ
text$yd	SEGMENT
??__Fg_decDriver@@YAXXZ PROC				; `dynamic atexit destructor for 'g_decDriver'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_decDriver@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_decDriver
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??__Fg_decDriver@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_decDriver''
text$yd	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\datatype.cpp
;	COMDAT ??__Eg_strSaveDir@@YAXXZ
text$yc	SEGMENT
??__Eg_strSaveDir@@YAXXZ PROC				; `dynamic initializer for 'g_strSaveDir'', COMDAT

; 67   : CString g_strSaveDir = _T("DATA\\");//

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG4294963868
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strSaveDir@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_strSaveDir
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_strSaveDir@@YAXXZ ; `dynamic atexit destructor for 'g_strSaveDir''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??__Eg_strSaveDir@@YAXXZ ENDP				; `dynamic initializer for 'g_strSaveDir''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fg_strSaveDir@@YAXXZ
text$yd	SEGMENT
??__Fg_strSaveDir@@YAXXZ PROC				; `dynamic atexit destructor for 'g_strSaveDir'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strSaveDir@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_strSaveDir
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??__Fg_strSaveDir@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_strSaveDir''
text$yd	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\datatype.cpp
;	COMDAT ??__Eg_strTmpDir@@YAXXZ
text$yc	SEGMENT
??__Eg_strTmpDir@@YAXXZ PROC				; `dynamic initializer for 'g_strTmpDir'', COMDAT

; 68   : CString g_strTmpDir = _T("D:\\Temp\\");	//

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG4294963867
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strTmpDir@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_strTmpDir
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_strTmpDir@@YAXXZ ; `dynamic atexit destructor for 'g_strTmpDir''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??__Eg_strTmpDir@@YAXXZ ENDP				; `dynamic initializer for 'g_strTmpDir''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fg_strTmpDir@@YAXXZ
text$yd	SEGMENT
??__Fg_strTmpDir@@YAXXZ PROC				; `dynamic atexit destructor for 'g_strTmpDir'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strTmpDir@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_strTmpDir
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??__Fg_strTmpDir@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_strTmpDir''
text$yd	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\datatype.cpp
;	COMDAT ??__Eg_ConfigPath@@YAXXZ
text$yc	SEGMENT
??__Eg_ConfigPath@@YAXXZ PROC				; `dynamic initializer for 'g_ConfigPath'', COMDAT

; 69   : CString g_ConfigPath = _T( "" );		//

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG4294963866
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_ConfigPath@@YAXXZ ; `dynamic atexit destructor for 'g_ConfigPath''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??__Eg_ConfigPath@@YAXXZ ENDP				; `dynamic initializer for 'g_ConfigPath''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fg_ConfigPath@@YAXXZ
text$yd	SEGMENT
??__Fg_ConfigPath@@YAXXZ PROC				; `dynamic atexit destructor for 'g_ConfigPath'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??__Fg_ConfigPath@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_ConfigPath''
text$yd	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\datatype.cpp
;	COMDAT ??__Eg_strIP@@YAXXZ
text$yc	SEGMENT
??__Eg_strIP@@YAXXZ PROC				; `dynamic initializer for 'g_strIP'', COMDAT

; 70   : CString g_strIP = _T("192.168.1.145");	//ip

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG4294963865
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strIP@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_strIP
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_strIP@@YAXXZ ; `dynamic atexit destructor for 'g_strIP''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??__Eg_strIP@@YAXXZ ENDP				; `dynamic initializer for 'g_strIP''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fg_strIP@@YAXXZ
text$yd	SEGMENT
??__Fg_strIP@@YAXXZ PROC				; `dynamic atexit destructor for 'g_strIP'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strIP@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_strIP
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??__Fg_strIP@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_strIP''
text$yd	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\datatype.cpp
;	COMDAT ??__Eg_strName@@YAXXZ
text$yc	SEGMENT
??__Eg_strName@@YAXXZ PROC				; `dynamic initializer for 'g_strName'', COMDAT

; 71   : CString g_strName = _T( "" );	//

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG4294963864
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strName@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_strName
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_strName@@YAXXZ ; `dynamic atexit destructor for 'g_strName''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??__Eg_strName@@YAXXZ ENDP				; `dynamic initializer for 'g_strName''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fg_strName@@YAXXZ
text$yd	SEGMENT
??__Fg_strName@@YAXXZ PROC				; `dynamic atexit destructor for 'g_strName'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strName@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_strName
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??__Fg_strName@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_strName''
text$yd	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\datatype.cpp
;	COMDAT ??__Eg_strID@@YAXXZ
text$yc	SEGMENT
??__Eg_strID@@YAXXZ PROC				; `dynamic initializer for 'g_strID'', COMDAT

; 72   : CString g_strID =_T( "" );		//ID

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG4294963863
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strID@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_strID
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_strID@@YAXXZ ; `dynamic atexit destructor for 'g_strID''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??__Eg_strID@@YAXXZ ENDP				; `dynamic initializer for 'g_strID''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fg_strID@@YAXXZ
text$yd	SEGMENT
??__Fg_strID@@YAXXZ PROC				; `dynamic atexit destructor for 'g_strID'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strID@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_strID
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??__Fg_strID@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_strID''
text$yd	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\datatype.cpp
;	COMDAT ??__Eg_strPatientInfo@@YAXXZ
text$yc	SEGMENT
??__Eg_strPatientInfo@@YAXXZ PROC			; `dynamic initializer for 'g_strPatientInfo'', COMDAT

; 73   : CString g_strPatientInfo=_T("");

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG4294963862
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strPatientInfo@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_strPatientInfo
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_strPatientInfo@@YAXXZ ; `dynamic atexit destructor for 'g_strPatientInfo''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??__Eg_strPatientInfo@@YAXXZ ENDP			; `dynamic initializer for 'g_strPatientInfo''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fg_strPatientInfo@@YAXXZ
text$yd	SEGMENT
??__Fg_strPatientInfo@@YAXXZ PROC			; `dynamic atexit destructor for 'g_strPatientInfo'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strPatientInfo@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_strPatientInfo
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??__Fg_strPatientInfo@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_strPatientInfo''
text$yd	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\datatype.cpp
;	COMDAT ??__EstrAvg@@YAXXZ
text$yc	SEGMENT
??__EstrAvg@@YAXXZ PROC					; `dynamic initializer for 'strAvg'', COMDAT

; 75   : CString strAvg = _T("");		//

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG4294963861
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?strAvg@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; strAvg
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00013	68 00 00 00 00	 push	 OFFSET ??__FstrAvg@@YAXXZ ; `dynamic atexit destructor for 'strAvg''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??__EstrAvg@@YAXXZ ENDP					; `dynamic initializer for 'strAvg''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FstrAvg@@YAXXZ
text$yd	SEGMENT
??__FstrAvg@@YAXXZ PROC					; `dynamic atexit destructor for 'strAvg'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?strAvg@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; strAvg
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??__FstrAvg@@YAXXZ ENDP					; `dynamic atexit destructor for 'strAvg''
text$yd	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\datatype.cpp
;	COMDAT ??__EstrPeek@@YAXXZ
text$yc	SEGMENT
??__EstrPeek@@YAXXZ PROC				; `dynamic initializer for 'strPeek'', COMDAT

; 76   : CString strPeek = _T("");		//

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG4294963860
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?strPeek@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; strPeek
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00013	68 00 00 00 00	 push	 OFFSET ??__FstrPeek@@YAXXZ ; `dynamic atexit destructor for 'strPeek''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??__EstrPeek@@YAXXZ ENDP				; `dynamic initializer for 'strPeek''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FstrPeek@@YAXXZ
text$yd	SEGMENT
??__FstrPeek@@YAXXZ PROC				; `dynamic atexit destructor for 'strPeek'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?strPeek@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; strPeek
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??__FstrPeek@@YAXXZ ENDP				; `dynamic atexit destructor for 'strPeek''
text$yd	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\datatype.cpp
;	COMDAT ??__Eg_Video_list@@YAXXZ
text$yc	SEGMENT
??__Eg_Video_list@@YAXXZ PROC				; `dynamic initializer for 'g_Video_list'', COMDAT

; 78   : queue<BYTE *> g_Video_list;	//

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a 01		 push	 1
  00005	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Video_list@@3V?$queue@PAEV?$deque@PAEV?$allocator@PAE@std@@@std@@@std@@A ; g_Video_list
  0000a	e8 00 00 00 00	 call	 ?__autoclassinit@?$queue@PAEV?$deque@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXI@Z
  0000f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Video_list@@3V?$queue@PAEV?$deque@PAEV?$allocator@PAE@std@@@std@@@std@@A ; g_Video_list
  00014	e8 00 00 00 00	 call	 ??0?$queue@PAEV?$deque@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@XZ ; std::queue<unsigned char *,std::deque<unsigned char *,std::allocator<unsigned char *> > >::queue<unsigned char *,std::deque<unsigned char *,std::allocator<unsigned char *> > >
  00019	68 00 00 00 00	 push	 OFFSET ??__Fg_Video_list@@YAXXZ ; `dynamic atexit destructor for 'g_Video_list''
  0001e	e8 00 00 00 00	 call	 _atexit
  00023	83 c4 04	 add	 esp, 4
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??__Eg_Video_list@@YAXXZ ENDP				; `dynamic initializer for 'g_Video_list''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fg_Video_list@@YAXXZ
text$yd	SEGMENT
??__Fg_Video_list@@YAXXZ PROC				; `dynamic atexit destructor for 'g_Video_list'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Video_list@@3V?$queue@PAEV?$deque@PAEV?$allocator@PAE@std@@@std@@@std@@A ; g_Video_list
  00008	e8 00 00 00 00	 call	 ??1?$queue@PAEV?$deque@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@XZ
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Fg_Video_list@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_Video_list''
text$yd	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit@?$queue@PAEV?$deque@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_$initVBases$ = 8					; size = 4
?__autoclassinit@?$queue@PAEV?$deque@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXI@Z PROC ; std::queue<unsigned char *,std::deque<unsigned char *,std::allocator<unsigned char *> > >::__autoclassinit, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 01		 push	 1
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?__autoclassinit@?$deque@PAEV?$allocator@PAE@std@@@std@@QAEXI@Z
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?__autoclassinit@?$queue@PAEV?$deque@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXI@Z ENDP ; std::queue<unsigned char *,std::deque<unsigned char *,std::allocator<unsigned char *> > >::__autoclassinit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$queue@PAEV?$deque@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$queue@PAEV?$deque@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@XZ PROC ; std::queue<unsigned char *,std::deque<unsigned char *,std::allocator<unsigned char *> > >::~queue<unsigned char *,std::deque<unsigned char *,std::allocator<unsigned char *> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$deque@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ; std::deque<unsigned char *,std::allocator<unsigned char *> >::~deque<unsigned char *,std::allocator<unsigned char *> >
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$queue@PAEV?$deque@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@XZ ENDP ; std::queue<unsigned char *,std::deque<unsigned char *,std::allocator<unsigned char *> > >::~queue<unsigned char *,std::deque<unsigned char *,std::allocator<unsigned char *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit@?$deque@PAEV?$allocator@PAE@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_$initVBases$ = 8					; size = 4
?__autoclassinit@?$deque@PAEV?$allocator@PAE@std@@@std@@QAEXI@Z PROC ; std::deque<unsigned char *,std::allocator<unsigned char *> >::__autoclassinit, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?__autoclassinit@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXI@Z
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?__autoclassinit@?$deque@PAEV?$allocator@PAE@std@@@std@@QAEXI@Z ENDP ; std::deque<unsigned char *,std::allocator<unsigned char *> >::__autoclassinit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_$initVBases$ = 8					; size = 4
?__autoclassinit@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXI@Z PROC ; std::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >::__autoclassinit, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?__autoclassinit@?$_Deque_val@U?$_Deque_simple_types@PAE@std@@@std@@QAEXI@Z
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?__autoclassinit@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXI@Z ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >::__autoclassinit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit@?$_Deque_val@U?$_Deque_simple_types@PAE@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_$initVBases$ = 8					; size = 4
?__autoclassinit@?$_Deque_val@U?$_Deque_simple_types@PAE@std@@@std@@QAEXI@Z PROC ; std::_Deque_val<std::_Deque_simple_types<unsigned char *> >::__autoclassinit, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?__autoclassinit@?$_Deque_val@U?$_Deque_simple_types@PAE@std@@@std@@QAEXI@Z ENDP ; std::_Deque_val<std::_Deque_simple_types<unsigned char *> >::__autoclassinit
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\datatype.cpp
;	COMDAT ??__Eg_Map_Sharpness@@YAXXZ
text$yc	SEGMENT
??__Eg_Map_Sharpness@@YAXXZ PROC			; `dynamic initializer for 'g_Map_Sharpness'', COMDAT

; 80   : map<unsigned int, double> g_Map_Sharpness;//

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a 01		 push	 1
  00005	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Map_Sharpness@@3V?$map@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@A ; g_Map_Sharpness
  0000a	e8 00 00 00 00	 call	 ?__autoclassinit@?$map@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAEXI@Z
  0000f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Map_Sharpness@@3V?$map@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@A ; g_Map_Sharpness
  00014	e8 00 00 00 00	 call	 ??0?$map@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAE@XZ ; std::map<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> > >::map<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> > >
  00019	68 00 00 00 00	 push	 OFFSET ??__Fg_Map_Sharpness@@YAXXZ ; `dynamic atexit destructor for 'g_Map_Sharpness''
  0001e	e8 00 00 00 00	 call	 _atexit
  00023	83 c4 04	 add	 esp, 4
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??__Eg_Map_Sharpness@@YAXXZ ENDP			; `dynamic initializer for 'g_Map_Sharpness''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fg_Map_Sharpness@@YAXXZ
text$yd	SEGMENT
??__Fg_Map_Sharpness@@YAXXZ PROC			; `dynamic atexit destructor for 'g_Map_Sharpness'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Map_Sharpness@@3V?$map@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@A ; g_Map_Sharpness
  00008	e8 00 00 00 00	 call	 ??1?$map@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAE@XZ
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Fg_Map_Sharpness@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_Map_Sharpness''
text$yd	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit@?$map@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_$initVBases$ = 8					; size = 4
?__autoclassinit@?$map@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAEXI@Z PROC ; std::map<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> > >::__autoclassinit, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?__autoclassinit@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAEXI@Z
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?__autoclassinit@?$map@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAEXI@Z ENDP ; std::map<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> > >::__autoclassinit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$map@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$map@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAE@XZ PROC ; std::map<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> > >::~map<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$map@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAE@XZ ENDP ; std::map<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> > >::~map<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_$initVBases$ = 8					; size = 4
?__autoclassinit@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAEXI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::__autoclassinit, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?__autoclassinit@?$_Tree_comp@$0A@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAEXI@Z
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?__autoclassinit@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAEXI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::__autoclassinit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit@?$_Tree_comp@$0A@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_$initVBases$ = 8					; size = 4
?__autoclassinit@?$_Tree_comp@$0A@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAEXI@Z PROC ; std::_Tree_comp<0,std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::__autoclassinit, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?__autoclassinit@?$_Tree_buy@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAEXI@Z
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?__autoclassinit@?$_Tree_comp@$0A@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAEXI@Z ENDP ; std::_Tree_comp<0,std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::__autoclassinit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit@?$_Tree_buy@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_$initVBases$ = 8					; size = 4
?__autoclassinit@?$_Tree_buy@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAEXI@Z PROC ; std::_Tree_buy<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > >::__autoclassinit, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?__autoclassinit@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEXI@Z
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?__autoclassinit@?$_Tree_buy@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAEXI@Z ENDP ; std::_Tree_buy<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > >::__autoclassinit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_$initVBases$ = 8					; size = 4
?__autoclassinit@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEXI@Z PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::__autoclassinit, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?__autoclassinit@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@QAEXI@Z
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?__autoclassinit@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEXI@Z ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::__autoclassinit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_$initVBases$ = 8					; size = 4
?__autoclassinit@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@QAEXI@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::__autoclassinit, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?__autoclassinit@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@QAEXI@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::__autoclassinit
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\datatype.cpp
;	COMDAT ??__Eg_Operate_list@@YAXXZ
text$yc	SEGMENT
??__Eg_Operate_list@@YAXXZ PROC				; `dynamic initializer for 'g_Operate_list'', COMDAT

; 81   : queue<string> g_Operate_list;			 //

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a 01		 push	 1
  00005	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Operate_list@@3V?$queue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@A ; g_Operate_list
  0000a	e8 00 00 00 00	 call	 ?__autoclassinit@?$queue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAEXI@Z
  0000f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Operate_list@@3V?$queue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@A ; g_Operate_list
  00014	e8 00 00 00 00	 call	 ??0?$queue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAE@XZ ; std::queue<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::queue<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
  00019	68 00 00 00 00	 push	 OFFSET ??__Fg_Operate_list@@YAXXZ ; `dynamic atexit destructor for 'g_Operate_list''
  0001e	e8 00 00 00 00	 call	 _atexit
  00023	83 c4 04	 add	 esp, 4
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??__Eg_Operate_list@@YAXXZ ENDP				; `dynamic initializer for 'g_Operate_list''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fg_Operate_list@@YAXXZ
text$yd	SEGMENT
??__Fg_Operate_list@@YAXXZ PROC				; `dynamic atexit destructor for 'g_Operate_list'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Operate_list@@3V?$queue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@A ; g_Operate_list
  00008	e8 00 00 00 00	 call	 ??1?$queue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAE@XZ
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Fg_Operate_list@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_Operate_list''
text$yd	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit@?$queue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_$initVBases$ = 8					; size = 4
?__autoclassinit@?$queue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAEXI@Z PROC ; std::queue<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::__autoclassinit, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 01		 push	 1
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?__autoclassinit@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?__autoclassinit@?$queue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAEXI@Z ENDP ; std::queue<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::__autoclassinit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$queue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$queue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAE@XZ PROC ; std::queue<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~queue<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$queue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAE@XZ ENDP ; std::queue<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~queue<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_$initVBases$ = 8					; size = 4
?__autoclassinit@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z PROC ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::__autoclassinit, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?__autoclassinit@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXI@Z
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?__autoclassinit@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z ENDP ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::__autoclassinit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_$initVBases$ = 8					; size = 4
?__autoclassinit@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXI@Z PROC ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::__autoclassinit, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?__autoclassinit@?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXI@Z
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?__autoclassinit@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXI@Z ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::__autoclassinit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit@?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_$initVBases$ = 8					; size = 4
?__autoclassinit@?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXI@Z PROC ; std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::__autoclassinit, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?__autoclassinit@?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXI@Z ENDP ; std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::__autoclassinit
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\datatype.cpp
;	COMDAT ?ReadConfig@@YA_NXZ
_TEXT	SEGMENT
tv65 = -80						; size = 4
$T2 = -76						; size = 4
tv69 = -72						; size = 4
$T3 = -68						; size = 4
$T4 = -64						; size = 4
tv554 = -60						; size = 4
tv556 = -56						; size = 4
tv552 = -52						; size = 4
tv636 = -48						; size = 4
tv656 = -44						; size = 4
tv642 = -40						; size = 4
tv662 = -36						; size = 4
tv650 = -32						; size = 4
$T5 = -26						; size = 1
$T6 = -25						; size = 1
_strValue1$ = -24					; size = 4
_strValue$ = -20					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?ReadConfig@@YA_NXZ PROC				; ReadConfig, COMDAT

; 86   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ReadConfig@@YA_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 87   : 	CString strValue = _T(""),strValue1 = _T("");

  00028	68 00 00 00 00	 push	 OFFSET $SG4294963859
  0002d	8d 4d ec	 lea	 ecx, DWORD PTR _strValue$[ebp]
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003d	68 00 00 00 00	 push	 OFFSET $SG4294963858
  00042	8d 4d e8	 lea	 ecx, DWORD PTR _strValue1$[ebp]
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  0004b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 88   : 	g_ConfigPath = ReturnPath() + _T("\\config.ini");

  0004f	8d 45 bc	 lea	 eax, DWORD PTR $T3[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 ?ReturnPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; ReturnPath
  00058	83 c4 04	 add	 esp, 4
  0005b	89 45 b8	 mov	 DWORD PTR tv69[ebp], eax
  0005e	8b 4d b8	 mov	 ecx, DWORD PTR tv69[ebp]
  00061	89 4d cc	 mov	 DWORD PTR tv552[ebp], ecx
  00064	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00068	68 00 00 00 00	 push	 OFFSET $SG4294963857
  0006d	8b 55 cc	 mov	 edx, DWORD PTR tv552[ebp]
  00070	52		 push	 edx
  00071	8d 45 b4	 lea	 eax, DWORD PTR $T2[ebp]
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 ??HATL@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@ABV10@PBD@Z ; ATL::operator+
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007d	89 45 b0	 mov	 DWORD PTR tv65[ebp], eax
  00080	8b 4d b0	 mov	 ecx, DWORD PTR tv65[ebp]
  00083	89 4d c4	 mov	 DWORD PTR tv554[ebp], ecx
  00086	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0008a	8b 55 c4	 mov	 edx, DWORD PTR tv554[ebp]
  0008d	52		 push	 edx
  0008e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  00099	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0009d	8d 4d b4	 lea	 ecx, DWORD PTR $T2[ebp]
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000a6	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000aa	8d 4d bc	 lea	 ecx, DWORD PTR $T3[ebp]
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 89   : 
; 90   : 	GetPrivateProfileString(_T("PARAMETER"), _T("PATH"), _T("D:\\\\"), g_strSaveDir.GetBuffer(512), 512, g_ConfigPath);

  000b3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  000be	50		 push	 eax
  000bf	68 00 02 00 00	 push	 512			; 00000200H
  000c4	68 00 02 00 00	 push	 512			; 00000200H
  000c9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strSaveDir@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_strSaveDir
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBuffer@?$CSimpleStringT@D$00@ATL@@QAEPADH@Z
  000d4	50		 push	 eax
  000d5	68 00 00 00 00	 push	 OFFSET $SG4294963856
  000da	68 00 00 00 00	 push	 OFFSET $SG4294963855
  000df	68 00 00 00 00	 push	 OFFSET $SG4294963854
  000e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24

; 91   : 	g_strSaveDir.Trim();

  000ea	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strSaveDir@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_strSaveDir
  000ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Trim@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV12@XZ

; 92   : 	if (g_strSaveDir.Right(1) != "\\")

  000f5	6a 01		 push	 1
  000f7	8d 45 c0	 lea	 eax, DWORD PTR $T4[ebp]
  000fa	50		 push	 eax
  000fb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strSaveDir@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_strSaveDir
  00100	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Right@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z
  00106	89 45 c8	 mov	 DWORD PTR tv556[ebp], eax
  00109	68 00 00 00 00	 push	 OFFSET $SG4294963853
  0010e	8b 4d c8	 mov	 ecx, DWORD PTR tv556[ebp]
  00111	51		 push	 ecx
  00112	e8 00 00 00 00	 call	 ??9ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z ; ATL::operator!=
  00117	83 c4 08	 add	 esp, 8
  0011a	88 45 e6	 mov	 BYTE PTR $T5[ebp], al
  0011d	8d 4d c0	 lea	 ecx, DWORD PTR $T4[ebp]
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00126	0f b6 55 e6	 movzx	 edx, BYTE PTR $T5[ebp]
  0012a	85 d2		 test	 edx, edx
  0012c	74 10		 je	 SHORT $LN1@ReadConfig

; 93   : 		g_strSaveDir.Append(_T("\\"));

  0012e	68 00 00 00 00	 push	 OFFSET $SG4294963852
  00133	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strSaveDir@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_strSaveDir
  00138	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Append@?$CSimpleStringT@D$00@ATL@@QAEXPBD@Z
$LN1@ReadConfig:

; 94   : 	//g_nSharpness = GetPrivateProfileInt(_T("PARAMETER"), _T("SHARPNESS"), 1, g_ConfigPath);
; 95   : 	g_nBrightness = GetPrivateProfileInt(_T("PARAMETER"), _T("BRIGHTNESS"), 1, g_ConfigPath);

  0013e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  00143	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00149	50		 push	 eax
  0014a	6a 01		 push	 1
  0014c	68 00 00 00 00	 push	 OFFSET $SG4294963851
  00151	68 00 00 00 00	 push	 OFFSET $SG4294963850
  00156	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0015c	a3 00 00 00 00	 mov	 DWORD PTR ?g_nBrightness@@3HA, eax ; g_nBrightness

; 96   : 	g_nContrast = GetPrivateProfileInt(_T("PARAMETER"), _T("CONTRAST"), 1, g_ConfigPath);

  00161	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  00166	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  0016c	50		 push	 eax
  0016d	6a 01		 push	 1
  0016f	68 00 00 00 00	 push	 OFFSET $SG4294963849
  00174	68 00 00 00 00	 push	 OFFSET $SG4294963848
  00179	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0017f	a3 00 00 00 00	 mov	 DWORD PTR ?g_nContrast@@3HA, eax ; g_nContrast

; 97   : 	g_nSaturation = GetPrivateProfileInt(_T("PARAMETER"), _T("SATURATION"), 1, g_ConfigPath);

  00184	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  00189	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  0018f	50		 push	 eax
  00190	6a 01		 push	 1
  00192	68 00 00 00 00	 push	 OFFSET $SG4294963847
  00197	68 00 00 00 00	 push	 OFFSET $SG4294963846
  0019c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  001a2	a3 00 00 00 00	 mov	 DWORD PTR ?g_nSaturation@@3HA, eax ; g_nSaturation

; 98   : 	g_nExposure = GetPrivateProfileInt(_T("PARAMETER"), _T("EXPOSURE"), 1, g_ConfigPath);

  001a7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  001ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  001b2	50		 push	 eax
  001b3	6a 01		 push	 1
  001b5	68 00 00 00 00	 push	 OFFSET $SG4294963845
  001ba	68 00 00 00 00	 push	 OFFSET $SG4294963844
  001bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  001c5	a3 00 00 00 00	 mov	 DWORD PTR ?g_nExposure@@3HA, eax ; g_nExposure

; 99   : 	g_nGain = GetPrivateProfileInt(_T("PARAMETER"), _T("GAIN"), 1, g_ConfigPath);

  001ca	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  001cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  001d5	50		 push	 eax
  001d6	6a 01		 push	 1
  001d8	68 00 00 00 00	 push	 OFFSET $SG4294963843
  001dd	68 00 00 00 00	 push	 OFFSET $SG4294963842
  001e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  001e8	a3 00 00 00 00	 mov	 DWORD PTR ?g_nGain@@3HA, eax ; g_nGain

; 100  : 	g_nMetering = GetPrivateProfileInt(_T("PARAMETER"), _T("ADJBRIGHT"), 1, g_ConfigPath);

  001ed	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  001f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  001f8	50		 push	 eax
  001f9	6a 01		 push	 1
  001fb	68 00 00 00 00	 push	 OFFSET $SG4294963841
  00200	68 00 00 00 00	 push	 OFFSET $SG4294963840
  00205	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0020b	a3 00 00 00 00	 mov	 DWORD PTR ?g_nMetering@@3HA, eax ; g_nMetering

; 101  : 	g_bWhiteBalance = GetPrivateProfileInt(_T("PARAMETER"), _T("WHITEBALANCE"), 1, g_ConfigPath);

  00210	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  00215	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  0021b	50		 push	 eax
  0021c	6a 01		 push	 1
  0021e	68 00 00 00 00	 push	 OFFSET $SG4294963839
  00223	68 00 00 00 00	 push	 OFFSET $SG4294963838
  00228	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0022e	a3 00 00 00 00	 mov	 DWORD PTR ?g_bWhiteBalance@@3HA, eax ; g_bWhiteBalance

; 102  : 	g_nWhitebalance = GetPrivateProfileInt(_T("PARAMETER"), _T("WHITEBALANCEVAL"), 1, g_ConfigPath);

  00233	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  00238	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  0023e	50		 push	 eax
  0023f	6a 01		 push	 1
  00241	68 00 00 00 00	 push	 OFFSET $SG4294963837
  00246	68 00 00 00 00	 push	 OFFSET $SG4294963836
  0024b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00251	a3 00 00 00 00	 mov	 DWORD PTR ?g_nWhitebalance@@3HA, eax ; g_nWhitebalance

; 103  : 	g_nBlue = GetPrivateProfileInt(_T("PARAMETER"), _T("HUE_B"), 1, g_ConfigPath);

  00256	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  0025b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00261	50		 push	 eax
  00262	6a 01		 push	 1
  00264	68 00 00 00 00	 push	 OFFSET $SG4294963835
  00269	68 00 00 00 00	 push	 OFFSET $SG4294963834
  0026e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00274	a3 00 00 00 00	 mov	 DWORD PTR ?g_nBlue@@3HA, eax ; g_nBlue

; 104  : 	g_nRed = GetPrivateProfileInt(_T("PARAMETER"), _T("HUE_R"), 1, g_ConfigPath);

  00279	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  0027e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00284	50		 push	 eax
  00285	6a 01		 push	 1
  00287	68 00 00 00 00	 push	 OFFSET $SG4294963833
  0028c	68 00 00 00 00	 push	 OFFSET $SG4294963832
  00291	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00297	a3 00 00 00 00	 mov	 DWORD PTR ?g_nRed@@3HA, eax ; g_nRed

; 105  : 	//g_bIsAutoLightOpen = GetPrivateProfileInt(_T("PARAMETER"), _T("AUTOLIGHT"), 1, g_ConfigPath);
; 106  : 	g_nShowShape = GetPrivateProfileInt(_T("PARAMETER"), _T("CONTUOR"), 0, g_ConfigPath); 

  0029c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  002a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  002a7	50		 push	 eax
  002a8	6a 00		 push	 0
  002aa	68 00 00 00 00	 push	 OFFSET $SG4294963831
  002af	68 00 00 00 00	 push	 OFFSET $SG4294963830
  002b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  002ba	a3 00 00 00 00	 mov	 DWORD PTR ?g_nShowShape@@3HA, eax ; g_nShowShape

; 107  : 	g_bExposure = GetPrivateProfileInt(_T("PARAMETER"), _T("AUTOEXPOSURE"), 0, g_ConfigPath);

  002bf	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  002c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  002ca	50		 push	 eax
  002cb	6a 00		 push	 0
  002cd	68 00 00 00 00	 push	 OFFSET $SG4294963829
  002d2	68 00 00 00 00	 push	 OFFSET $SG4294963828
  002d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  002dd	a3 00 00 00 00	 mov	 DWORD PTR ?g_bExposure@@3HA, eax ; g_bExposure

; 108  : 	g_thred=GetPrivateProfileInt(_T("PARAMETER"), _T("THRETH"), 0, g_ConfigPath);

  002e2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  002e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  002ed	50		 push	 eax
  002ee	6a 00		 push	 0
  002f0	68 00 00 00 00	 push	 OFFSET $SG4294963827
  002f5	68 00 00 00 00	 push	 OFFSET $SG4294963826
  002fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00300	a3 00 00 00 00	 mov	 DWORD PTR ?g_thred@@3HA, eax ; g_thred

; 109  : 	g_fGainR = GetPrivateProfileInt(_T("PARAMETER"), _T("GAIN_R"), 0, g_ConfigPath);

  00305	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  0030a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00310	50		 push	 eax
  00311	6a 00		 push	 0
  00313	68 00 00 00 00	 push	 OFFSET $SG4294963825
  00318	68 00 00 00 00	 push	 OFFSET $SG4294963824
  0031d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00323	89 45 d0	 mov	 DWORD PTR tv636[ebp], eax
  00326	f2 0f 2a 45 d0	 cvtsi2sd xmm0, DWORD PTR tv636[ebp]
  0032b	8b 45 d0	 mov	 eax, DWORD PTR tv636[ebp]
  0032e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00331	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  0033a	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR ?g_fGainR@@3NA, xmm0

; 110  : 	g_fGainB = GetPrivateProfileInt(_T("PARAMETER"), _T("GAIN_B"), 0, g_ConfigPath);

  00342	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  00347	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  0034d	50		 push	 eax
  0034e	6a 00		 push	 0
  00350	68 00 00 00 00	 push	 OFFSET $SG4294963823
  00355	68 00 00 00 00	 push	 OFFSET $SG4294963822
  0035a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00360	89 45 d8	 mov	 DWORD PTR tv642[ebp], eax
  00363	f2 0f 2a 45 d8	 cvtsi2sd xmm0, DWORD PTR tv642[ebp]
  00368	8b 4d d8	 mov	 ecx, DWORD PTR tv642[ebp]
  0036b	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0036e	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  00377	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR ?g_fGainB@@3NA, xmm0

; 111  : 	g_iMenu = GetPrivateProfileInt(_T("PARAMETER"), _T("MENU"), 3, g_ConfigPath);

  0037f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  00384	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  0038a	50		 push	 eax
  0038b	6a 03		 push	 3
  0038d	68 00 00 00 00	 push	 OFFSET $SG4294963821
  00392	68 00 00 00 00	 push	 OFFSET $SG4294963820
  00397	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0039d	a3 00 00 00 00	 mov	 DWORD PTR ?g_iMenu@@3HA, eax ; g_iMenu

; 112  : 	g_lamdar=GetPrivateProfileInt(_T("PARAMETER"), _T("LAMDAR"), 0, g_ConfigPath);

  003a2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  003a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  003ad	50		 push	 eax
  003ae	6a 00		 push	 0
  003b0	68 00 00 00 00	 push	 OFFSET $SG4294963819
  003b5	68 00 00 00 00	 push	 OFFSET $SG4294963818
  003ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  003c0	89 45 e0	 mov	 DWORD PTR tv650[ebp], eax
  003c3	f2 0f 2a 45 e0	 cvtsi2sd xmm0, DWORD PTR tv650[ebp]
  003c8	8b 55 e0	 mov	 edx, DWORD PTR tv650[ebp]
  003cb	c1 ea 1f	 shr	 edx, 31			; 0000001fH
  003ce	f2 0f 58 04 d5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
  003d7	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR ?g_lamdar@@3NA, xmm0

; 113  : 	g_lamdag=GetPrivateProfileInt(_T("PARAMETER"), _T("LAMDAG"), 0, g_ConfigPath);

  003df	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  003e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  003ea	50		 push	 eax
  003eb	6a 00		 push	 0
  003ed	68 00 00 00 00	 push	 OFFSET $SG4294963817
  003f2	68 00 00 00 00	 push	 OFFSET $SG4294963816
  003f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  003fd	89 45 d4	 mov	 DWORD PTR tv656[ebp], eax
  00400	f2 0f 2a 45 d4	 cvtsi2sd xmm0, DWORD PTR tv656[ebp]
  00405	8b 45 d4	 mov	 eax, DWORD PTR tv656[ebp]
  00408	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0040b	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00414	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR ?g_lamdag@@3NA, xmm0

; 114  : 	g_lamdab=GetPrivateProfileInt(_T("PARAMETER"), _T("LAMDAB"), 0, g_ConfigPath);

  0041c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  00421	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00427	50		 push	 eax
  00428	6a 00		 push	 0
  0042a	68 00 00 00 00	 push	 OFFSET $SG4294963815
  0042f	68 00 00 00 00	 push	 OFFSET $SG4294963814
  00434	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0043a	89 45 dc	 mov	 DWORD PTR tv662[ebp], eax
  0043d	f2 0f 2a 45 dc	 cvtsi2sd xmm0, DWORD PTR tv662[ebp]
  00442	8b 4d dc	 mov	 ecx, DWORD PTR tv662[ebp]
  00445	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00448	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  00451	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR ?g_lamdab@@3NA, xmm0

; 115  : 	g_nChangePixel = GetPrivateProfileInt(_T("PARAMETER"), _T("CHANGEPIXEL"), 3, g_ConfigPath);

  00459	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  0045e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00464	50		 push	 eax
  00465	6a 03		 push	 3
  00467	68 00 00 00 00	 push	 OFFSET $SG4294963813
  0046c	68 00 00 00 00	 push	 OFFSET $SG4294963812
  00471	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00477	a3 00 00 00 00	 mov	 DWORD PTR ?g_nChangePixel@@3HA, eax ; g_nChangePixel

; 116  : 	g_nThresh= GetPrivateProfileInt(_T("PARAMETER"), _T("THRETH2"), 255, g_ConfigPath);

  0047c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  00481	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00487	50		 push	 eax
  00488	68 ff 00 00 00	 push	 255			; 000000ffH
  0048d	68 00 00 00 00	 push	 OFFSET $SG4294963811
  00492	68 00 00 00 00	 push	 OFFSET $SG4294963810
  00497	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0049d	a3 00 00 00 00	 mov	 DWORD PTR ?g_nThresh@@3HA, eax ; g_nThresh

; 117  : 	g_nChange255 = GetPrivateProfileInt(_T("PARAMETER"), _T("CHANGE255"), 0, g_ConfigPath);

  004a2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  004a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  004ad	50		 push	 eax
  004ae	6a 00		 push	 0
  004b0	68 00 00 00 00	 push	 OFFSET $SG4294963809
  004b5	68 00 00 00 00	 push	 OFFSET $SG4294963808
  004ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  004c0	a3 00 00 00 00	 mov	 DWORD PTR ?g_nChange255@@3HA, eax ; g_nChange255

; 118  : 	g_nThreshNew= GetPrivateProfileInt(_T("PARAMETER"), _T("THRETHNEW"), 255, g_ConfigPath);

  004c5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  004ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  004d0	50		 push	 eax
  004d1	68 ff 00 00 00	 push	 255			; 000000ffH
  004d6	68 00 00 00 00	 push	 OFFSET $SG4294963807
  004db	68 00 00 00 00	 push	 OFFSET $SG4294963806
  004e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  004e6	a3 00 00 00 00	 mov	 DWORD PTR ?g_nThreshNew@@3HA, eax ; g_nThreshNew

; 119  : 
; 120  : 	g_nVCOM = GetPrivateProfileInt(_T("COM"), _T("VCOMNUM"), 0, g_ConfigPath);

  004eb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  004f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  004f6	50		 push	 eax
  004f7	6a 00		 push	 0
  004f9	68 00 00 00 00	 push	 OFFSET $SG4294963805
  004fe	68 00 00 00 00	 push	 OFFSET $SG4294963804
  00503	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00509	a3 00 00 00 00	 mov	 DWORD PTR ?g_nVCOM@@3HA, eax ; g_nVCOM

; 121  : 	g_nLCOM = GetPrivateProfileInt(_T("COM"), _T("LCOMNUM"), 0, g_ConfigPath);

  0050e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  00513	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00519	50		 push	 eax
  0051a	6a 00		 push	 0
  0051c	68 00 00 00 00	 push	 OFFSET $SG4294963803
  00521	68 00 00 00 00	 push	 OFFSET $SG4294963802
  00526	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0052c	a3 00 00 00 00	 mov	 DWORD PTR ?g_nLCOM@@3HA, eax ; g_nLCOM

; 122  : 	g_nCCOM=GetPrivateProfileInt(_T("COM"), _T("CCOMNUM"), 2, g_ConfigPath);

  00531	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  00536	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  0053c	50		 push	 eax
  0053d	6a 02		 push	 2
  0053f	68 00 00 00 00	 push	 OFFSET $SG4294963801
  00544	68 00 00 00 00	 push	 OFFSET $SG4294963800
  00549	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  0054f	a3 00 00 00 00	 mov	 DWORD PTR ?g_nCCOM@@3HA, eax ; g_nCCOM

; 123  : 
; 124  : 	g_bConnect = GetPrivateProfileInt(_T("SOCKET"), _T("ISCONNECT"), 0, g_ConfigPath);

  00554	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  00559	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  0055f	50		 push	 eax
  00560	6a 00		 push	 0
  00562	68 00 00 00 00	 push	 OFFSET $SG4294963799
  00567	68 00 00 00 00	 push	 OFFSET $SG4294963798
  0056c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  00572	a3 00 00 00 00	 mov	 DWORD PTR ?g_bConnect@@3HA, eax ; g_bConnect

; 125  : 	GetPrivateProfileString(_T("SOCKET"), _T("SERVERIP"), _T("192.168.1.248"), g_strIP.GetBuffer(32), 32, g_ConfigPath);

  00577	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  0057c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00582	50		 push	 eax
  00583	6a 20		 push	 32			; 00000020H
  00585	6a 20		 push	 32			; 00000020H
  00587	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strIP@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_strIP
  0058c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBuffer@?$CSimpleStringT@D$00@ATL@@QAEPADH@Z
  00592	50		 push	 eax
  00593	68 00 00 00 00	 push	 OFFSET $SG4294963797
  00598	68 00 00 00 00	 push	 OFFSET $SG4294963796
  0059d	68 00 00 00 00	 push	 OFFSET $SG4294963795
  005a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24

; 126  : 	g_nPort = GetPrivateProfileInt(_T("SOCKET"), _T("SERVERPORT"), 8887, g_ConfigPath);

  005a8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  005ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  005b3	50		 push	 eax
  005b4	68 b7 22 00 00	 push	 8887			; 000022b7H
  005b9	68 00 00 00 00	 push	 OFFSET $SG4294963794
  005be	68 00 00 00 00	 push	 OFFSET $SG4294963793
  005c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16
  005c9	a3 00 00 00 00	 mov	 DWORD PTR ?g_nPort@@3HA, eax ; g_nPort

; 127  : 
; 128  : 	return TRUE;  // return TRUE unless you set the focus to a control

  005ce	c6 45 e7 01	 mov	 BYTE PTR $T6[ebp], 1
  005d2	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  005d6	8d 4d e8	 lea	 ecx, DWORD PTR _strValue1$[ebp]
  005d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  005df	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  005e6	8d 4d ec	 lea	 ecx, DWORD PTR _strValue$[ebp]
  005e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  005ef	8a 45 e7	 mov	 al, BYTE PTR $T6[ebp]

; 129  : }

  005f2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  005f5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  005fc	59		 pop	 ecx
  005fd	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00600	33 cd		 xor	 ecx, ebp
  00602	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00607	8b e5		 mov	 esp, ebp
  00609	5d		 pop	 ebp
  0060a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ReadConfig@@YA_NXZ$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR _strValue$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?ReadConfig@@YA_NXZ$1:
  00009	8d 4d e8	 lea	 ecx, DWORD PTR _strValue1$[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?ReadConfig@@YA_NXZ$2:
  00012	8d 4d bc	 lea	 ecx, DWORD PTR $T3[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?ReadConfig@@YA_NXZ$3:
  0001b	8d 4d b4	 lea	 ecx, DWORD PTR $T2[ebp]
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?ReadConfig@@YA_NXZ:
  00024	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00028	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002b	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00038	33 c8		 xor	 ecx, eax
  0003a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ReadConfig@@YA_NXZ
  00044	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ReadConfig@@YA_NXZ ENDP				; ReadConfig
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\datatype.cpp
;	COMDAT ?SetConfig@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@N@Z
_TEXT	SEGMENT
$T2 = -188						; size = 132
tv155 = -56						; size = 4
tv94 = -52						; size = 4
_sql$ = -48						; size = 24
_cstrTmp$ = -24						; size = 4
_temp$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_keyname$ = 8						; size = 4
_para$ = 12						; size = 8
?SetConfig@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@N@Z PROC ; SetConfig, COMDAT

; 132  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetConfig@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec b0 00 00
	00		 sub	 esp, 176		; 000000b0H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 133  : 	CString temp;

  00032	8d 4d ec	 lea	 ecx, DWORD PTR _temp$[ebp]
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0003b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 134  : 	temp.Format(_T("%lf"), para);

  0003f	83 ec 08	 sub	 esp, 8
  00042	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _para$[ebp]
  00047	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0004c	68 00 00 00 00	 push	 OFFSET $SG4294963792
  00051	8d 45 ec	 lea	 eax, DWORD PTR _temp$[ebp]
  00054	50		 push	 eax
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  0005b	83 c4 10	 add	 esp, 16			; 00000010H

; 135  : 	WritePrivateProfileString(_T("PARAMETER"), keyname, temp, g_ConfigPath);

  0005e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ConfigPath@@3V?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@A ; g_ConfigPath
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00069	50		 push	 eax
  0006a	8d 4d ec	 lea	 ecx, DWORD PTR _temp$[ebp]
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00073	50		 push	 eax
  00074	8d 4d 08	 lea	 ecx, DWORD PTR _keyname$[ebp]
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  0007d	50		 push	 eax
  0007e	68 00 00 00 00	 push	 OFFSET $SG4294963791
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WritePrivateProfileStringA@16

; 136  : 
; 137  :  	CString cstrTmp;

  00089	8d 4d e8	 lea	 ecx, DWORD PTR _cstrTmp$[ebp]
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00092	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 138  :  	cstrTmp.Format( _T("insert into RecData (, ) Values('%s', '%lf')"), keyname, para);

  00096	83 ec 08	 sub	 esp, 8
  00099	f2 0f 10 45 0c	 movsd	 xmm0, QWORD PTR _para$[ebp]
  0009e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000a3	8b 4d 08	 mov	 ecx, DWORD PTR _keyname$[ebp]
  000a6	51		 push	 ecx
  000a7	68 00 00 00 00	 push	 OFFSET $SG4294963790
  000ac	8d 55 e8	 lea	 edx, DWORD PTR _cstrTmp$[ebp]
  000af	52		 push	 edx
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  000b6	83 c4 14	 add	 esp, 20			; 00000014H

; 139  : 	//USES_CONVERSION; 
; 140  :  	string sql=(CT2A)cstrTmp.GetString(); 

  000b9	8d 4d e8	 lea	 ecx, DWORD PTR _cstrTmp$[ebp]
  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetString@?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  000c2	50		 push	 eax
  000c3	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000c9	e8 00 00 00 00	 call	 ??0?$CA2AEX@$0IA@@ATL@@QAE@PBD@Z ; ATL::CA2AEX<128>::CA2AEX<128>
  000ce	89 45 cc	 mov	 DWORD PTR tv94[ebp], eax
  000d1	8b 45 cc	 mov	 eax, DWORD PTR tv94[ebp]
  000d4	89 45 c8	 mov	 DWORD PTR tv155[ebp], eax
  000d7	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000db	8b 4d c8	 mov	 ecx, DWORD PTR tv155[ebp]
  000de	e8 00 00 00 00	 call	 ??B?$CA2AEX@$0IA@@ATL@@QBEPADXZ ; ATL::CA2AEX<128>::operator char *
  000e3	50		 push	 eax
  000e4	8d 4d d0	 lea	 ecx, DWORD PTR _sql$[ebp]
  000e7	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000ec	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  000f0	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000f6	e8 00 00 00 00	 call	 ??1?$CA2AEX@$0IA@@ATL@@QAE@XZ ; ATL::CA2AEX<128>::~CA2AEX<128>

; 141  : 	g_Operate_list.push( sql );

  000fb	8d 4d d0	 lea	 ecx, DWORD PTR _sql$[ebp]
  000fe	51		 push	 ecx
  000ff	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Operate_list@@3V?$queue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@A ; g_Operate_list
  00104	e8 00 00 00 00	 call	 ?push@?$queue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::queue<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::push

; 142  : 
; 143  : // 	bool ret = SQLiteHelper::GetInstance().InsertData(sql);  
; 144  : // 	if (!ret)  
; 145  : // 	{  
; 146  : // 		string strTmp = SQLiteHelper::GetInstance().GetLastError();  
; 147  : // 		g_Operate_list.pop();
; 148  : // 		AfxMessageBox( _T("SaveError!") );
; 149  : // 		return;  
; 150  : // 	} 
; 151  : }

  00109	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0010d	8d 4d d0	 lea	 ecx, DWORD PTR _sql$[ebp]
  00110	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00115	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00119	8d 4d e8	 lea	 ecx, DWORD PTR _cstrTmp$[ebp]
  0011c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00122	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00126	8d 4d ec	 lea	 ecx, DWORD PTR _temp$[ebp]
  00129	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0012f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00136	8d 4d 08	 lea	 ecx, DWORD PTR _keyname$[ebp]
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0013f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00142	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00149	59		 pop	 ecx
  0014a	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014d	33 cd		 xor	 ecx, ebp
  0014f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00154	8b e5		 mov	 esp, ebp
  00156	5d		 pop	 ebp
  00157	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetConfig@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@N@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _keyname$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?SetConfig@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@N@Z$1:
  00009	8d 4d ec	 lea	 ecx, DWORD PTR _temp$[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?SetConfig@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@N@Z$2:
  00012	8d 4d e8	 lea	 ecx, DWORD PTR _cstrTmp$[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?SetConfig@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@N@Z$3:
  0001b	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00021	e9 00 00 00 00	 jmp	 ??1?$CA2AEX@$0IA@@ATL@@QAE@XZ ; ATL::CA2AEX<128>::~CA2AEX<128>
__unwindfunclet$?SetConfig@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@N@Z$4:
  00026	8d 4d d0	 lea	 ecx, DWORD PTR _sql$[ebp]
  00029	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?SetConfig@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@N@Z:
  0002e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00032	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00035	8b 8a 4c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-180]
  0003b	33 c8		 xor	 ecx, eax
  0003d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00042	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00045	33 c8		 xor	 ecx, eax
  00047	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetConfig@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@N@Z
  00051	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetConfig@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@N@Z ENDP ; SetConfig
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\datatype.cpp
;	COMDAT ?ReturnPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
_TEXT	SEGMENT
$T2 = -40						; size = 4
tv65 = -36						; size = 4
tv132 = -32						; size = 4
_nPos$ = -28						; size = 4
$T3 = -24						; size = 4
_sPath$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?ReturnPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ PROC ; ReturnPath, COMDAT

; 154  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ReturnPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0

; 155  : 	CString sPath;

  0002f	8d 4d ec	 lea	 ecx, DWORD PTR _sPath$[ebp]
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 156  : 	GetModuleFileName(NULL, sPath.GetBufferSetLength(MAX_PATH + 1), MAX_PATH);

  0003f	68 04 01 00 00	 push	 260			; 00000104H
  00044	68 05 01 00 00	 push	 261			; 00000105H
  00049	8d 4d ec	 lea	 ecx, DWORD PTR _sPath$[ebp]
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBufferSetLength@?$CSimpleStringT@D$00@ATL@@QAEPADH@Z
  00052	50		 push	 eax
  00053	6a 00		 push	 0
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12

; 157  : 	sPath.ReleaseBuffer();

  0005b	6a ff		 push	 -1
  0005d	8d 4d ec	 lea	 ecx, DWORD PTR _sPath$[ebp]
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ReleaseBuffer@?$CSimpleStringT@D$00@ATL@@QAEXH@Z

; 158  : 
; 159  : 	int nPos;
; 160  : 	nPos = sPath.ReverseFind('\\');

  00066	6a 5c		 push	 92			; 0000005cH
  00068	8d 4d ec	 lea	 ecx, DWORD PTR _sPath$[ebp]
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ReverseFind@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHD@Z
  00071	89 45 e4	 mov	 DWORD PTR _nPos$[ebp], eax

; 161  : 	sPath = sPath.Left(nPos);

  00074	8b 45 e4	 mov	 eax, DWORD PTR _nPos$[ebp]
  00077	50		 push	 eax
  00078	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  0007b	51		 push	 ecx
  0007c	8d 4d ec	 lea	 ecx, DWORD PTR _sPath$[ebp]
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Left@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z
  00085	89 45 dc	 mov	 DWORD PTR tv65[ebp], eax
  00088	8b 55 dc	 mov	 edx, DWORD PTR tv65[ebp]
  0008b	89 55 e0	 mov	 DWORD PTR tv132[ebp], edx
  0008e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00092	8b 45 e0	 mov	 eax, DWORD PTR tv132[ebp]
  00095	50		 push	 eax
  00096	8d 4d ec	 lea	 ecx, DWORD PTR _sPath$[ebp]
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  0009f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000a3	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 162  : 	return sPath;

  000ac	8d 4d ec	 lea	 ecx, DWORD PTR _sPath$[ebp]
  000af	51		 push	 ecx
  000b0	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  000b9	8b 55 e8	 mov	 edx, DWORD PTR $T3[ebp]
  000bc	83 ca 01	 or	 edx, 1
  000bf	89 55 e8	 mov	 DWORD PTR $T3[ebp], edx
  000c2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000c9	8d 4d ec	 lea	 ecx, DWORD PTR _sPath$[ebp]
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000d2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 163  : }

  000d5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000df	59		 pop	 ecx
  000e0	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e3	33 cd		 xor	 ecx, ebp
  000e5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ReturnPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR _sPath$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?ReturnPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ$1:
  00009	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?ReturnPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ReturnPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ReturnPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ENDP ; ReturnPath
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\cstringt.h
;	COMDAT ??9ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
_str1$ = 8						; size = 4
_psz2$ = 12						; size = 4
??9ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z PROC ; ATL::operator!=, COMDAT

; 2466 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2467 : 		return( str1.Compare( psz2 ) != 0 );

  00004	8b 45 0c	 mov	 eax, DWORD PTR _psz2$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _str1$[ebp]
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  00011	85 c0		 test	 eax, eax
  00013	74 09		 je	 SHORT $LN3@operator
  00015	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  0001c	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN4@operator:
  00025	8a 45 fc	 mov	 al, BYTE PTR tv68[ebp]

; 2468 : 	}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??9ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z ENDP ; ATL::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\queue
;	COMDAT ??0?$queue@PAEV?$deque@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$queue@PAEV?$deque@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@XZ PROC ; std::queue<unsigned char *,std::deque<unsigned char *,std::allocator<unsigned char *> > >::queue<unsigned char *,std::deque<unsigned char *,std::allocator<unsigned char *> > >, COMDAT
; _this$ = ecx

; 30   : 		{	// construct with empty container

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$deque@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ; std::deque<unsigned char *,std::allocator<unsigned char *> >::deque<unsigned char *,std::allocator<unsigned char *> >

; 31   : 		}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$queue@PAEV?$deque@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@XZ ENDP ; std::queue<unsigned char *,std::deque<unsigned char *,std::allocator<unsigned char *> > >::queue<unsigned char *,std::deque<unsigned char *,std::allocator<unsigned char *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??1?$deque@PAEV?$allocator@PAE@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$deque@PAEV?$allocator@PAE@std@@@std@@QAE@XZ PROC	; std::deque<unsigned char *,std::allocator<unsigned char *> >::~deque<unsigned char *,std::allocator<unsigned char *> >, COMDAT
; _this$ = ecx

; 1221 : 		{	// destroy the deque

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1222 : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$deque@PAEV?$allocator@PAE@std@@@std@@IAEXXZ ; std::deque<unsigned char *,std::allocator<unsigned char *> >::_Tidy

; 1223 : 		}

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??1?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >::~_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$deque@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ENDP	; std::deque<unsigned char *,std::allocator<unsigned char *> >::~deque<unsigned char *,std::allocator<unsigned char *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\map
;	COMDAT ??0?$map@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -2						; size = 1
$T2 = -1						; size = 1
??0?$map@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAE@XZ PROC ; std::map<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> > >::map<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> > >, COMDAT
; _this$ = ecx

; 92   : 		{	// construct empty map from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8d 4d ff	 lea	 ecx, DWORD PTR $T2[ebp]
  0000c	e8 00 00 00 00	 call	 ??0?$allocator@U?$pair@$$CBIN@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned int const ,double> >::allocator<std::pair<unsigned int const ,double> >
  00011	50		 push	 eax
  00012	8d 45 fe	 lea	 eax, DWORD PTR $T1[ebp]
  00015	50		 push	 eax
  00016	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIN@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >

; 93   : 		}

  0001e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??0?$map@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAE@XZ ENDP ; std::map<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> > >::map<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >, COMDAT
; _this$ = ecx

; 1188 : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1189 : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Tidy

; 1190 : 		}

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??1?$_Tree_comp@$0A@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE@XZ
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\queue
;	COMDAT ??0?$queue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$queue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAE@XZ PROC ; std::queue<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::queue<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 30   : 		{	// construct with empty container

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 31   : 		}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$queue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAE@XZ ENDP ; std::queue<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::queue<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\queue
;	COMDAT ?push@?$queue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push@?$queue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::queue<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::push, COMDAT
; _this$ = ecx

; 154  : 		{	// insert element at beginning

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 155  : 		c.push_back(_Val);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?push_back@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 156  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?push@?$queue@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::queue<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::push
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??1?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 1221 : 		{	// destroy the deque

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1222 : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy

; 1223 : 		}

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??1?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlconv.h
;	COMDAT ??0?$CA2AEX@$0IA@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_psz$ = 8						; size = 4
??0?$CA2AEX@$0IA@@ATL@@QAE@PBD@Z PROC			; ATL::CA2AEX<128>::CA2AEX<128>, COMDAT
; _this$ = ecx

; 234  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	89 01		 mov	 DWORD PTR [ecx], eax

; 235  : 		Init( psz );

  00012	8b 55 08	 mov	 edx, DWORD PTR _psz$[ebp]
  00015	52		 push	 edx
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?Init@?$CA2AEX@$0IA@@ATL@@AAEXPBD@Z ; ATL::CA2AEX<128>::Init

; 236  : 	}

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??0?$CA2AEX@$0IA@@ATL@@QAE@PBD@Z ENDP			; ATL::CA2AEX<128>::CA2AEX<128>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlconv.h
;	COMDAT ??1?$CA2AEX@$0IA@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CA2AEX@$0IA@@ATL@@QAE@XZ PROC			; ATL::CA2AEX<128>::~CA2AEX<128>, COMDAT
; _this$ = ecx

; 247  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 248  : 		AtlConvFreeMemory(m_psz,m_szBuffer,t_nBufferLength);

  00007	68 80 00 00 00	 push	 128			; 00000080H
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	52		 push	 edx
  00019	e8 00 00 00 00	 call	 ??$AtlConvFreeMemory@D@ATL@@YAXPAD0H@Z ; ATL::AtlConvFreeMemory<char>
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 249  : 	}

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??1?$CA2AEX@$0IA@@ATL@@QAE@XZ ENDP			; ATL::CA2AEX<128>::~CA2AEX<128>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlconv.h
;	COMDAT ??B?$CA2AEX@$0IA@@ATL@@QBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CA2AEX@$0IA@@ATL@@QBEPADXZ PROC			; ATL::CA2AEX<128>::operator char *, COMDAT
; _this$ = ecx

; 252  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 		return( m_psz );

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 254  : 	}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??B?$CA2AEX@$0IA@@ATL@@QBEPADXZ ENDP			; ATL::CA2AEX<128>::operator char *
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Tree_comp@$0A@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_comp@$0A@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_comp<0,std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::~_Tree_comp<0,std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Tree_buy@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAE@XZ
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Tree_comp@$0A@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_comp<0,std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::~_Tree_comp<0,std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Tree_buy@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_buy@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAE@XZ PROC ; std::_Tree_buy<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > >::~_Tree_buy<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAE@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Tree_buy@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAE@XZ ENDP ; std::_Tree_buy<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > >::~_Tree_buy<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??0?$deque@PAEV?$allocator@PAE@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$deque@PAEV?$allocator@PAE@std@@@std@@QAE@XZ PROC	; std::deque<unsigned char *,std::allocator<unsigned char *> >::deque<unsigned char *,std::allocator<unsigned char *> >, COMDAT
; _this$ = ecx

; 956  : 		{	// construct empty deque

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  0000c	e8 00 00 00 00	 call	 ??0?$allocator@PAE@std@@QAE@XZ ; std::allocator<unsigned char *>::allocator<unsigned char *>
  00011	50		 push	 eax
  00012	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z ; std::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >

; 957  : 		}

  0001a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0?$deque@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ENDP	; std::deque<unsigned char *,std::allocator<unsigned char *> >::deque<unsigned char *,std::allocator<unsigned char *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Tidy@?$deque@PAEV?$allocator@PAE@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -19						; size = 1
$T2 = -18						; size = 1
$T3 = -17						; size = 1
__Block$4 = -16						; size = 4
_this$ = -12						; size = 4
__Almap$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?_Tidy@?$deque@PAEV?$allocator@PAE@std@@@std@@IAEXXZ PROC ; std::deque<unsigned char *,std::allocator<unsigned char *> >::_Tidy, COMDAT
; _this$ = ecx

; 1857 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1858 : 		_Alpty _Almap(this->_Getal());

  00013	8d 45 ee	 lea	 eax, DWORD PTR $T2[ebp]
  00016	50		 push	 eax
  00017	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAE@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >::_Getal
  0001f	50		 push	 eax
  00020	8d 4d fb	 lea	 ecx, DWORD PTR __Almap$[ebp]
  00023	e8 00 00 00 00	 call	 ??$?0U?$_Wrap_alloc@V?$allocator@PAE@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAPAE@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@PAE@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<unsigned char * *> >::_Wrap_alloc<std::allocator<unsigned char * *> ><std::_Wrap_alloc<std::allocator<unsigned char *> > >
$LN6@Tidy:

; 1859 : 		while (!empty())

  00028	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?empty@?$deque@PAEV?$allocator@PAE@std@@@std@@QBE_NXZ ; std::deque<unsigned char *,std::allocator<unsigned char *> >::empty
  00030	0f b6 c8	 movzx	 ecx, al
  00033	85 c9		 test	 ecx, ecx
  00035	75 0a		 jne	 SHORT $LN5@Tidy

; 1860 : 			pop_back();

  00037	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?pop_back@?$deque@PAEV?$allocator@PAE@std@@@std@@QAEXXZ ; std::deque<unsigned char *,std::allocator<unsigned char *> >::pop_back
  0003f	eb e7		 jmp	 SHORT $LN6@Tidy
$LN5@Tidy:

; 1861 : 		for (size_type _Block = this->_Mapsize; 0 < _Block; )

  00041	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00044	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00047	89 45 f0	 mov	 DWORD PTR __Block$4[ebp], eax
$LN4@Tidy:
  0004a	83 7d f0 00	 cmp	 DWORD PTR __Block$4[ebp], 0
  0004e	76 5c		 jbe	 SHORT $LN3@Tidy

; 1862 : 			{	// free storage for a block and destroy pointer
; 1863 : 			if (this->_Map[--_Block] != pointer())

  00050	8b 4d f0	 mov	 ecx, DWORD PTR __Block$4[ebp]
  00053	83 e9 01	 sub	 ecx, 1
  00056	89 4d f0	 mov	 DWORD PTR __Block$4[ebp], ecx
  00059	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0005c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0005f	8b 4d f0	 mov	 ecx, DWORD PTR __Block$4[ebp]
  00062	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  00066	74 42		 je	 SHORT $LN2@Tidy

; 1864 : 				{	// free block and destroy its pointer
; 1865 : 				this->_Getal().deallocate(this->_Map[_Block], _DEQUESIZ);

  00068	6a 04		 push	 4
  0006a	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0006d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00070	8b 4d f0	 mov	 ecx, DWORD PTR __Block$4[ebp]
  00073	8b 14 88	 mov	 edx, DWORD PTR [eax+ecx*4]
  00076	52		 push	 edx
  00077	8d 45 ef	 lea	 eax, DWORD PTR $T3[ebp]
  0007a	50		 push	 eax
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	e8 00 00 00 00	 call	 ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAE@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >::_Getal
  00083	8b c8		 mov	 ecx, eax
  00085	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@PAE@std@@@std@@QAEXPAPAEI@Z ; std::_Wrap_alloc<std::allocator<unsigned char *> >::deallocate

; 1866 : 				this->_Getal().destroy(&this->_Map[_Block]);

  0008a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00090	8b 45 f0	 mov	 eax, DWORD PTR __Block$4[ebp]
  00093	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  00096	51		 push	 ecx
  00097	8d 55 ed	 lea	 edx, DWORD PTR $T1[ebp]
  0009a	52		 push	 edx
  0009b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0009e	e8 00 00 00 00	 call	 ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAE@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >::_Getal
  000a3	8b c8		 mov	 ecx, eax
  000a5	e8 00 00 00 00	 call	 ??$destroy@PAPAE@?$_Wrap_alloc@V?$allocator@PAE@std@@@std@@QAEXPAPAPAE@Z ; std::_Wrap_alloc<std::allocator<unsigned char *> >::destroy<unsigned char * *>
$LN2@Tidy:

; 1867 : 				}
; 1868 : 			}

  000aa	eb 9e		 jmp	 SHORT $LN4@Tidy
$LN3@Tidy:

; 1869 : 
; 1870 : 		if (this->_Map != _Mapptr())

  000ac	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000af	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000b3	74 16		 je	 SHORT $LN1@Tidy

; 1871 : 			_Almap.deallocate(this->_Map,
; 1872 : 				this->_Mapsize);	// free storage for map

  000b5	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000bb	52		 push	 edx
  000bc	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c2	51		 push	 ecx
  000c3	8d 4d fb	 lea	 ecx, DWORD PTR __Almap$[ebp]
  000c6	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@PAPAE@std@@@std@@QAEXPAPAPAEI@Z ; std::_Wrap_alloc<std::allocator<unsigned char * *> >::deallocate
$LN1@Tidy:

; 1873 : 		this->_Mapsize = 0;

  000cb	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000ce	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 1874 : 		this->_Map = _Mapptr();

  000d5	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000d8	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1875 : 		}

  000df	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e2	33 cd		 xor	 ecx, ebp
  000e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c3		 ret	 0
?_Tidy@?$deque@PAEV?$allocator@PAE@std@@@std@@IAEXXZ ENDP ; std::deque<unsigned char *,std::allocator<unsigned char *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??1?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >::~_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >, COMDAT
; _this$ = ecx

; 883  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		_Free_proxy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >::_Free_proxy

; 885  : 		}

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??1?$_Deque_val@U?$_Deque_simple_types@PAE@std@@@std@@QAE@XZ
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >::~_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIN@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIN@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >, COMDAT
; _this$ = ecx

; 1071 : 		{	// construct empty tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR __Al$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??0?$_Tree_comp@$0A@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIN@std@@@1@@Z ; std::_Tree_comp<0,std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Tree_comp<0,std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >

; 1072 : 		}

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
??0?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIN@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
$T4 = -12						; size = 4
$T5 = -8						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 2215 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2216 : 		erase(begin(), end());

  00009	8d 45 f0	 lea	 eax, DWORD PTR $T3[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::end
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	89 4d f8	 mov	 DWORD PTR $T5[ebp], ecx
  0001a	8d 55 ec	 lea	 edx, DWORD PTR $T2[ebp]
  0001d	52		 push	 edx
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::begin
  00026	8b 00		 mov	 eax, DWORD PTR [eax]
  00028	89 45 f4	 mov	 DWORD PTR $T4[ebp], eax
  0002b	8b 4d f8	 mov	 ecx, DWORD PTR $T5[ebp]
  0002e	51		 push	 ecx
  0002f	8b 55 f4	 mov	 edx, DWORD PTR $T4[ebp]
  00032	52		 push	 edx
  00033	8d 45 e8	 lea	 eax, DWORD PTR $T1[ebp]
  00036	50		 push	 eax
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::erase

; 2217 : 		}

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$pair@$$CBIN@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$pair@$$CBIN@std@@@std@@QAE@XZ PROC	; std::allocator<std::pair<unsigned int const ,double> >::allocator<std::pair<unsigned int const ,double> >, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@U?$pair@$$CBIN@std@@@std@@QAE@XZ ENDP	; std::allocator<std::pair<unsigned int const ,double> >::allocator<std::pair<unsigned int const ,double> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAE@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >, COMDAT
; _this$ = ecx

; 782  : 		{	// destroy head node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 783  : 		_Freeheadnode(this->_Myhead);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Freeheadnode

; 784  : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??0?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 956  : 		{	// construct empty deque

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  0000c	e8 00 00 00 00	 call	 ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00011	50		 push	 eax
  00012	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >

; 957  : 		}

  0001a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?push_back@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
__Newoff$ = -16						; size = 4
__Block$ = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -2						; size = 1
$T2 = -1						; size = 1
__Val$ = 8						; size = 4
?push_back@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back, COMDAT
; _this$ = ecx

; 1485 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1486 : 		this->_Orphan_all();

  0000a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ

; 1487 : 		_PUSH_BACK_BEGIN;

  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00019	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	03 41 10	 add	 eax, DWORD PTR [ecx+16]
  0001f	33 d2		 xor	 edx, edx
  00021	b9 01 00 00 00	 mov	 ecx, 1
  00026	f7 f1		 div	 ecx
  00028	85 d2		 test	 edx, edx
  0002a	75 1b		 jne	 SHORT $LN2@push_back
  0002c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0002f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00032	83 c0 01	 add	 eax, 1
  00035	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	39 41 08	 cmp	 DWORD PTR [ecx+8], eax
  0003b	77 0a		 ja	 SHORT $LN2@push_back
  0003d	6a 01		 push	 1
  0003f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?_Growmap@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Growmap
$LN2@push_back:
  00047	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0004a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0004d	83 e8 01	 sub	 eax, 1
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	23 41 0c	 and	 eax, DWORD PTR [ecx+12]
  00056	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00059	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  0005c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00062	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00065	03 4a 10	 add	 ecx, DWORD PTR [edx+16]
  00068	89 4d f0	 mov	 DWORD PTR __Newoff$[ebp], ecx
  0006b	8b 45 f0	 mov	 eax, DWORD PTR __Newoff$[ebp]
  0006e	50		 push	 eax
  0006f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	e8 00 00 00 00	 call	 ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getblock
  00077	89 45 f4	 mov	 DWORD PTR __Block$[ebp], eax
  0007a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00080	8b 45 f4	 mov	 eax, DWORD PTR __Block$[ebp]
  00083	83 3c 82 00	 cmp	 DWORD PTR [edx+eax*4], 0
  00087	75 21		 jne	 SHORT $LN1@push_back
  00089	6a 01		 push	 1
  0008b	8d 4d ff	 lea	 ecx, DWORD PTR $T2[ebp]
  0008e	51		 push	 ecx
  0008f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	e8 00 00 00 00	 call	 ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
  00097	8b c8		 mov	 ecx, eax
  00099	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocate
  0009e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000a1	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000a4	8b 55 f4	 mov	 edx, DWORD PTR __Block$[ebp]
  000a7	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax
$LN1@push_back:

; 1488 : 		this->_Getal().construct(
; 1489 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

  000aa	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000ad	50		 push	 eax
  000ae	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000b4	8b 45 f0	 mov	 eax, DWORD PTR __Newoff$[ebp]
  000b7	33 d2		 xor	 edx, edx
  000b9	be 01 00 00 00	 mov	 esi, 1
  000be	f7 f6		 div	 esi
  000c0	6b d2 18	 imul	 edx, 24			; 00000018H
  000c3	8b 45 f4	 mov	 eax, DWORD PTR __Block$[ebp]
  000c6	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  000c9	52		 push	 edx
  000ca	8d 4d fe	 lea	 ecx, DWORD PTR $T1[ebp]
  000cd	51		 push	 ecx
  000ce	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d1	e8 00 00 00 00	 call	 ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
  000d6	8b c8		 mov	 ecx, eax
  000d8	e8 00 00 00 00	 call	 ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>

; 1490 : 		_PUSH_BACK_END;

  000dd	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000e0	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000e3	83 c0 01	 add	 eax, 1
  000e6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e9	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 1491 : 		}

  000ec	5e		 pop	 esi
  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c2 04 00	 ret	 4
?push_back@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Tidy@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -19						; size = 1
$T2 = -18						; size = 1
$T3 = -17						; size = 1
__Block$4 = -16						; size = 4
_this$ = -12						; size = 4
__Almap$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?_Tidy@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ PROC ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy, COMDAT
; _this$ = ecx

; 1857 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1858 : 		_Alpty _Almap(this->_Getal());

  00013	8d 45 ee	 lea	 eax, DWORD PTR $T2[ebp]
  00016	50		 push	 eax
  00017	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
  0001f	50		 push	 eax
  00020	8d 4d fb	 lea	 ecx, DWORD PTR __Almap$[ebp]
  00023	e8 00 00 00 00	 call	 ??$?0U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> >::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> ><std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
$LN6@Tidy:

; 1859 : 		while (!empty())

  00028	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?empty@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty
  00030	0f b6 c8	 movzx	 ecx, al
  00033	85 c9		 test	 ecx, ecx
  00035	75 0a		 jne	 SHORT $LN5@Tidy

; 1860 : 			pop_back();

  00037	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?pop_back@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::pop_back
  0003f	eb e7		 jmp	 SHORT $LN6@Tidy
$LN5@Tidy:

; 1861 : 		for (size_type _Block = this->_Mapsize; 0 < _Block; )

  00041	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00044	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00047	89 45 f0	 mov	 DWORD PTR __Block$4[ebp], eax
$LN4@Tidy:
  0004a	83 7d f0 00	 cmp	 DWORD PTR __Block$4[ebp], 0
  0004e	76 5c		 jbe	 SHORT $LN3@Tidy

; 1862 : 			{	// free storage for a block and destroy pointer
; 1863 : 			if (this->_Map[--_Block] != pointer())

  00050	8b 4d f0	 mov	 ecx, DWORD PTR __Block$4[ebp]
  00053	83 e9 01	 sub	 ecx, 1
  00056	89 4d f0	 mov	 DWORD PTR __Block$4[ebp], ecx
  00059	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0005c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0005f	8b 4d f0	 mov	 ecx, DWORD PTR __Block$4[ebp]
  00062	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  00066	74 42		 je	 SHORT $LN2@Tidy

; 1864 : 				{	// free block and destroy its pointer
; 1865 : 				this->_Getal().deallocate(this->_Map[_Block], _DEQUESIZ);

  00068	6a 01		 push	 1
  0006a	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0006d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00070	8b 4d f0	 mov	 ecx, DWORD PTR __Block$4[ebp]
  00073	8b 14 88	 mov	 edx, DWORD PTR [eax+ecx*4]
  00076	52		 push	 edx
  00077	8d 45 ef	 lea	 eax, DWORD PTR $T3[ebp]
  0007a	50		 push	 eax
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	e8 00 00 00 00	 call	 ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
  00083	8b c8		 mov	 ecx, eax
  00085	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deallocate

; 1866 : 				this->_Getal().destroy(&this->_Map[_Block]);

  0008a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00090	8b 45 f0	 mov	 eax, DWORD PTR __Block$4[ebp]
  00093	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  00096	51		 push	 ecx
  00097	8d 55 ed	 lea	 edx, DWORD PTR $T1[ebp]
  0009a	52		 push	 edx
  0009b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0009e	e8 00 00 00 00	 call	 ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
  000a3	8b c8		 mov	 ecx, eax
  000a5	e8 00 00 00 00	 call	 ??$destroy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
$LN2@Tidy:

; 1867 : 				}
; 1868 : 			}

  000aa	eb 9e		 jmp	 SHORT $LN4@Tidy
$LN3@Tidy:

; 1869 : 
; 1870 : 		if (this->_Map != _Mapptr())

  000ac	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000af	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000b3	74 16		 je	 SHORT $LN1@Tidy

; 1871 : 			_Almap.deallocate(this->_Map,
; 1872 : 				this->_Mapsize);	// free storage for map

  000b5	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000bb	52		 push	 edx
  000bc	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c2	51		 push	 ecx
  000c3	8d 4d fb	 lea	 ecx, DWORD PTR __Almap$[ebp]
  000c6	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> >::deallocate
$LN1@Tidy:

; 1873 : 		this->_Mapsize = 0;

  000cb	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000ce	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 1874 : 		this->_Map = _Mapptr();

  000d5	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000d8	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1875 : 		}

  000df	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e2	33 cd		 xor	 ecx, ebp
  000e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c3		 ret	 0
?_Tidy@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ENDP ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??1?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 883  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		_Free_proxy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Free_proxy

; 885  : 		}

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??1?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlconv.h
;	COMDAT ?Init@?$CA2AEX@$0IA@@ATL@@AAEXPBD@Z
_TEXT	SEGMENT
tv68 = -24						; size = 4
tv86 = -20						; size = 4
_nLength$ = -16						; size = 4
_this$ = -12						; size = 4
tv83 = -8						; size = 4
tv89 = -1						; size = 1
_psz$ = 8						; size = 4
?Init@?$CA2AEX@$0IA@@ATL@@AAEXPBD@Z PROC		; ATL::CA2AEX<128>::Init, COMDAT
; _this$ = ecx

; 258  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 259  : 		if (psz == NULL)

  00009	83 7d 08 00	 cmp	 DWORD PTR _psz$[ebp], 0
  0000d	75 0b		 jne	 SHORT $LN1@Init

; 260  : 		{
; 261  : 			m_psz = NULL;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 262  : 			return;

  00018	eb 69		 jmp	 SHORT $LN2@Init
$LN1@Init:

; 263  : 		}
; 264  : 		int nLength = static_cast<int>(strlen( psz ))+1;

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _psz$[ebp]
  0001d	89 4d f8	 mov	 DWORD PTR tv83[ebp], ecx
  00020	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  00023	83 c2 01	 add	 edx, 1
  00026	89 55 ec	 mov	 DWORD PTR tv86[ebp], edx
$LL4@Init:
  00029	8b 45 f8	 mov	 eax, DWORD PTR tv83[ebp]
  0002c	8a 08		 mov	 cl, BYTE PTR [eax]
  0002e	88 4d ff	 mov	 BYTE PTR tv89[ebp], cl
  00031	83 45 f8 01	 add	 DWORD PTR tv83[ebp], 1
  00035	80 7d ff 00	 cmp	 BYTE PTR tv89[ebp], 0
  00039	75 ee		 jne	 SHORT $LL4@Init
  0003b	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  0003e	2b 55 ec	 sub	 edx, DWORD PTR tv86[ebp]
  00041	89 55 e8	 mov	 DWORD PTR tv68[ebp], edx
  00044	8b 45 e8	 mov	 eax, DWORD PTR tv68[ebp]
  00047	83 c0 01	 add	 eax, 1
  0004a	89 45 f0	 mov	 DWORD PTR _nLength$[ebp], eax

; 265  : 		AtlConvAllocMemory(&m_psz,nLength,m_szBuffer,t_nBufferLength);		

  0004d	68 80 00 00 00	 push	 128			; 00000080H
  00052	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	83 c1 04	 add	 ecx, 4
  00058	51		 push	 ecx
  00059	8b 55 f0	 mov	 edx, DWORD PTR _nLength$[ebp]
  0005c	52		 push	 edx
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ??$AtlConvAllocMemory@D@ATL@@YAXPAPADHPADH@Z ; ATL::AtlConvAllocMemory<char>
  00066	83 c4 10	 add	 esp, 16			; 00000010H

; 266  : 		Checked::memcpy_s( m_psz, nLength*sizeof( char ), psz, nLength*sizeof( char ));

  00069	8b 4d f0	 mov	 ecx, DWORD PTR _nLength$[ebp]
  0006c	51		 push	 ecx
  0006d	8b 55 08	 mov	 edx, DWORD PTR _psz$[ebp]
  00070	52		 push	 edx
  00071	8b 45 f0	 mov	 eax, DWORD PTR _nLength$[ebp]
  00074	50		 push	 eax
  00075	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007a	52		 push	 edx
  0007b	e8 00 00 00 00	 call	 ?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z ; ATL::Checked::memcpy_s
  00080	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@Init:

; 267  : 	}

  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 04 00	 ret	 4
?Init@?$CA2AEX@$0IA@@ATL@@AAEXPBD@Z ENDP		; ATL::CA2AEX<128>::Init
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Deque_val@U?$_Deque_simple_types@PAE@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Deque_val@U?$_Deque_simple_types@PAE@std@@@std@@QAE@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<unsigned char *> >::~_Deque_val<std::_Deque_simple_types<unsigned char *> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Container_base12@std@@QAE@XZ
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1?$_Deque_val@U?$_Deque_simple_types@PAE@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<unsigned char *> >::~_Deque_val<std::_Deque_simple_types<unsigned char *> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Container_base12@std@@QAE@XZ
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?empty@?$deque@PAEV?$allocator@PAE@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv70 = -4						; size = 4
?empty@?$deque@PAEV?$allocator@PAE@std@@@std@@QBE_NXZ PROC ; std::deque<unsigned char *,std::allocator<unsigned char *> >::empty, COMDAT
; _this$ = ecx

; 1381 : 		{	// test if sequence is empty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1382 : 		return (this->_Mysize == 0);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00010	75 09		 jne	 SHORT $LN3@empty
  00012	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv70[ebp], 1
  00019	eb 07		 jmp	 SHORT $LN4@empty
$LN3@empty:
  0001b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN4@empty:
  00022	8a 45 fc	 mov	 al, BYTE PTR tv70[ebp]

; 1383 : 		}

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?empty@?$deque@PAEV?$allocator@PAE@std@@@std@@QBE_NXZ ENDP ; std::deque<unsigned char *,std::allocator<unsigned char *> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?pop_back@?$deque@PAEV?$allocator@PAE@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Block$1 = -20						; size = 4
tv144 = -16						; size = 4
__Newoff$2 = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
?pop_back@?$deque@PAEV?$allocator@PAE@std@@@std@@QAEXXZ PROC ; std::deque<unsigned char *,std::allocator<unsigned char *> >::pop_back, COMDAT
; _this$ = ecx

; 1494 : 		{	// erase element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1495 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1496 : 		if (empty())
; 1497 : 			_DEBUG_ERROR("deque empty before pop");
; 1498 : 		else
; 1499 : 			{	// something to erase, do it
; 1500 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1501 : 			_Orphan_off(_Newoff);
; 1502 : 			size_type _Block = this->_Getblock(_Newoff);
; 1503 : 			this->_Getal().destroy(
; 1504 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1505 : 			if (--this->_Mysize == 0)
; 1506 : 				this->_Myoff = 0;
; 1507 : 			}
; 1508 : 
; 1509 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1510 : 		if (!empty())

  0000a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ?empty@?$deque@PAEV?$allocator@PAE@std@@@std@@QBE_NXZ ; std::deque<unsigned char *,std::allocator<unsigned char *> >::empty
  00012	0f b6 c0	 movzx	 eax, al
  00015	85 c0		 test	 eax, eax
  00017	75 76		 jne	 SHORT $LN3@pop_back

; 1511 : 			{	// something to erase, do it
; 1512 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;

  00019	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00025	8d 54 0a ff	 lea	 edx, DWORD PTR [edx+ecx-1]
  00029	89 55 f4	 mov	 DWORD PTR __Newoff$2[ebp], edx

; 1513 : 			size_type _Block = this->_Getblock(_Newoff);

  0002c	8b 45 f4	 mov	 eax, DWORD PTR __Newoff$2[ebp]
  0002f	50		 push	 eax
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@PAE@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<unsigned char *> >::_Getblock
  00038	89 45 ec	 mov	 DWORD PTR __Block$1[ebp], eax

; 1514 : 			this->_Getal().destroy(
; 1515 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);

  0003b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Newoff$2[ebp]
  00044	33 d2		 xor	 edx, edx
  00046	be 04 00 00 00	 mov	 esi, 4
  0004b	f7 f6		 div	 esi
  0004d	8b 45 ec	 mov	 eax, DWORD PTR __Block$1[ebp]
  00050	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00053	8d 14 91	 lea	 edx, DWORD PTR [ecx+edx*4]
  00056	52		 push	 edx
  00057	8d 45 ff	 lea	 eax, DWORD PTR $T3[ebp]
  0005a	50		 push	 eax
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAE@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >::_Getal
  00063	8b c8		 mov	 ecx, eax
  00065	e8 00 00 00 00	 call	 ??$destroy@PAE@?$_Wrap_alloc@V?$allocator@PAE@std@@@std@@QAEXPAPAE@Z ; std::_Wrap_alloc<std::allocator<unsigned char *> >::destroy<unsigned char *>

; 1516 : 			if (--this->_Mysize == 0)

  0006a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00070	83 ea 01	 sub	 edx, 1
  00073	89 55 f0	 mov	 DWORD PTR tv144[ebp], edx
  00076	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00079	8b 4d f0	 mov	 ecx, DWORD PTR tv144[ebp]
  0007c	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0007f	83 7d f0 00	 cmp	 DWORD PTR tv144[ebp], 0
  00083	75 0a		 jne	 SHORT $LN3@pop_back

; 1517 : 				this->_Myoff = 0;

  00085	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00088	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
$LN3@pop_back:

; 1518 : 			}
; 1519 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1520 : 		}

  0008f	5e		 pop	 esi
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
?pop_back@?$deque@PAEV?$allocator@PAE@std@@@std@@QAEXXZ ENDP ; std::deque<unsigned char *,std::allocator<unsigned char *> >::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAE@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAE@std@@QAE@XZ PROC			; std::allocator<unsigned char *>::allocator<unsigned char *>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@PAE@std@@QAE@XZ ENDP			; std::allocator<unsigned char *>::allocator<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z PROC ; std::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >, COMDAT
; _this$ = ecx

; 877  : 	_Deque_alloc(const _Alloc& = _Alloc())

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??0?$_Deque_val@U?$_Deque_simple_types@PAE@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<unsigned char *> >::_Deque_val<std::_Deque_simple_types<unsigned char *> >
  0002e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 878  : 		{	// construct allocators from _Al
; 879  : 		_Alloc_proxy();

  00035	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >::_Alloc_proxy

; 880  : 		}

  0003d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00044	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Deque_val@U?$_Deque_simple_types@PAE@std@@@std@@QAE@XZ
__ehhandler$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Alproxy$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 906  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 907  : 		typename _Alty::template rebind<_Container_proxy>::other
; 908  : 			_Alproxy;

  00013	8d 4d fb	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00016	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> >

; 909  : 		this->_Orphan_all();

  0001b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ

; 910  : 		_Alproxy.destroy(this->_Myproxy);

  00024	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 08		 mov	 ecx, DWORD PTR [eax]
  00029	51		 push	 ecx
  0002a	8d 4d fb	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>

; 911  : 		_Alproxy.deallocate(this->_Myproxy, 1);

  00032	6a 01		 push	 1
  00034	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00037	8b 02		 mov	 eax, DWORD PTR [edx]
  00039	50		 push	 eax
  0003a	8d 4d fb	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  0003d	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate

; 912  : 		this->_Myproxy = 0;

  00042	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 913  : 		}

  0004b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004e	33 cd		 xor	 ecx, ebp
  00050	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAE@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAE@std@@@2@XZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >::_Getal, COMDAT
; _this$ = ecx

; 916  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 917  : 		return (_Alty());

  00007	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@PAE@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<unsigned char *> >::_Wrap_alloc<std::allocator<unsigned char *> >
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 918  : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAE@std@@@2@XZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAE@std@@@std@@QAEXPAPAEI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAE@std@@@std@@QAEXPAPAEI@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned char *> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAE@std@@QAEXPAPAEI@Z ; std::allocator<unsigned char *>::deallocate

; 888  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAE@std@@@std@@QAEXPAPAEI@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned char *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAPAE@std@@@std@@QAEXPAPAPAEI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAPAE@std@@@std@@QAEXPAPAPAEI@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned char * *> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAPAE@std@@QAEXPAPAPAEI@Z ; std::allocator<unsigned char * *>::deallocate

; 888  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAPAE@std@@@std@@QAEXPAPAPAEI@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned char * *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::begin, COMDAT
; _this$ = ecx

; 1210 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1211 : 		return (iterator(_Lmost(), this));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Lmost
  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
  00015	51		 push	 ecx
  00016	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1212 : 		}

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::end, COMDAT
; _this$ = ecx

; 1220 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1221 : 		return (iterator(this->_Myhead, this));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	52		 push	 edx
  00011	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00014	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >
  00019	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1222 : 		}

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
$T4 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::erase, COMDAT
; _this$ = ecx

; 1508 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1509 : 		if (_First == begin() && _Last == end())

  00009	8d 45 f8	 lea	 eax, DWORD PTR $T4[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::begin
  00015	50		 push	 eax
  00016	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00019	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::operator==
  0001e	0f b6 c8	 movzx	 ecx, al
  00021	85 c9		 test	 ecx, ecx
  00023	74 37		 je	 SHORT $LN2@erase
  00025	8d 55 f4	 lea	 edx, DWORD PTR $T3[ebp]
  00028	52		 push	 edx
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::end
  00031	50		 push	 eax
  00032	8d 4d 10	 lea	 ecx, DWORD PTR __Last$[ebp]
  00035	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::operator==
  0003a	0f b6 c0	 movzx	 eax, al
  0003d	85 c0		 test	 eax, eax
  0003f	74 1b		 je	 SHORT $LN2@erase

; 1510 : 			{	// erase all
; 1511 : 			clear();

  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::clear

; 1512 : 			return (begin());

  00049	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::begin
  00055	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00058	eb 47		 jmp	 SHORT $LN5@erase

; 1513 : 			}
; 1514 : 		else

  0005a	eb 45		 jmp	 SHORT $LN5@erase
$LN2@erase:

; 1515 : 			{	// partial erase, one at a time
; 1516 : 			while (_First != _Last)

  0005c	8d 55 10	 lea	 edx, DWORD PTR __Last$[ebp]
  0005f	52		 push	 edx
  00060	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00063	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::operator!=
  00068	0f b6 c0	 movzx	 eax, al
  0006b	85 c0		 test	 eax, eax
  0006d	74 1f		 je	 SHORT $LN1@erase

; 1517 : 				erase(_First++);

  0006f	6a 00		 push	 0
  00071	8d 4d f0	 lea	 ecx, DWORD PTR $T2[ebp]
  00074	51		 push	 ecx
  00075	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00078	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::operator++
  0007d	8b 10		 mov	 edx, DWORD PTR [eax]
  0007f	52		 push	 edx
  00080	8d 45 ec	 lea	 eax, DWORD PTR $T1[ebp]
  00083	50		 push	 eax
  00084	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::erase
  0008c	eb ce		 jmp	 SHORT $LN2@erase
$LN1@erase:

; 1518 : 			return (iterator(_First._Ptr, this));

  0008e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	51		 push	 ecx
  00092	8b 55 0c	 mov	 edx, DWORD PTR __First$[ebp]
  00095	52		 push	 edx
  00096	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00099	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >
  0009e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase:

; 1519 : 			}
; 1520 : 		}

  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??0?$_Tree_comp@$0A@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIN@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree_comp@$0A@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIN@std@@@1@@Z PROC ; std::_Tree_comp<0,std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Tree_comp<0,std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >, COMDAT
; _this$ = ecx

; 1007 : 		{	// construct ordering predicate

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR __Al$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$_Tree_buy@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBIN@std@@@1@@Z ; std::_Tree_buy<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > >::_Tree_buy<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > >

; 1008 : 		}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
??0?$_Tree_comp@$0A@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIN@std@@@1@@Z ENDP ; std::_Tree_comp<0,std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Tree_comp<0,std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 1
$T2 = -3						; size = 1
$T3 = -2						; size = 1
$T4 = -1						; size = 1
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Freeheadnode, COMDAT
; _this$ = ecx

; 862  : 		{	// free head node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 863  : 		this->_Getal().destroy(
; 864  : 			_STD addressof(this->_Left(_Pnode)));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$addressof@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *>
  0001b	83 c4 04	 add	 esp, 4
  0001e	50		 push	 eax
  0001f	8d 4d ff	 lea	 ecx, DWORD PTR $T4[ebp]
  00022	51		 push	 ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Getal
  0002b	8b c8		 mov	 ecx, eax
  0002d	e8 00 00 00 00	 call	 ??$destroy@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::destroy<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *>

; 865  : 		this->_Getal().destroy(
; 866  : 			_STD addressof(this->_Parent(_Pnode)));

  00032	8b 55 08	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  0003b	83 c4 04	 add	 esp, 4
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ??$addressof@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *>
  00044	83 c4 04	 add	 esp, 4
  00047	50		 push	 eax
  00048	8d 45 fe	 lea	 eax, DWORD PTR $T3[ebp]
  0004b	50		 push	 eax
  0004c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Getal
  00054	8b c8		 mov	 ecx, eax
  00056	e8 00 00 00 00	 call	 ??$destroy@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::destroy<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *>

; 867  : 		this->_Getal().destroy(
; 868  : 			_STD addressof(this->_Right(_Pnode)));

  0005b	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0005e	51		 push	 ecx
  0005f	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  00064	83 c4 04	 add	 esp, 4
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ??$addressof@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *>
  0006d	83 c4 04	 add	 esp, 4
  00070	50		 push	 eax
  00071	8d 55 fd	 lea	 edx, DWORD PTR $T2[ebp]
  00074	52		 push	 edx
  00075	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	e8 00 00 00 00	 call	 ?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Getal
  0007d	8b c8		 mov	 ecx, eax
  0007f	e8 00 00 00 00	 call	 ??$destroy@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::destroy<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *>

; 869  : 		this->_Getal().deallocate(_Pnode, 1);

  00084	6a 01		 push	 1
  00086	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00089	50		 push	 eax
  0008a	8d 4d fc	 lea	 ecx, DWORD PTR $T1[ebp]
  0008d	51		 push	 ecx
  0008e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	e8 00 00 00 00	 call	 ?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Getal
  00096	8b c8		 mov	 ecx, eax
  00098	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::deallocate

; 870  : 		}

  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 04 00	 ret	 4
?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?empty@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv70 = -4						; size = 4
?empty@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ PROC ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty, COMDAT
; _this$ = ecx

; 1381 : 		{	// test if sequence is empty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1382 : 		return (this->_Mysize == 0);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00010	75 09		 jne	 SHORT $LN3@empty
  00012	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv70[ebp], 1
  00019	eb 07		 jmp	 SHORT $LN4@empty
$LN3@empty:
  0001b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN4@empty:
  00022	8a 45 fc	 mov	 al, BYTE PTR tv70[ebp]

; 1383 : 		}

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?empty@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ ENDP ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?pop_back@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
__Block$1 = -20						; size = 4
tv144 = -16						; size = 4
__Newoff$2 = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
?pop_back@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ PROC ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::pop_back, COMDAT
; _this$ = ecx

; 1494 : 		{	// erase element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1495 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1496 : 		if (empty())
; 1497 : 			_DEBUG_ERROR("deque empty before pop");
; 1498 : 		else
; 1499 : 			{	// something to erase, do it
; 1500 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;
; 1501 : 			_Orphan_off(_Newoff);
; 1502 : 			size_type _Block = this->_Getblock(_Newoff);
; 1503 : 			this->_Getal().destroy(
; 1504 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1505 : 			if (--this->_Mysize == 0)
; 1506 : 				this->_Myoff = 0;
; 1507 : 			}
; 1508 : 
; 1509 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1510 : 		if (!empty())

  0000a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ?empty@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty
  00012	0f b6 c0	 movzx	 eax, al
  00015	85 c0		 test	 eax, eax
  00017	75 76		 jne	 SHORT $LN3@pop_back

; 1511 : 			{	// something to erase, do it
; 1512 : 			size_type _Newoff = this->_Myoff + this->_Mysize - 1;

  00019	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00025	8d 54 0a ff	 lea	 edx, DWORD PTR [edx+ecx-1]
  00029	89 55 f4	 mov	 DWORD PTR __Newoff$2[ebp], edx

; 1513 : 			size_type _Block = this->_Getblock(_Newoff);

  0002c	8b 45 f4	 mov	 eax, DWORD PTR __Newoff$2[ebp]
  0002f	50		 push	 eax
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getblock
  00038	89 45 ec	 mov	 DWORD PTR __Block$1[ebp], eax

; 1514 : 			this->_Getal().destroy(
; 1515 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);

  0003b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Newoff$2[ebp]
  00044	33 d2		 xor	 edx, edx
  00046	be 01 00 00 00	 mov	 esi, 1
  0004b	f7 f6		 div	 esi
  0004d	6b d2 18	 imul	 edx, 24			; 00000018H
  00050	8b 45 ec	 mov	 eax, DWORD PTR __Block$1[ebp]
  00053	03 14 81	 add	 edx, DWORD PTR [ecx+eax*4]
  00056	52		 push	 edx
  00057	8d 4d ff	 lea	 ecx, DWORD PTR $T3[ebp]
  0005a	51		 push	 ecx
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
  00063	8b c8		 mov	 ecx, eax
  00065	e8 00 00 00 00	 call	 ??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 1516 : 			if (--this->_Mysize == 0)

  0006a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006d	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00070	83 e8 01	 sub	 eax, 1
  00073	89 45 f0	 mov	 DWORD PTR tv144[ebp], eax
  00076	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	8b 55 f0	 mov	 edx, DWORD PTR tv144[ebp]
  0007c	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0007f	83 7d f0 00	 cmp	 DWORD PTR tv144[ebp], 0
  00083	75 0a		 jne	 SHORT $LN3@pop_back

; 1517 : 				this->_Myoff = 0;

  00085	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00088	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
$LN3@pop_back:

; 1518 : 			}
; 1519 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1520 : 		}

  0008f	5e		 pop	 esi
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
?pop_back@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ENDP ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::pop_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Growmap@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z
_TEXT	SEGMENT
tv84 = -36						; size = 4
$T1 = -29						; size = 1
__Newmap$ = -28						; size = 4
__Newsize$ = -24					; size = 4
__Myboff$ = -20						; size = 4
__Myptr$ = -16						; size = 4
_this$ = -12						; size = 4
__Almap$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
__Count$ = 8						; size = 4
?_Growmap@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z PROC ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Growmap, COMDAT
; _this$ = ecx

; 1802 : 		{	// grow map by at least _Count pointers, _Mapsize a power of 2

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1803 : 		static_assert(1 < _DEQUEMAPSIZ,
; 1804 : 			"The _Xlen() test should always be performed.");
; 1805 : 
; 1806 : 		typedef typename _Alpty::pointer _Blockptr;
; 1807 : 		_Alpty _Almap(this->_Getal());

  00013	8d 45 e3	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
  0001f	50		 push	 eax
  00020	8d 4d fb	 lea	 ecx, DWORD PTR __Almap$[ebp]
  00023	e8 00 00 00 00	 call	 ??$?0U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> >::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> ><std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >

; 1808 : 		size_type _Newsize = 0 < this->_Mapsize ? this->_Mapsize : 1;

  00028	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  0002f	76 0b		 jbe	 SHORT $LN10@Growmap
  00031	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00034	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00037	89 45 dc	 mov	 DWORD PTR tv84[ebp], eax
  0003a	eb 07		 jmp	 SHORT $LN11@Growmap
$LN10@Growmap:
  0003c	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv84[ebp], 1
$LN11@Growmap:
  00043	8b 4d dc	 mov	 ecx, DWORD PTR tv84[ebp]
  00046	89 4d e8	 mov	 DWORD PTR __Newsize$[ebp], ecx
$LN7@Growmap:

; 1809 : 		while (_Newsize - this->_Mapsize < _Count || _Newsize < _DEQUEMAPSIZ)

  00049	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0004c	8b 45 e8	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0004f	2b 42 08	 sub	 eax, DWORD PTR [edx+8]
  00052	3b 45 08	 cmp	 eax, DWORD PTR __Count$[ebp]
  00055	72 06		 jb	 SHORT $LN5@Growmap
  00057	83 7d e8 08	 cmp	 DWORD PTR __Newsize$[ebp], 8
  0005b	73 22		 jae	 SHORT $LN6@Growmap
$LN5@Growmap:

; 1810 : 			{	// scale _Newsize to 2^N >= _Mapsize + _Count
; 1811 : 			if (max_size() / _DEQUESIZ - _Newsize < _Newsize)

  0005d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	e8 00 00 00 00	 call	 ?max_size@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
  00065	2b 45 e8	 sub	 eax, DWORD PTR __Newsize$[ebp]
  00068	3b 45 e8	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0006b	73 08		 jae	 SHORT $LN4@Growmap

; 1812 : 				_Xlen();	// result too long

  0006d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	e8 00 00 00 00	 call	 ?_Xlen@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
$LN4@Growmap:

; 1813 : 			_Newsize *= 2;

  00075	8b 4d e8	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00078	d1 e1		 shl	 ecx, 1
  0007a	89 4d e8	 mov	 DWORD PTR __Newsize$[ebp], ecx

; 1814 : 			}

  0007d	eb ca		 jmp	 SHORT $LN7@Growmap
$LN6@Growmap:

; 1815 : 		_Count = _Newsize - this->_Mapsize;

  0007f	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00082	8b 45 e8	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00085	2b 42 08	 sub	 eax, DWORD PTR [edx+8]
  00088	89 45 08	 mov	 DWORD PTR __Count$[ebp], eax

; 1816 : 
; 1817 : 		size_type _Myboff = this->_Myoff / _DEQUESIZ;

  0008b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00091	89 55 ec	 mov	 DWORD PTR __Myboff$[ebp], edx

; 1818 : 		_Mapptr _Newmap = _Almap.allocate(this->_Mapsize + _Count);

  00094	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0009a	03 4d 08	 add	 ecx, DWORD PTR __Count$[ebp]
  0009d	51		 push	 ecx
  0009e	8d 4d fb	 lea	 ecx, DWORD PTR __Almap$[ebp]
  000a1	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> >::allocate
  000a6	89 45 e4	 mov	 DWORD PTR __Newmap$[ebp], eax

; 1819 : 		_Mapptr _Myptr = _Newmap + _Myboff;

  000a9	8b 55 ec	 mov	 edx, DWORD PTR __Myboff$[ebp]
  000ac	8b 45 e4	 mov	 eax, DWORD PTR __Newmap$[ebp]
  000af	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  000b2	89 4d f0	 mov	 DWORD PTR __Myptr$[ebp], ecx

; 1820 : 
; 1821 : 		_Myptr = _Uninitialized_copy(this->_Map + _Myboff,
; 1822 : 			this->_Map + this->_Mapsize,
; 1823 : 			_Myptr, _Almap);	// copy initial to end

  000b5	8d 55 fb	 lea	 edx, DWORD PTR __Almap$[ebp]
  000b8	52		 push	 edx
  000b9	8b 45 f0	 mov	 eax, DWORD PTR __Myptr$[ebp]
  000bc	50		 push	 eax
  000bd	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000c3	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000c6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c9	8d 14 91	 lea	 edx, DWORD PTR [ecx+edx*4]
  000cc	52		 push	 edx
  000cd	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000d0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d3	8b 55 ec	 mov	 edx, DWORD PTR __Myboff$[ebp]
  000d6	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAV12@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ; std::_Uninitialized_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >
  000df	83 c4 10	 add	 esp, 16			; 00000010H
  000e2	89 45 f0	 mov	 DWORD PTR __Myptr$[ebp], eax

; 1824 : 		if (_Myboff <= _Count)

  000e5	8b 4d ec	 mov	 ecx, DWORD PTR __Myboff$[ebp]
  000e8	3b 4d 08	 cmp	 ecx, DWORD PTR __Count$[ebp]
  000eb	77 54		 ja	 SHORT $LN3@Growmap

; 1825 : 			{	// increment greater than offset of initial block
; 1826 : 			_Myptr = _Uninitialized_copy(this->_Map,
; 1827 : 				this->_Map + _Myboff,
; 1828 : 				_Myptr, _Almap);	// copy rest of old

  000ed	8d 55 fb	 lea	 edx, DWORD PTR __Almap$[ebp]
  000f0	52		 push	 edx
  000f1	8b 45 f0	 mov	 eax, DWORD PTR __Myptr$[ebp]
  000f4	50		 push	 eax
  000f5	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000f8	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000fb	8b 45 ec	 mov	 eax, DWORD PTR __Myboff$[ebp]
  000fe	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  00101	51		 push	 ecx
  00102	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00105	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAV12@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ; std::_Uninitialized_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >
  0010e	83 c4 10	 add	 esp, 16			; 00000010H
  00111	89 45 f0	 mov	 DWORD PTR __Myptr$[ebp], eax

; 1829 : 			_Uninitialized_default_fill_n(_Myptr, _Count - _Myboff,
; 1830 : 				_Almap);	// clear suffix of new

  00114	8d 4d fb	 lea	 ecx, DWORD PTR __Almap$[ebp]
  00117	51		 push	 ecx
  00118	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  0011b	2b 55 ec	 sub	 edx, DWORD PTR __Myboff$[ebp]
  0011e	52		 push	 edx
  0011f	8b 45 f0	 mov	 eax, DWORD PTR __Myptr$[ebp]
  00122	50		 push	 eax
  00123	e8 00 00 00 00	 call	 ??$_Uninitialized_default_fill_n@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,unsigned int,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >
  00128	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1831 : 			_Uninitialized_default_fill_n(_Newmap, _Myboff,
; 1832 : 				_Almap);	// clear prefix of new

  0012b	8d 4d fb	 lea	 ecx, DWORD PTR __Almap$[ebp]
  0012e	51		 push	 ecx
  0012f	8b 55 ec	 mov	 edx, DWORD PTR __Myboff$[ebp]
  00132	52		 push	 edx
  00133	8b 45 e4	 mov	 eax, DWORD PTR __Newmap$[ebp]
  00136	50		 push	 eax
  00137	e8 00 00 00 00	 call	 ??$_Uninitialized_default_fill_n@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,unsigned int,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >
  0013c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1833 : 			}
; 1834 : 		else

  0013f	eb 65		 jmp	 SHORT $LN2@Growmap
$LN3@Growmap:

; 1835 : 			{	// increment not greater than offset of initial block
; 1836 : 			_Uninitialized_copy(this->_Map,
; 1837 : 				this->_Map + _Count,
; 1838 : 				_Myptr, _Almap);	// copy more old

  00141	8d 4d fb	 lea	 ecx, DWORD PTR __Almap$[ebp]
  00144	51		 push	 ecx
  00145	8b 55 f0	 mov	 edx, DWORD PTR __Myptr$[ebp]
  00148	52		 push	 edx
  00149	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0014c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0014f	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  00152	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  00155	50		 push	 eax
  00156	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00159	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0015c	52		 push	 edx
  0015d	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAV12@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ; std::_Uninitialized_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >
  00162	83 c4 10	 add	 esp, 16			; 00000010H

; 1839 : 			_Myptr = _Uninitialized_copy(this->_Map + _Count,
; 1840 : 				this->_Map + _Myboff,
; 1841 : 				_Newmap, _Almap);	// copy rest of old

  00165	8d 45 fb	 lea	 eax, DWORD PTR __Almap$[ebp]
  00168	50		 push	 eax
  00169	8b 4d e4	 mov	 ecx, DWORD PTR __Newmap$[ebp]
  0016c	51		 push	 ecx
  0016d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00170	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00173	8b 4d ec	 mov	 ecx, DWORD PTR __Myboff$[ebp]
  00176	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00179	52		 push	 edx
  0017a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0017d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00180	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  00183	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  00186	50		 push	 eax
  00187	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAV12@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ; std::_Uninitialized_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >
  0018c	83 c4 10	 add	 esp, 16			; 00000010H
  0018f	89 45 f0	 mov	 DWORD PTR __Myptr$[ebp], eax

; 1842 : 			_Uninitialized_default_fill_n(_Myptr, _Count,
; 1843 : 				_Almap);	// clear rest to initial block

  00192	8d 4d fb	 lea	 ecx, DWORD PTR __Almap$[ebp]
  00195	51		 push	 ecx
  00196	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  00199	52		 push	 edx
  0019a	8b 45 f0	 mov	 eax, DWORD PTR __Myptr$[ebp]
  0019d	50		 push	 eax
  0019e	e8 00 00 00 00	 call	 ??$_Uninitialized_default_fill_n@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,unsigned int,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >
  001a3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@Growmap:

; 1844 : 			}
; 1845 : 
; 1846 : 		_Destroy_range(this->_Map + _Myboff, this->_Map + this->_Mapsize,
; 1847 : 			_Almap);

  001a6	8d 4d fb	 lea	 ecx, DWORD PTR __Almap$[ebp]
  001a9	51		 push	 ecx
  001aa	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  001ad	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  001b0	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001b3	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001b6	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  001b9	50		 push	 eax
  001ba	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001bd	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001c0	8b 45 ec	 mov	 eax, DWORD PTR __Myboff$[ebp]
  001c3	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  001c6	51		 push	 ecx
  001c7	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >
  001cc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1848 : 		if (this->_Map != _Mapptr())

  001cf	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  001d2	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  001d6	74 16		 je	 SHORT $LN1@Growmap

; 1849 : 			_Almap.deallocate(this->_Map,
; 1850 : 				this->_Mapsize);	// free storage for old

  001d8	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  001db	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001de	51		 push	 ecx
  001df	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  001e2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001e5	50		 push	 eax
  001e6	8d 4d fb	 lea	 ecx, DWORD PTR __Almap$[ebp]
  001e9	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> >::deallocate
$LN1@Growmap:

; 1851 : 
; 1852 : 		this->_Map = _Newmap;	// point at new

  001ee	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001f1	8b 55 e4	 mov	 edx, DWORD PTR __Newmap$[ebp]
  001f4	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 1853 : 		this->_Mapsize += _Count;

  001f7	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  001fa	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001fd	03 4d 08	 add	 ecx, DWORD PTR __Count$[ebp]
  00200	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00203	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$LN9@Growmap:

; 1854 : 		}

  00206	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00209	33 cd		 xor	 ecx, ebp
  0020b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00210	8b e5		 mov	 esp, ebp
  00212	5d		 pop	 ebp
  00213	c2 04 00	 ret	 4
?_Growmap@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ENDP ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Growmap
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??0?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
??0?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 877  : 	_Deque_alloc(const _Alloc& = _Alloc())

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??0?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0002e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 878  : 		{	// construct allocators from _Al
; 879  : 		_Alloc_proxy();

  00035	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Alloc_proxy

; 880  : 		}

  0003d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00044	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Alproxy$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Free_proxy, COMDAT
; _this$ = ecx

; 906  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 907  : 		typename _Alty::template rebind<_Container_proxy>::other
; 908  : 			_Alproxy;

  00013	8d 4d fb	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00016	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> >

; 909  : 		this->_Orphan_all();

  0001b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ

; 910  : 		_Alproxy.destroy(this->_Myproxy);

  00024	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 08		 mov	 ecx, DWORD PTR [eax]
  00029	51		 push	 ecx
  0002a	8d 4d fb	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>

; 911  : 		_Alproxy.deallocate(this->_Myproxy, 1);

  00032	6a 01		 push	 1
  00034	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00037	8b 02		 mov	 eax, DWORD PTR [edx]
  00039	50		 push	 eax
  0003a	8d 4d fb	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  0003d	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate

; 912  : 		this->_Myproxy = 0;

  00042	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 913  : 		}

  0004b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004e	33 cd		 xor	 ecx, ebp
  00050	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal, COMDAT
; _this$ = ecx

; 916  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 917  : 		return (_Alty());

  00007	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 918  : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate

; 877  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?allocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate

; 888  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::deallocate

; 888  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEII@Z PROC ; std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getblock, COMDAT
; _this$ = ecx

; 785  : 		{	// determine block from offset

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 786  : 			// NB: _Mapsize and _DEQUESIZ are guaranteed to be powers of 2
; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000d	83 e8 01	 sub	 eax, 1
  00010	23 45 08	 and	 eax, DWORD PTR __Off$[ebp]

; 788  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEII@Z ENDP ; std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Getblock
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAE@std@@QAEXPAPAEI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAE@std@@QAEXPAPAEI@Z PROC	; std::allocator<unsigned char *>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??3@YAXPAX@Z
  00011	83 c4 04	 add	 esp, 4

; 587  : 		}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
?deallocate@?$allocator@PAE@std@@QAEXPAPAEI@Z ENDP	; std::allocator<unsigned char *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -20						; size = 8
_this$ = -12						; size = 4
__Alproxy$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 897  : 		{	// construct proxy from _Alval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 898  : 		typename _Alty::template rebind<_Container_proxy>::other
; 899  : 			_Alproxy;

  00013	8d 4d fb	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00016	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> >

; 900  : 		this->_Myproxy = _Alproxy.allocate(1);

  0001b	6a 01		 push	 1
  0001d	8d 4d fb	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00020	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
  00025	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	89 01		 mov	 DWORD PTR [ecx], eax

; 901  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());

  0002a	8d 4d ec	 lea	 ecx, DWORD PTR $T1[ebp]
  0002d	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy
  00032	50		 push	 eax
  00033	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00036	8b 02		 mov	 eax, DWORD PTR [edx]
  00038	50		 push	 eax
  00039	8d 4d fb	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  0003c	e8 00 00 00 00	 call	 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>

; 902  : 		this->_Myproxy->_Mycont = this;

  00041	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	8b 11		 mov	 edx, DWORD PTR [ecx]
  00046	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00049	89 02		 mov	 DWORD PTR [edx], eax

; 903  : 		}

  0004b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004e	33 cd		 xor	 ecx, ebp
  00050	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<unsigned char *,std::allocator<unsigned char *> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAE@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@PAE@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<unsigned char *> >::_Wrap_alloc<std::allocator<unsigned char *> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$allocator@PAE@std@@QAE@XZ ; std::allocator<unsigned char *>::allocator<unsigned char *>

; 831  : 		}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAE@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<unsigned char *> >::_Wrap_alloc<std::allocator<unsigned char *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAPAE@std@@QAEXPAPAPAEI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAPAE@std@@QAEXPAPAPAEI@Z PROC	; std::allocator<unsigned char * *>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??3@YAXPAX@Z
  00011	83 c4 04	 add	 esp, 4

; 587  : 		}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
?deallocate@?$allocator@PAPAE@std@@QAEXPAPAPAEI@Z ENDP	; std::allocator<unsigned char * *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??0?$_Deque_val@U?$_Deque_simple_types@PAE@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Deque_val@U?$_Deque_simple_types@PAE@std@@@std@@QAE@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<unsigned char *> >::_Deque_val<std::_Deque_simple_types<unsigned char *> >, COMDAT
; _this$ = ecx

; 776  : 	_Deque_val()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Container_base12@std@@QAE@XZ

; 777  : 		{	// initialize values
; 778  : 		_Map = _Mapptr();

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 779  : 		_Mapsize = 0;

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 780  : 		_Myoff = 0;

  00024	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00027	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 781  : 		_Mysize = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 782  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??0?$_Deque_val@U?$_Deque_simple_types@PAE@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<unsigned char *> >::_Deque_val<std::_Deque_simple_types<unsigned char *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@PAE@std@@@std@@QBEII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@PAE@std@@@std@@QBEII@Z PROC ; std::_Deque_val<std::_Deque_simple_types<unsigned char *> >::_Getblock, COMDAT
; _this$ = ecx

; 785  : 		{	// determine block from offset

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 786  : 			// NB: _Mapsize and _DEQUESIZ are guaranteed to be powers of 2
; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	c1 e8 02	 shr	 eax, 2
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00013	83 ea 01	 sub	 edx, 1
  00016	23 c2		 and	 eax, edx

; 788  : 		}

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@PAE@std@@@std@@QBEII@Z ENDP ; std::_Deque_val<std::_Deque_simple_types<unsigned char *> >::_Getblock
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv182 = -32						; size = 4
tv170 = -28						; size = 4
_this$ = -24						; size = 4
__Erasednode$ = -20					; size = 4
__Fixnode$ = -16					; size = 4
__Fixnodeparent$ = -12					; size = 4
__Pnode$ = -8						; size = 4
$T1 = -2						; size = 1
$T2 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::erase, COMDAT
; _this$ = ecx

; 1323 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	56		 push	 esi
  00007	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 1324 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1325 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1326 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1327 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1328 : 		++_Where;	// save successor iterator for return
; 1329 : 		_Orphan_ptr(*this, _Erasednode);
; 1330 : 
; 1331 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1332 : 		if (this->_Isnil(_Where._Mynode()))

  0000a	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0000d	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >,std::_Iterator_base0>::_Mynode
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Isnil
  00018	83 c4 04	 add	 esp, 4
  0001b	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0001e	85 c0		 test	 eax, eax
  00020	74 0b		 je	 SHORT $LN40@erase

; 1333 : 			_Xout_of_range("invalid map/set<T> iterator");

  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN40@erase:

; 1334 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

  0002d	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >,std::_Iterator_base0>::_Mynode
  00035	89 45 ec	 mov	 DWORD PTR __Erasednode$[ebp], eax

; 1335 : 		++_Where;	// save successor iterator for return

  00038	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0003b	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::operator++

; 1336 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 
; 1338 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1339 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1340 : 		_Nodeptr _Pnode = _Erasednode;

  00040	8b 4d ec	 mov	 ecx, DWORD PTR __Erasednode$[ebp]
  00043	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1341 : 
; 1342 : 		if (this->_Isnil(this->_Left(_Pnode)))

  00046	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00049	52		 push	 edx
  0004a	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  0004f	83 c4 04	 add	 esp, 4
  00052	8b 00		 mov	 eax, DWORD PTR [eax]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Isnil
  0005a	83 c4 04	 add	 esp, 4
  0005d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00060	85 c9		 test	 ecx, ecx
  00062	74 13		 je	 SHORT $LN39@erase

; 1343 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  00064	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00067	52		 push	 edx
  00068	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  0006d	83 c4 04	 add	 esp, 4
  00070	8b 00		 mov	 eax, DWORD PTR [eax]
  00072	89 45 f0	 mov	 DWORD PTR __Fixnode$[ebp], eax
  00075	eb 4d		 jmp	 SHORT $LN38@erase
$LN39@erase:

; 1344 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00077	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0007a	51		 push	 ecx
  0007b	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  00080	83 c4 04	 add	 esp, 4
  00083	8b 10		 mov	 edx, DWORD PTR [eax]
  00085	52		 push	 edx
  00086	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Isnil
  0008b	83 c4 04	 add	 esp, 4
  0008e	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00091	85 c0		 test	 eax, eax
  00093	74 13		 je	 SHORT $LN37@erase

; 1345 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  00095	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00098	51		 push	 ecx
  00099	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  0009e	83 c4 04	 add	 esp, 4
  000a1	8b 10		 mov	 edx, DWORD PTR [eax]
  000a3	89 55 f0	 mov	 DWORD PTR __Fixnode$[ebp], edx

; 1346 : 		else

  000a6	eb 1c		 jmp	 SHORT $LN38@erase
$LN37@erase:

; 1347 : 			{	// two subtrees, must lift successor node to replace erased
; 1348 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

  000a8	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  000ab	e8 00 00 00 00	 call	 ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >,std::_Iterator_base0>::_Mynode
  000b0	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 1349 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  000b3	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  000bc	83 c4 04	 add	 esp, 4
  000bf	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c1	89 4d f0	 mov	 DWORD PTR __Fixnode$[ebp], ecx
$LN38@erase:

; 1350 : 			}
; 1351 : 
; 1352 : 		if (_Pnode == _Erasednode)

  000c4	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  000c7	3b 55 ec	 cmp	 edx, DWORD PTR __Erasednode$[ebp]
  000ca	0f 85 1b 01 00
	00		 jne	 $LN35@erase

; 1353 : 			{	// at most one subtree, relink it
; 1354 : 			_Fixnodeparent = this->_Parent(_Erasednode);

  000d0	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  000d3	50		 push	 eax
  000d4	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  000d9	83 c4 04	 add	 esp, 4
  000dc	8b 08		 mov	 ecx, DWORD PTR [eax]
  000de	89 4d f4	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx

; 1355 : 			if (!this->_Isnil(_Fixnode))

  000e1	8b 55 f0	 mov	 edx, DWORD PTR __Fixnode$[ebp]
  000e4	52		 push	 edx
  000e5	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Isnil
  000ea	83 c4 04	 add	 esp, 4
  000ed	0f be 00	 movsx	 eax, BYTE PTR [eax]
  000f0	85 c0		 test	 eax, eax
  000f2	75 11		 jne	 SHORT $LN34@erase

; 1356 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  000f4	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  000f7	51		 push	 ecx
  000f8	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  000fd	83 c4 04	 add	 esp, 4
  00100	8b 55 f4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  00103	89 10		 mov	 DWORD PTR [eax], edx
$LN34@erase:

; 1357 : 
; 1358 : 			if (_Root() == _Erasednode)

  00105	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00108	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Root
  0010d	8b 00		 mov	 eax, DWORD PTR [eax]
  0010f	3b 45 ec	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  00112	75 0f		 jne	 SHORT $LN33@erase

; 1359 : 				_Root() = _Fixnode;	// link down from root

  00114	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00117	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Root
  0011c	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  0011f	89 08		 mov	 DWORD PTR [eax], ecx
  00121	eb 37		 jmp	 SHORT $LN32@erase
$LN33@erase:

; 1360 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  00123	8b 55 f4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  00126	52		 push	 edx
  00127	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  0012c	83 c4 04	 add	 esp, 4
  0012f	8b 00		 mov	 eax, DWORD PTR [eax]
  00131	3b 45 ec	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  00134	75 13		 jne	 SHORT $LN31@erase

; 1361 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  00136	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00139	51		 push	 ecx
  0013a	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  0013f	83 c4 04	 add	 esp, 4
  00142	8b 55 f0	 mov	 edx, DWORD PTR __Fixnode$[ebp]
  00145	89 10		 mov	 DWORD PTR [eax], edx

; 1362 : 			else

  00147	eb 11		 jmp	 SHORT $LN32@erase
$LN31@erase:

; 1363 : 				this->_Right(_Fixnodeparent) =
; 1364 : 					_Fixnode;	// link down to right

  00149	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0014c	50		 push	 eax
  0014d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  00152	83 c4 04	 add	 esp, 4
  00155	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00158	89 08		 mov	 DWORD PTR [eax], ecx
$LN32@erase:

; 1365 : 
; 1366 : 			if (_Lmost() == _Erasednode)

  0015a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0015d	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Lmost
  00162	8b 10		 mov	 edx, DWORD PTR [eax]
  00164	3b 55 ec	 cmp	 edx, DWORD PTR __Erasednode$[ebp]
  00167	75 37		 jne	 SHORT $LN29@erase

; 1367 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1368 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1369 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  00169	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0016c	50		 push	 eax
  0016d	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Isnil
  00172	83 c4 04	 add	 esp, 4
  00175	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00178	85 c9		 test	 ecx, ecx
  0017a	74 08		 je	 SHORT $LN43@erase
  0017c	8b 55 f4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  0017f	89 55 e4	 mov	 DWORD PTR tv170[ebp], edx
  00182	eb 0f		 jmp	 SHORT $LN44@erase
$LN43@erase:
  00184	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00187	50		 push	 eax
  00188	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Min
  0018d	83 c4 04	 add	 esp, 4
  00190	89 45 e4	 mov	 DWORD PTR tv170[ebp], eax
$LN44@erase:
  00193	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00196	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Lmost
  0019b	8b 4d e4	 mov	 ecx, DWORD PTR tv170[ebp]
  0019e	89 08		 mov	 DWORD PTR [eax], ecx
$LN29@erase:

; 1370 : 
; 1371 : 			if (_Rmost() == _Erasednode)

  001a0	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001a3	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Rmost
  001a8	8b 10		 mov	 edx, DWORD PTR [eax]
  001aa	3b 55 ec	 cmp	 edx, DWORD PTR __Erasednode$[ebp]
  001ad	75 37		 jne	 SHORT $LN28@erase

; 1372 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1373 : 					? _Fixnodeparent	// largest is parent of erased node
; 1374 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  001af	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  001b2	50		 push	 eax
  001b3	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Isnil
  001b8	83 c4 04	 add	 esp, 4
  001bb	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001be	85 c9		 test	 ecx, ecx
  001c0	74 08		 je	 SHORT $LN45@erase
  001c2	8b 55 f4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  001c5	89 55 e0	 mov	 DWORD PTR tv182[ebp], edx
  001c8	eb 0f		 jmp	 SHORT $LN46@erase
$LN45@erase:
  001ca	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  001cd	50		 push	 eax
  001ce	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Max
  001d3	83 c4 04	 add	 esp, 4
  001d6	89 45 e0	 mov	 DWORD PTR tv182[ebp], eax
$LN46@erase:
  001d9	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001dc	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Rmost
  001e1	8b 4d e0	 mov	 ecx, DWORD PTR tv182[ebp]
  001e4	89 08		 mov	 DWORD PTR [eax], ecx
$LN28@erase:

; 1375 : 			}
; 1376 : 		else

  001e6	e9 8e 01 00 00	 jmp	 $LN27@erase
$LN35@erase:

; 1377 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1378 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1379 : 				_Pnode;	// link left up

  001eb	8b 55 ec	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  001ee	52		 push	 edx
  001ef	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  001f4	83 c4 04	 add	 esp, 4
  001f7	8b 00		 mov	 eax, DWORD PTR [eax]
  001f9	50		 push	 eax
  001fa	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  001ff	83 c4 04	 add	 esp, 4
  00202	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00205	89 08		 mov	 DWORD PTR [eax], ecx

; 1380 : 			this->_Left(_Pnode) =
; 1381 : 				this->_Left(_Erasednode);	// link successor down

  00207	8b 55 ec	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  0020a	52		 push	 edx
  0020b	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  00210	83 c4 04	 add	 esp, 4
  00213	8b f0		 mov	 esi, eax
  00215	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00218	50		 push	 eax
  00219	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  0021e	83 c4 04	 add	 esp, 4
  00221	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00223	89 08		 mov	 DWORD PTR [eax], ecx

; 1382 : 
; 1383 : 			if (_Pnode == this->_Right(_Erasednode))

  00225	8b 55 ec	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  00228	52		 push	 edx
  00229	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  0022e	83 c4 04	 add	 esp, 4
  00231	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00234	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00236	75 0b		 jne	 SHORT $LN26@erase

; 1384 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  00238	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0023b	89 55 f4	 mov	 DWORD PTR __Fixnodeparent$[ebp], edx

; 1385 : 			else

  0023e	e9 80 00 00 00	 jmp	 $LN25@erase
$LN26@erase:

; 1386 : 				{	// successor further down, link in place of erased
; 1387 : 				_Fixnodeparent =
; 1388 : 					this->_Parent(_Pnode);	// parent is successor's

  00243	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00246	50		 push	 eax
  00247	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  0024c	83 c4 04	 add	 esp, 4
  0024f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00251	89 4d f4	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx

; 1389 : 				if (!this->_Isnil(_Fixnode))

  00254	8b 55 f0	 mov	 edx, DWORD PTR __Fixnode$[ebp]
  00257	52		 push	 edx
  00258	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Isnil
  0025d	83 c4 04	 add	 esp, 4
  00260	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00263	85 c0		 test	 eax, eax
  00265	75 11		 jne	 SHORT $LN24@erase

; 1390 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  00267	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  0026a	51		 push	 ecx
  0026b	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  00270	83 c4 04	 add	 esp, 4
  00273	8b 55 f4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  00276	89 10		 mov	 DWORD PTR [eax], edx
$LN24@erase:

; 1391 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  00278	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0027b	50		 push	 eax
  0027c	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  00281	83 c4 04	 add	 esp, 4
  00284	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00287	89 08		 mov	 DWORD PTR [eax], ecx

; 1392 : 				this->_Right(_Pnode) =
; 1393 : 					this->_Right(_Erasednode);	// link next down

  00289	8b 55 ec	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  0028c	52		 push	 edx
  0028d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  00292	83 c4 04	 add	 esp, 4
  00295	8b f0		 mov	 esi, eax
  00297	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0029a	50		 push	 eax
  0029b	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  002a0	83 c4 04	 add	 esp, 4
  002a3	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002a5	89 08		 mov	 DWORD PTR [eax], ecx

; 1394 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1395 : 					_Pnode;	// right up

  002a7	8b 55 ec	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  002aa	52		 push	 edx
  002ab	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  002b0	83 c4 04	 add	 esp, 4
  002b3	8b 00		 mov	 eax, DWORD PTR [eax]
  002b5	50		 push	 eax
  002b6	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  002bb	83 c4 04	 add	 esp, 4
  002be	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  002c1	89 08		 mov	 DWORD PTR [eax], ecx
$LN25@erase:

; 1396 : 				}
; 1397 : 
; 1398 : 			if (_Root() == _Erasednode)

  002c3	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  002c6	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Root
  002cb	8b 10		 mov	 edx, DWORD PTR [eax]
  002cd	3b 55 ec	 cmp	 edx, DWORD PTR __Erasednode$[ebp]
  002d0	75 0f		 jne	 SHORT $LN23@erase

; 1399 : 				_Root() = _Pnode;	// link down from root

  002d2	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  002d5	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Root
  002da	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  002dd	89 08		 mov	 DWORD PTR [eax], ecx
  002df	eb 58		 jmp	 SHORT $LN22@erase
$LN23@erase:

; 1400 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  002e1	8b 55 ec	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  002e4	52		 push	 edx
  002e5	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  002ea	83 c4 04	 add	 esp, 4
  002ed	8b 00		 mov	 eax, DWORD PTR [eax]
  002ef	50		 push	 eax
  002f0	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  002f5	83 c4 04	 add	 esp, 4
  002f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  002fa	3b 4d ec	 cmp	 ecx, DWORD PTR __Erasednode$[ebp]
  002fd	75 1e		 jne	 SHORT $LN21@erase

; 1401 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1402 : 					_Pnode;	// link down to left

  002ff	8b 55 ec	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  00302	52		 push	 edx
  00303	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  00308	83 c4 04	 add	 esp, 4
  0030b	8b 00		 mov	 eax, DWORD PTR [eax]
  0030d	50		 push	 eax
  0030e	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  00313	83 c4 04	 add	 esp, 4
  00316	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00319	89 08		 mov	 DWORD PTR [eax], ecx

; 1403 : 			else

  0031b	eb 1c		 jmp	 SHORT $LN22@erase
$LN21@erase:

; 1404 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to right

  0031d	8b 55 ec	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  00320	52		 push	 edx
  00321	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  00326	83 c4 04	 add	 esp, 4
  00329	8b 00		 mov	 eax, DWORD PTR [eax]
  0032b	50		 push	 eax
  0032c	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  00331	83 c4 04	 add	 esp, 4
  00334	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00337	89 08		 mov	 DWORD PTR [eax], ecx
$LN22@erase:

; 1406 : 
; 1407 : 			this->_Parent(_Pnode) =
; 1408 : 				this->_Parent(_Erasednode);	// link successor up

  00339	8b 55 ec	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  0033c	52		 push	 edx
  0033d	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  00342	83 c4 04	 add	 esp, 4
  00345	8b f0		 mov	 esi, eax
  00347	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0034a	50		 push	 eax
  0034b	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  00350	83 c4 04	 add	 esp, 4
  00353	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00355	89 08		 mov	 DWORD PTR [eax], ecx

; 1409 : 			_STD swap(this->_Color(_Pnode),
; 1410 : 				this->_Color(_Erasednode));	// recolor it

  00357	8b 55 ec	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  0035a	52		 push	 edx
  0035b	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  00360	83 c4 04	 add	 esp, 4
  00363	50		 push	 eax
  00364	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00367	50		 push	 eax
  00368	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  0036d	83 c4 04	 add	 esp, 4
  00370	50		 push	 eax
  00371	e8 00 00 00 00	 call	 ??$swap@D@std@@YAXAAD0@Z ; std::swap<char>
  00376	83 c4 08	 add	 esp, 8
$LN27@erase:

; 1411 : 			}
; 1412 : 
; 1413 : 		if (this->_Color(_Erasednode) == this->_Black)

  00379	8b 4d ec	 mov	 ecx, DWORD PTR __Erasednode$[ebp]
  0037c	51		 push	 ecx
  0037d	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  00382	83 c4 04	 add	 esp, 4
  00385	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00388	83 fa 01	 cmp	 edx, 1
  0038b	0f 85 8f 03 00
	00		 jne	 $LN19@erase

; 1414 : 			{	// erasing black link, must recolor/rebalance tree
; 1415 : 			for (; _Fixnode != _Root()
; 1416 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1417 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  00391	eb 11		 jmp	 SHORT $LN18@erase
$LN17@erase:
  00393	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00396	50		 push	 eax
  00397	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  0039c	83 c4 04	 add	 esp, 4
  0039f	8b 08		 mov	 ecx, DWORD PTR [eax]
  003a1	89 4d f4	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx
$LN18@erase:
  003a4	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  003a7	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Root
  003ac	8b 55 f0	 mov	 edx, DWORD PTR __Fixnode$[ebp]
  003af	3b 10		 cmp	 edx, DWORD PTR [eax]
  003b1	0f 84 5a 03 00
	00		 je	 $LN16@erase
  003b7	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  003ba	50		 push	 eax
  003bb	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  003c0	83 c4 04	 add	 esp, 4
  003c3	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  003c6	83 f9 01	 cmp	 ecx, 1
  003c9	0f 85 42 03 00
	00		 jne	 $LN16@erase

; 1418 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  003cf	8b 55 f4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  003d2	52		 push	 edx
  003d3	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  003d8	83 c4 04	 add	 esp, 4
  003db	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  003de	3b 08		 cmp	 ecx, DWORD PTR [eax]
  003e0	0f 85 97 01 00
	00		 jne	 $LN15@erase

; 1419 : 					{	// fixup left subtree
; 1420 : 					_Pnode = this->_Right(_Fixnodeparent);

  003e6	8b 55 f4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  003e9	52		 push	 edx
  003ea	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  003ef	83 c4 04	 add	 esp, 4
  003f2	8b 00		 mov	 eax, DWORD PTR [eax]
  003f4	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 1421 : 					if (this->_Color(_Pnode) == this->_Red)

  003f7	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  003fa	51		 push	 ecx
  003fb	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  00400	83 c4 04	 add	 esp, 4
  00403	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00406	85 d2		 test	 edx, edx
  00408	75 3b		 jne	 SHORT $LN14@erase

; 1422 : 						{	// rotate red up from right subtree
; 1423 : 						this->_Color(_Pnode) = this->_Black;

  0040a	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0040d	50		 push	 eax
  0040e	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  00413	83 c4 04	 add	 esp, 4
  00416	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1424 : 						this->_Color(_Fixnodeparent) = this->_Red;

  00419	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  0041c	51		 push	 ecx
  0041d	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  00422	83 c4 04	 add	 esp, 4
  00425	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1425 : 						_Lrotate(_Fixnodeparent);

  00428	8b 55 f4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  0042b	52		 push	 edx
  0042c	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0042f	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Lrotate

; 1426 : 						_Pnode = this->_Right(_Fixnodeparent);

  00434	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00437	50		 push	 eax
  00438	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  0043d	83 c4 04	 add	 esp, 4
  00440	8b 08		 mov	 ecx, DWORD PTR [eax]
  00442	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN14@erase:

; 1427 : 						}
; 1428 : 
; 1429 : 					if (this->_Isnil(_Pnode))

  00445	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00448	52		 push	 edx
  00449	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Isnil
  0044e	83 c4 04	 add	 esp, 4
  00451	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00454	85 c0		 test	 eax, eax
  00456	74 0b		 je	 SHORT $LN13@erase

; 1430 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

  00458	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  0045b	89 4d f0	 mov	 DWORD PTR __Fixnode$[ebp], ecx

; 1431 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black

  0045e	e9 15 01 00 00	 jmp	 $LN12@erase
$LN13@erase:

; 1432 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00463	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00466	52		 push	 edx
  00467	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  0046c	83 c4 04	 add	 esp, 4
  0046f	8b 00		 mov	 eax, DWORD PTR [eax]
  00471	50		 push	 eax
  00472	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  00477	83 c4 04	 add	 esp, 4
  0047a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0047d	83 f9 01	 cmp	 ecx, 1
  00480	75 39		 jne	 SHORT $LN11@erase
  00482	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00485	52		 push	 edx
  00486	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  0048b	83 c4 04	 add	 esp, 4
  0048e	8b 00		 mov	 eax, DWORD PTR [eax]
  00490	50		 push	 eax
  00491	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  00496	83 c4 04	 add	 esp, 4
  00499	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0049c	83 f9 01	 cmp	 ecx, 1
  0049f	75 1a		 jne	 SHORT $LN11@erase

; 1433 : 						{	// redden right subtree with black children
; 1434 : 						this->_Color(_Pnode) = this->_Red;

  004a1	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  004a4	52		 push	 edx
  004a5	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  004aa	83 c4 04	 add	 esp, 4
  004ad	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1435 : 						_Fixnode = _Fixnodeparent;

  004b0	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  004b3	89 45 f0	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 1436 : 						}
; 1437 : 					else

  004b6	e9 bd 00 00 00	 jmp	 $LN12@erase
$LN11@erase:

; 1438 : 						{	// must rearrange right subtree
; 1439 : 						if (this->_Color(this->_Right(_Pnode))
; 1440 : 							== this->_Black)

  004bb	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  004be	51		 push	 ecx
  004bf	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  004c4	83 c4 04	 add	 esp, 4
  004c7	8b 10		 mov	 edx, DWORD PTR [eax]
  004c9	52		 push	 edx
  004ca	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  004cf	83 c4 04	 add	 esp, 4
  004d2	0f be 00	 movsx	 eax, BYTE PTR [eax]
  004d5	83 f8 01	 cmp	 eax, 1
  004d8	75 46		 jne	 SHORT $LN9@erase

; 1441 : 							{	// rotate red up from left sub-subtree
; 1442 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  004da	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  004dd	51		 push	 ecx
  004de	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  004e3	83 c4 04	 add	 esp, 4
  004e6	8b 10		 mov	 edx, DWORD PTR [eax]
  004e8	52		 push	 edx
  004e9	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  004ee	83 c4 04	 add	 esp, 4
  004f1	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1443 : 							this->_Color(_Pnode) = this->_Red;

  004f4	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004f7	50		 push	 eax
  004f8	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  004fd	83 c4 04	 add	 esp, 4
  00500	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1444 : 							_Rrotate(_Pnode);

  00503	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00506	51		 push	 ecx
  00507	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0050a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Rrotate

; 1445 : 							_Pnode = this->_Right(_Fixnodeparent);

  0050f	8b 55 f4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  00512	52		 push	 edx
  00513	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  00518	83 c4 04	 add	 esp, 4
  0051b	8b 00		 mov	 eax, DWORD PTR [eax]
  0051d	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN9@erase:

; 1446 : 							}
; 1447 : 
; 1448 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00520	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00523	51		 push	 ecx
  00524	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  00529	83 c4 04	 add	 esp, 4
  0052c	8b f0		 mov	 esi, eax
  0052e	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00531	52		 push	 edx
  00532	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  00537	83 c4 04	 add	 esp, 4
  0053a	8a 0e		 mov	 cl, BYTE PTR [esi]
  0053c	88 08		 mov	 BYTE PTR [eax], cl

; 1449 : 						this->_Color(_Fixnodeparent) = this->_Black;

  0053e	8b 55 f4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  00541	52		 push	 edx
  00542	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  00547	83 c4 04	 add	 esp, 4
  0054a	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1450 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  0054d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00550	50		 push	 eax
  00551	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  00556	83 c4 04	 add	 esp, 4
  00559	8b 08		 mov	 ecx, DWORD PTR [eax]
  0055b	51		 push	 ecx
  0055c	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  00561	83 c4 04	 add	 esp, 4
  00564	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1451 : 						_Lrotate(_Fixnodeparent);

  00567	8b 55 f4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  0056a	52		 push	 edx
  0056b	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0056e	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Lrotate

; 1452 : 						break;	// tree now recolored/rebalanced

  00573	e9 99 01 00 00	 jmp	 $LN16@erase
$LN12@erase:

; 1453 : 						}
; 1454 : 					}
; 1455 : 				else

  00578	e9 8f 01 00 00	 jmp	 $LN8@erase
$LN15@erase:

; 1456 : 					{	// fixup right subtree
; 1457 : 					_Pnode = this->_Left(_Fixnodeparent);

  0057d	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00580	50		 push	 eax
  00581	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  00586	83 c4 04	 add	 esp, 4
  00589	8b 08		 mov	 ecx, DWORD PTR [eax]
  0058b	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 1458 : 					if (this->_Color(_Pnode) == this->_Red)

  0058e	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00591	52		 push	 edx
  00592	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  00597	83 c4 04	 add	 esp, 4
  0059a	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0059d	85 c0		 test	 eax, eax
  0059f	75 3b		 jne	 SHORT $LN7@erase

; 1459 : 						{	// rotate red up from left subtree
; 1460 : 						this->_Color(_Pnode) = this->_Black;

  005a1	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  005a4	51		 push	 ecx
  005a5	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  005aa	83 c4 04	 add	 esp, 4
  005ad	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1461 : 						this->_Color(_Fixnodeparent) = this->_Red;

  005b0	8b 55 f4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  005b3	52		 push	 edx
  005b4	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  005b9	83 c4 04	 add	 esp, 4
  005bc	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1462 : 						_Rrotate(_Fixnodeparent);

  005bf	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  005c2	50		 push	 eax
  005c3	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  005c6	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Rrotate

; 1463 : 						_Pnode = this->_Left(_Fixnodeparent);

  005cb	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  005ce	51		 push	 ecx
  005cf	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  005d4	83 c4 04	 add	 esp, 4
  005d7	8b 10		 mov	 edx, DWORD PTR [eax]
  005d9	89 55 f8	 mov	 DWORD PTR __Pnode$[ebp], edx
$LN7@erase:

; 1464 : 						}
; 1465 : 
; 1466 : 					if (this->_Isnil(_Pnode))

  005dc	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  005df	50		 push	 eax
  005e0	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Isnil
  005e5	83 c4 04	 add	 esp, 4
  005e8	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  005eb	85 c9		 test	 ecx, ecx
  005ed	74 0b		 je	 SHORT $LN6@erase

; 1467 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

  005ef	8b 55 f4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  005f2	89 55 f0	 mov	 DWORD PTR __Fixnode$[ebp], edx

; 1468 : 					else if (this->_Color(this->_Right(_Pnode)) ==

  005f5	e9 12 01 00 00	 jmp	 $LN8@erase
$LN6@erase:

; 1469 : 						this->_Black
; 1470 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  005fa	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  005fd	50		 push	 eax
  005fe	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  00603	83 c4 04	 add	 esp, 4
  00606	8b 08		 mov	 ecx, DWORD PTR [eax]
  00608	51		 push	 ecx
  00609	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  0060e	83 c4 04	 add	 esp, 4
  00611	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00614	83 fa 01	 cmp	 edx, 1
  00617	75 39		 jne	 SHORT $LN4@erase
  00619	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0061c	50		 push	 eax
  0061d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  00622	83 c4 04	 add	 esp, 4
  00625	8b 08		 mov	 ecx, DWORD PTR [eax]
  00627	51		 push	 ecx
  00628	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  0062d	83 c4 04	 add	 esp, 4
  00630	0f be 10	 movsx	 edx, BYTE PTR [eax]
  00633	83 fa 01	 cmp	 edx, 1
  00636	75 1a		 jne	 SHORT $LN4@erase

; 1471 : 						{	// redden left subtree with black children
; 1472 : 						this->_Color(_Pnode) = this->_Red;

  00638	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0063b	50		 push	 eax
  0063c	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  00641	83 c4 04	 add	 esp, 4
  00644	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1473 : 						_Fixnode = _Fixnodeparent;

  00647	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  0064a	89 4d f0	 mov	 DWORD PTR __Fixnode$[ebp], ecx

; 1474 : 						}
; 1475 : 					else

  0064d	e9 ba 00 00 00	 jmp	 $LN8@erase
$LN4@erase:

; 1476 : 						{	// must rearrange left subtree
; 1477 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  00652	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00655	52		 push	 edx
  00656	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  0065b	83 c4 04	 add	 esp, 4
  0065e	8b 00		 mov	 eax, DWORD PTR [eax]
  00660	50		 push	 eax
  00661	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  00666	83 c4 04	 add	 esp, 4
  00669	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0066c	83 f9 01	 cmp	 ecx, 1
  0066f	75 46		 jne	 SHORT $LN2@erase

; 1478 : 							{	// rotate red up from right sub-subtree
; 1479 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  00671	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00674	52		 push	 edx
  00675	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  0067a	83 c4 04	 add	 esp, 4
  0067d	8b 00		 mov	 eax, DWORD PTR [eax]
  0067f	50		 push	 eax
  00680	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  00685	83 c4 04	 add	 esp, 4
  00688	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1480 : 							this->_Color(_Pnode) = this->_Red;

  0068b	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0068e	51		 push	 ecx
  0068f	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  00694	83 c4 04	 add	 esp, 4
  00697	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1481 : 							_Lrotate(_Pnode);

  0069a	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0069d	52		 push	 edx
  0069e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  006a1	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Lrotate

; 1482 : 							_Pnode = this->_Left(_Fixnodeparent);

  006a6	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  006a9	50		 push	 eax
  006aa	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  006af	83 c4 04	 add	 esp, 4
  006b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  006b4	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN2@erase:

; 1483 : 							}
; 1484 : 
; 1485 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  006b7	8b 55 f4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  006ba	52		 push	 edx
  006bb	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  006c0	83 c4 04	 add	 esp, 4
  006c3	8b f0		 mov	 esi, eax
  006c5	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  006c8	50		 push	 eax
  006c9	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  006ce	83 c4 04	 add	 esp, 4
  006d1	8a 0e		 mov	 cl, BYTE PTR [esi]
  006d3	88 08		 mov	 BYTE PTR [eax], cl

; 1486 : 						this->_Color(_Fixnodeparent) = this->_Black;

  006d5	8b 55 f4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  006d8	52		 push	 edx
  006d9	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  006de	83 c4 04	 add	 esp, 4
  006e1	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1487 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  006e4	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  006e7	50		 push	 eax
  006e8	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  006ed	83 c4 04	 add	 esp, 4
  006f0	8b 08		 mov	 ecx, DWORD PTR [eax]
  006f2	51		 push	 ecx
  006f3	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  006f8	83 c4 04	 add	 esp, 4
  006fb	c6 00 01	 mov	 BYTE PTR [eax], 1

; 1488 : 						_Rrotate(_Fixnodeparent);

  006fe	8b 55 f4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  00701	52		 push	 edx
  00702	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00705	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Rrotate

; 1489 : 						break;	// tree now recolored/rebalanced

  0070a	eb 05		 jmp	 SHORT $LN16@erase
$LN8@erase:

; 1490 : 						}
; 1491 : 					}

  0070c	e9 82 fc ff ff	 jmp	 $LN17@erase
$LN16@erase:

; 1492 : 
; 1493 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  00711	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00714	50		 push	 eax
  00715	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  0071a	83 c4 04	 add	 esp, 4
  0071d	c6 00 01	 mov	 BYTE PTR [eax], 1
$LN19@erase:

; 1494 : 			}
; 1495 : 
; 1496 : 		this->_Getal().destroy(
; 1497 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node

  00720	8b 4d ec	 mov	 ecx, DWORD PTR __Erasednode$[ebp]
  00723	51		 push	 ecx
  00724	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAU?$pair@$$CBIN@2@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Myval
  00729	83 c4 04	 add	 esp, 4
  0072c	50		 push	 eax
  0072d	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBIN@std@@@std@@YAPAU?$pair@$$CBIN@0@AAU10@@Z ; std::addressof<std::pair<unsigned int const ,double> >
  00732	83 c4 04	 add	 esp, 4
  00735	50		 push	 eax
  00736	8d 55 ff	 lea	 edx, DWORD PTR $T2[ebp]
  00739	52		 push	 edx
  0073a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0073d	e8 00 00 00 00	 call	 ?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Getal
  00742	8b c8		 mov	 ecx, eax
  00744	e8 00 00 00 00	 call	 ??$destroy@U?$pair@$$CBIN@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBIN@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::destroy<std::pair<unsigned int const ,double> >

; 1498 : 
; 1499 : 		this->_Getal().deallocate(_Erasednode, 1);

  00749	6a 01		 push	 1
  0074b	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0074e	50		 push	 eax
  0074f	8d 4d fe	 lea	 ecx, DWORD PTR $T1[ebp]
  00752	51		 push	 ecx
  00753	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00756	e8 00 00 00 00	 call	 ?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Getal
  0075b	8b c8		 mov	 ecx, eax
  0075d	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::deallocate

; 1500 : 
; 1501 : 		if (0 < this->_Mysize)

  00762	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00765	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00769	76 0f		 jbe	 SHORT $LN1@erase

; 1502 : 			--this->_Mysize;

  0076b	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0076e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00771	83 e9 01	 sub	 ecx, 1
  00774	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00777	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN1@erase:

; 1503 : 
; 1504 : 		return (iterator(_Where._Ptr, this));	// return successor iterator

  0077a	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0077d	50		 push	 eax
  0077e	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00781	51		 push	 ecx
  00782	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00785	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >
  0078a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase:

; 1505 : 		}

  0078d	5e		 pop	 esi
  0078e	8b e5		 mov	 esp, ebp
  00790	5d		 pop	 ebp
  00791	c2 08 00	 ret	 8
?erase@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::clear, COMDAT
; _this$ = ecx

; 1532 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1533 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1534 : 		this->_Orphan_ptr(*this, 0);
; 1535 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1536 : 
; 1537 : 		_Erase(_Root());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Root
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Erase

; 1538 : 		_Root() = this->_Myhead;

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Root
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	8b 11		 mov	 edx, DWORD PTR [ecx]
  00027	89 10		 mov	 DWORD PTR [eax], edx

; 1539 : 		_Lmost() = this->_Myhead;

  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Lmost@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Lmost
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 11		 mov	 edx, DWORD PTR [ecx]
  00036	89 10		 mov	 DWORD PTR [eax], edx

; 1540 : 		_Rmost() = this->_Myhead;

  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?_Rmost@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Rmost
  00040	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	8b 11		 mov	 edx, DWORD PTR [ecx]
  00045	89 10		 mov	 DWORD PTR [eax], edx

; 1541 : 		this->_Mysize = 0;

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1542 : 		}

  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lmost@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 2108 : 		{	// return leftmost node in nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2109 : 		return (this->_Left(this->_Myhead));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  00012	83 c4 04	 add	 esp, 4

; 2110 : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Lmost
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??0?$_Tree_buy@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBIN@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 4
??0?$_Tree_buy@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBIN@std@@@1@@Z PROC ; std::_Tree_buy<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > >::_Tree_buy<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > >, COMDAT
; _this$ = ecx

; 893  : 		{	// construct from allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Al$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIN@std@@@1@@Z ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >

; 894  : 		}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$_Tree_buy@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBIN@std@@@1@@Z ENDP ; std::_Tree_buy<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > >::_Tree_buy<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Getal, COMDAT
; _this$ = ecx

; 873  : 		{	// get allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 874  : 		return (_Alty());

  00007	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 875  : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >::deallocate

; 888  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left, COMDAT

; 592  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  : 		return ((_Nodepref)_Pnode->_Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 594  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent, COMDAT

; 597  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 599  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right, COMDAT

; 602  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 603  : 		return ((_Nodepref)_Pnode->_Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 604  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?max_size@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT
; _this$ = ecx

; 1376 : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1377 : 		return (this->_Getal().max_size());

  00009	8d 45 ff	 lea	 eax, DWORD PTR $T1[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Getal
  00015	8b c8		 mov	 ecx, eax
  00017	e8 00 00 00 00	 call	 ?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size

; 1378 : 		}

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?max_size@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Xlen@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ PROC ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen, COMDAT
; _this$ = ecx

; 1792 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1793 : 		_Xlength_error("deque<T> too long");

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN2@Xlen:

; 1794 : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Xlen@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ENDP ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??3@YAXPAX@Z
  00011	83 c4 04	 add	 esp, 4

; 587  : 		}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

  00007	6a 00		 push	 0
  00009	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00012	83 c4 08	 add	 esp, 8

; 592  : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -20						; size = 8
_this$ = -12						; size = 4
__Alproxy$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 897  : 		{	// construct proxy from _Alval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 898  : 		typename _Alty::template rebind<_Container_proxy>::other
; 899  : 			_Alproxy;

  00013	8d 4d fb	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00016	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> >

; 900  : 		this->_Myproxy = _Alproxy.allocate(1);

  0001b	6a 01		 push	 1
  0001d	8d 4d fb	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  00020	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
  00025	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	89 01		 mov	 DWORD PTR [ecx], eax

; 901  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());

  0002a	8d 4d ec	 lea	 ecx, DWORD PTR $T1[ebp]
  0002d	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy
  00032	50		 push	 eax
  00033	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00036	8b 02		 mov	 eax, DWORD PTR [edx]
  00038	50		 push	 eax
  00039	8d 4d fb	 lea	 ecx, DWORD PTR __Alproxy$[ebp]
  0003c	e8 00 00 00 00	 call	 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>

; 902  : 		this->_Myproxy->_Mycont = this;

  00041	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	8b 11		 mov	 edx, DWORD PTR [ecx]
  00046	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00049	89 02		 mov	 DWORD PTR [edx], eax

; 903  : 		}

  0004b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004e	33 cd		 xor	 ecx, ebp
  00050	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 831  : 		}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?allocate@?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::allocate

; 877  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?allocate@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??3@YAXPAX@Z
  00011	83 c4 04	 add	 esp, 4

; 587  : 		}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
?deallocate@?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??0?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 776  : 	_Deque_val()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Container_base12@std@@QAE@XZ

; 777  : 		{	// initialize values
; 778  : 		_Map = _Mapptr();

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 779  : 		_Mapsize = 0;

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 780  : 		_Myoff = 0;

  00024	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00027	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 781  : 		_Mysize = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 782  : 		}

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??0?$_Deque_val@U?$_Deque_simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Deque_val<std::_Deque_simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >, COMDAT
; _this$ = ecx

; 384  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >

; 385  : 		}

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::operator++, COMDAT
; _this$ = ecx

; 276  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 277  : 		_Myiter _Tmp = *this;

  00013	6a 01		 push	 1
  00015	8d 4d f8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00018	e8 00 00 00 00	 call	 ?__autoclassinit@?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAEXI@Z
  0001d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 08		 mov	 ecx, DWORD PTR [eax]
  00022	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 278  : 		++*this;

  00025	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::operator++

; 279  : 		return (_Tmp);

  0002d	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00030	8b 45 f8	 mov	 eax, DWORD PTR __Tmp$[ebp]
  00033	89 02		 mov	 DWORD PTR [edx], eax
  00035	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 280  : 		}

  00038	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003b	33 cd		 xor	 ecx, ebp
  0003d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 08 00	 ret	 8
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv75 = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::operator==, COMDAT
; _this$ = ecx

; 322  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00013	75 09		 jne	 SHORT $LN3@operator
  00015	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv75[ebp], 1
  0001c	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN4@operator:
  00025	8a 45 fc	 mov	 al, BYTE PTR tv75[ebp]

; 337  : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv69 = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::operator!=, COMDAT
; _this$ = ecx

; 340  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 341  : 		return (!(*this == _Right));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::operator==
  00015	0f b6 c8	 movzx	 ecx, al
  00018	85 c9		 test	 ecx, ecx
  0001a	75 09		 jne	 SHORT $LN3@operator
  0001c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00023	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  0002c	8a 45 fc	 mov	 al, BYTE PTR tv69[ebp]

; 342  : 		}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>

; 831  : 		}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate

; 888  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit@?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_$initVBases$ = 8					; size = 4
?__autoclassinit@?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAEXI@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::__autoclassinit, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?__autoclassinit@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEXI@Z
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?__autoclassinit@?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAEXI@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::__autoclassinit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_$initVBases$ = 8					; size = 4
?__autoclassinit@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEXI@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >,std::_Iterator_base0>::__autoclassinit, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?__autoclassinit@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEXI@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >,std::_Iterator_base0>::__autoclassinit
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Pnode$1 = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 2060 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2061 : 		for (_Nodeptr _Pnode = _Rootnode;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __Pnode$1[ebp], eax

; 2062 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  0000f	eb 06		 jmp	 SHORT $LN3@Erase
$LN2@Erase:
  00011	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$1[ebp]
  00014	89 4d 08	 mov	 DWORD PTR __Rootnode$[ebp], ecx
$LN3@Erase:
  00017	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$1[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Isnil
  00020	83 c4 04	 add	 esp, 4
  00023	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00026	85 c0		 test	 eax, eax
  00028	75 6f		 jne	 SHORT $LN4@Erase

; 2063 : 			{	// free subtrees, then node
; 2064 : 			_Erase(this->_Right(_Pnode));

  0002a	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$1[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  00033	83 c4 04	 add	 esp, 4
  00036	8b 10		 mov	 edx, DWORD PTR [eax]
  00038	52		 push	 edx
  00039	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Erase

; 2065 : 			_Pnode = this->_Left(_Pnode);

  00041	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$1[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  0004a	83 c4 04	 add	 esp, 4
  0004d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004f	89 4d f8	 mov	 DWORD PTR __Pnode$1[ebp], ecx

; 2066 : 			this->_Getal().destroy(
; 2067 : 				_STD addressof(this->_Myval(_Rootnode)));

  00052	8b 55 08	 mov	 edx, DWORD PTR __Rootnode$[ebp]
  00055	52		 push	 edx
  00056	e8 00 00 00 00	 call	 ?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAU?$pair@$$CBIN@2@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Myval
  0005b	83 c4 04	 add	 esp, 4
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBIN@std@@@std@@YAPAU?$pair@$$CBIN@0@AAU10@@Z ; std::addressof<std::pair<unsigned int const ,double> >
  00064	83 c4 04	 add	 esp, 4
  00067	50		 push	 eax
  00068	8d 45 ff	 lea	 eax, DWORD PTR $T3[ebp]
  0006b	50		 push	 eax
  0006c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	e8 00 00 00 00	 call	 ?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Getal
  00074	8b c8		 mov	 ecx, eax
  00076	e8 00 00 00 00	 call	 ??$destroy@U?$pair@$$CBIN@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBIN@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::destroy<std::pair<unsigned int const ,double> >

; 2068 : 
; 2069 : 			this->_Getal().deallocate(_Rootnode, 1);

  0007b	6a 01		 push	 1
  0007d	8b 4d 08	 mov	 ecx, DWORD PTR __Rootnode$[ebp]
  00080	51		 push	 ecx
  00081	8d 55 fe	 lea	 edx, DWORD PTR $T2[ebp]
  00084	52		 push	 edx
  00085	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	e8 00 00 00 00	 call	 ?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Getal
  0008d	8b c8		 mov	 ecx, eax
  0008f	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::deallocate

; 2070 : 			}

  00094	e9 78 ff ff ff	 jmp	 $LN2@Erase
$LN4@Erase:

; 2071 : 		}

  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 2113 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2114 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  0000a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  00013	83 c4 04	 add	 esp, 4
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	89 4d fc	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 2115 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0001b	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0001e	52		 push	 edx
  0001f	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  00024	83 c4 04	 add	 esp, 4
  00027	8b f0		 mov	 esi, eax
  00029	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  00032	83 c4 04	 add	 esp, 4
  00035	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00037	89 08		 mov	 DWORD PTR [eax], ecx

; 2116 : 
; 2117 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  00039	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  00042	83 c4 04	 add	 esp, 4
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Isnil
  0004d	83 c4 04	 add	 esp, 4
  00050	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00053	85 c9		 test	 ecx, ecx
  00055	75 1c		 jne	 SHORT $LN5@Lrotate

; 2118 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00057	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0005a	52		 push	 edx
  0005b	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  00060	83 c4 04	 add	 esp, 4
  00063	8b 00		 mov	 eax, DWORD PTR [eax]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  0006b	83 c4 04	 add	 esp, 4
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00071	89 08		 mov	 DWORD PTR [eax], ecx
$LN5@Lrotate:

; 2119 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00073	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00076	52		 push	 edx
  00077	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  0007c	83 c4 04	 add	 esp, 4
  0007f	8b f0		 mov	 esi, eax
  00081	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  0008a	83 c4 04	 add	 esp, 4
  0008d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0008f	89 08		 mov	 DWORD PTR [eax], ecx

; 2120 : 
; 2121 : 		if (_Wherenode == _Root())

  00091	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Root
  00099	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  0009c	3b 10		 cmp	 edx, DWORD PTR [eax]
  0009e	75 0f		 jne	 SHORT $LN4@Lrotate

; 2122 : 			_Root() = _Pnode;

  000a0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Root
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000ab	89 08		 mov	 DWORD PTR [eax], ecx
  000ad	eb 58		 jmp	 SHORT $LN3@Lrotate
$LN4@Lrotate:

; 2123 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  000af	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000b2	52		 push	 edx
  000b3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  000b8	83 c4 04	 add	 esp, 4
  000bb	8b 00		 mov	 eax, DWORD PTR [eax]
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  000c3	83 c4 04	 add	 esp, 4
  000c6	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  000c9	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000cb	75 1e		 jne	 SHORT $LN2@Lrotate

; 2124 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  000cd	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000d0	52		 push	 edx
  000d1	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  000d6	83 c4 04	 add	 esp, 4
  000d9	8b 00		 mov	 eax, DWORD PTR [eax]
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  000e1	83 c4 04	 add	 esp, 4
  000e4	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000e7	89 08		 mov	 DWORD PTR [eax], ecx

; 2125 : 		else

  000e9	eb 1c		 jmp	 SHORT $LN3@Lrotate
$LN2@Lrotate:

; 2126 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  000eb	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000ee	52		 push	 edx
  000ef	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  000f4	83 c4 04	 add	 esp, 4
  000f7	8b 00		 mov	 eax, DWORD PTR [eax]
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  000ff	83 c4 04	 add	 esp, 4
  00102	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00105	89 08		 mov	 DWORD PTR [eax], ecx
$LN3@Lrotate:

; 2127 : 
; 2128 : 		this->_Left(_Pnode) = _Wherenode;

  00107	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0010a	52		 push	 edx
  0010b	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  00110	83 c4 04	 add	 esp, 4
  00113	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00116	89 08		 mov	 DWORD PTR [eax], ecx

; 2129 : 		this->_Parent(_Wherenode) = _Pnode;

  00118	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  0011b	52		 push	 edx
  0011c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  00121	83 c4 04	 add	 esp, 4
  00124	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00127	89 08		 mov	 DWORD PTR [eax], ecx

; 2130 : 		}

  00129	5e		 pop	 esi
  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Rmost@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 2133 : 		{	// return rightmost node in nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2134 : 		return (this->_Right(this->_Myhead));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  00012	83 c4 04	 add	 esp, 4

; 2135 : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Rmost
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Root@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Root, COMDAT
; _this$ = ecx

; 2138 : 		{	// return root of nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2139 : 		return (this->_Parent(this->_Myhead));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  00012	83 c4 04	 add	 esp, 4

; 2140 : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Root
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 2143 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2144 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  0000a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  00013	83 c4 04	 add	 esp, 4
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	89 4d fc	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 2145 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  0001b	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0001e	52		 push	 edx
  0001f	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  00024	83 c4 04	 add	 esp, 4
  00027	8b f0		 mov	 esi, eax
  00029	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  00032	83 c4 04	 add	 esp, 4
  00035	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00037	89 08		 mov	 DWORD PTR [eax], ecx

; 2146 : 
; 2147 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  00039	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  00042	83 c4 04	 add	 esp, 4
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Isnil
  0004d	83 c4 04	 add	 esp, 4
  00050	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00053	85 c9		 test	 ecx, ecx
  00055	75 1c		 jne	 SHORT $LN5@Rrotate

; 2148 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00057	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0005a	52		 push	 edx
  0005b	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  00060	83 c4 04	 add	 esp, 4
  00063	8b 00		 mov	 eax, DWORD PTR [eax]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  0006b	83 c4 04	 add	 esp, 4
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00071	89 08		 mov	 DWORD PTR [eax], ecx
$LN5@Rrotate:

; 2149 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00073	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00076	52		 push	 edx
  00077	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  0007c	83 c4 04	 add	 esp, 4
  0007f	8b f0		 mov	 esi, eax
  00081	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  0008a	83 c4 04	 add	 esp, 4
  0008d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0008f	89 08		 mov	 DWORD PTR [eax], ecx

; 2150 : 
; 2151 : 		if (_Wherenode == _Root())

  00091	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Root
  00099	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  0009c	3b 10		 cmp	 edx, DWORD PTR [eax]
  0009e	75 0f		 jne	 SHORT $LN4@Rrotate

; 2152 : 			_Root() = _Pnode;

  000a0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	e8 00 00 00 00	 call	 ?_Root@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Root
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000ab	89 08		 mov	 DWORD PTR [eax], ecx
  000ad	eb 58		 jmp	 SHORT $LN3@Rrotate
$LN4@Rrotate:

; 2153 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  000af	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000b2	52		 push	 edx
  000b3	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  000b8	83 c4 04	 add	 esp, 4
  000bb	8b 00		 mov	 eax, DWORD PTR [eax]
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  000c3	83 c4 04	 add	 esp, 4
  000c6	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  000c9	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000cb	75 1e		 jne	 SHORT $LN2@Rrotate

; 2154 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  000cd	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000d0	52		 push	 edx
  000d1	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  000d6	83 c4 04	 add	 esp, 4
  000d9	8b 00		 mov	 eax, DWORD PTR [eax]
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  000e1	83 c4 04	 add	 esp, 4
  000e4	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000e7	89 08		 mov	 DWORD PTR [eax], ecx

; 2155 : 		else

  000e9	eb 1c		 jmp	 SHORT $LN3@Rrotate
$LN2@Rrotate:

; 2156 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  000eb	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  000ee	52		 push	 edx
  000ef	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  000f4	83 c4 04	 add	 esp, 4
  000f7	8b 00		 mov	 eax, DWORD PTR [eax]
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  000ff	83 c4 04	 add	 esp, 4
  00102	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00105	89 08		 mov	 DWORD PTR [eax], ecx
$LN3@Rrotate:

; 2157 : 
; 2158 : 		this->_Right(_Pnode) = _Wherenode;

  00107	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0010a	52		 push	 edx
  0010b	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  00110	83 c4 04	 add	 esp, 4
  00113	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00116	89 08		 mov	 DWORD PTR [eax], ecx

; 2159 : 		this->_Parent(_Wherenode) = _Pnode;

  00118	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  0011b	52		 push	 edx
  0011c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  00121	83 c4 04	 add	 esp, 4
  00124	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00127	89 08		 mov	 DWORD PTR [eax], ecx

; 2160 : 		}

  00129	5e		 pop	 esi
  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@INU?$less@I@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,double> >,0> >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIN@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIN@std@@@1@@Z PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >, COMDAT
; _this$ = ecx

; 776  : 	_Tree_alloc(const _Alloc& = _Alloc())

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >

; 777  : 		{	// construct head node, allocator from _Al
; 778  : 		this->_Myhead = _Buyheadnode();

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Buyheadnode
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	89 01		 mov	 DWORD PTR [ecx], eax

; 779  : 		}

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIN@std@@@1@@Z ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >

; 831  : 		}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??3@YAXPAX@Z
  00011	83 c4 04	 add	 esp, 4

; 587  : 		}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color, COMDAT

; 582  : 		{	// return reference to color in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 583  : 		return ((char&)_Pnode->_Color);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 584  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Isnil, COMDAT

; 587  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 588  : 		return ((char&)_Pnode->_Isnil);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0d	 add	 eax, 13			; 0000000dH

; 589  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Isnil
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAU?$pair@$$CBIN@2@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAU?$pair@$$CBIN@2@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Myval, COMDAT

; 607  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 608  : 		return ((reference)_Pnode->_Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 10	 add	 eax, 16			; 00000010H

; 609  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAU?$pair@$$CBIN@2@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Myval
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Max, COMDAT

; 612  : 		{	// return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$LN2@Max:

; 613  : 		while (!_Isnil(_Right(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  0000c	83 c4 04	 add	 esp, 4
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Isnil
  00017	83 c4 04	 add	 esp, 4
  0001a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0001d	85 d2		 test	 edx, edx
  0001f	75 13		 jne	 SHORT $LN1@Max

; 614  : 			_Pnode = _Right(_Pnode);

  00021	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  0002a	83 c4 04	 add	 esp, 4
  0002d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002f	89 4d 08	 mov	 DWORD PTR __Pnode$[ebp], ecx
  00032	eb cf		 jmp	 SHORT $LN2@Max
$LN1@Max:

; 615  : 		return (_Pnode);

  00034	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 616  : 		}

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Max
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Min, COMDAT

; 619  : 		{	// return leftmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$LN2@Min:

; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  0000c	83 c4 04	 add	 esp, 4
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Isnil
  00017	83 c4 04	 add	 esp, 4
  0001a	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0001d	85 d2		 test	 edx, edx
  0001f	75 13		 jne	 SHORT $LN1@Min

; 621  : 			_Pnode = _Left(_Pnode);

  00021	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  0002a	83 c4 04	 add	 esp, 4
  0002d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002f	89 4d 08	 mov	 DWORD PTR __Pnode$[ebp], ecx
  00032	eb cf		 jmp	 SHORT $LN2@Min
$LN1@Min:

; 622  : 		return (_Pnode);

  00034	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 623  : 		}

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Min
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?max_size@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
  00010	83 c4 04	 add	 esp, 4

; 915  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

  00007	6a 00		 push	 0
  00009	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Allocate@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAPAV10@@Z ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
  00012	83 c4 08	 add	 esp, 8

; 592  : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?allocate@?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >, COMDAT
; _this$ = ecx

; 214  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >,std::_Iterator_base0>

; 215  : 		}

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::operator++, COMDAT
; _this$ = ecx

; 256  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >,std::_Iterator_base0>::operator++

; 272  : 		return (*this);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 273  : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 122  : 		{	// return node pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 123  : 		return (_Ptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 124  : 		}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate

; 877  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ PROC	; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ENDP	; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??3@YAXPAX@Z
  00011	83 c4 04	 add	 esp, 4

; 587  : 		}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ
_TEXT	SEGMENT
tv150 = -60						; size = 4
tv147 = -56						; size = 4
tv149 = -52						; size = 4
tv146 = -48						; size = 4
tv148 = -44						; size = 4
tv145 = -40						; size = 4
$T2 = -33						; size = 1
$T3 = -32						; size = 1
$T4 = -31						; size = 1
$T5 = -30						; size = 1
$T6 = -29						; size = 1
_this$ = -28						; size = 4
__Pnode$ = -24						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Buyheadnode, COMDAT
; _this$ = ecx

; 841  : 		{	// get head node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001f	53		 push	 ebx
  00020	56		 push	 esi
  00021	57		 push	 edi
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002f	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 842  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);

  00032	6a 01		 push	 1
  00034	8d 45 df	 lea	 eax, DWORD PTR $T2[ebp]
  00037	50		 push	 eax
  00038	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Getal
  00040	8b c8		 mov	 ecx, eax
  00042	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::allocate
  00047	89 45 e8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 843  : 
; 844  : 		_TRY_BEGIN

  0004a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 845  : 		this->_Getal().construct(
; 846  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);

  00051	8b 4d e8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Left
  0005a	83 c4 04	 add	 esp, 4
  0005d	89 45 d8	 mov	 DWORD PTR tv145[ebp], eax
  00060	8d 55 e1	 lea	 edx, DWORD PTR $T4[ebp]
  00063	52		 push	 edx
  00064	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Getal
  0006c	89 45 d0	 mov	 DWORD PTR tv146[ebp], eax
  0006f	8d 45 e8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  00072	50		 push	 eax
  00073	8b 4d d8	 mov	 ecx, DWORD PTR tv145[ebp]
  00076	51		 push	 ecx
  00077	e8 00 00 00 00	 call	 ??$addressof@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *>
  0007c	83 c4 04	 add	 esp, 4
  0007f	50		 push	 eax
  00080	8b 4d d0	 mov	 ecx, DWORD PTR tv146[ebp]
  00083	e8 00 00 00 00	 call	 ??$construct@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::construct<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *,std::_Tree_node<std::pair<unsigned int const ,double>,void *> * &>

; 847  : 		this->_Getal().construct(
; 848  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);

  00088	8b 55 e8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0008b	52		 push	 edx
  0008c	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  00091	83 c4 04	 add	 esp, 4
  00094	89 45 c8	 mov	 DWORD PTR tv147[ebp], eax
  00097	8d 45 e2	 lea	 eax, DWORD PTR $T5[ebp]
  0009a	50		 push	 eax
  0009b	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0009e	e8 00 00 00 00	 call	 ?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Getal
  000a3	89 45 d4	 mov	 DWORD PTR tv148[ebp], eax
  000a6	8d 4d e8	 lea	 ecx, DWORD PTR __Pnode$[ebp]
  000a9	51		 push	 ecx
  000aa	8b 55 c8	 mov	 edx, DWORD PTR tv147[ebp]
  000ad	52		 push	 edx
  000ae	e8 00 00 00 00	 call	 ??$addressof@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *>
  000b3	83 c4 04	 add	 esp, 4
  000b6	50		 push	 eax
  000b7	8b 4d d4	 mov	 ecx, DWORD PTR tv148[ebp]
  000ba	e8 00 00 00 00	 call	 ??$construct@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::construct<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *,std::_Tree_node<std::pair<unsigned int const ,double>,void *> * &>

; 849  : 		this->_Getal().construct(
; 850  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);

  000bf	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  000c8	83 c4 04	 add	 esp, 4
  000cb	89 45 cc	 mov	 DWORD PTR tv149[ebp], eax
  000ce	8d 4d e0	 lea	 ecx, DWORD PTR $T3[ebp]
  000d1	51		 push	 ecx
  000d2	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	e8 00 00 00 00	 call	 ?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Getal
  000da	89 45 c4	 mov	 DWORD PTR tv150[ebp], eax
  000dd	8d 55 e8	 lea	 edx, DWORD PTR __Pnode$[ebp]
  000e0	52		 push	 edx
  000e1	8b 45 cc	 mov	 eax, DWORD PTR tv149[ebp]
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 ??$addressof@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *>
  000ea	83 c4 04	 add	 esp, 4
  000ed	50		 push	 eax
  000ee	8b 4d c4	 mov	 ecx, DWORD PTR tv150[ebp]
  000f1	e8 00 00 00 00	 call	 ??$construct@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::construct<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *,std::_Tree_node<std::pair<unsigned int const ,double>,void *> * &>
  000f6	eb 28		 jmp	 SHORT $LN4@Buyheadnod
__catch$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ$0:

; 851  : 		_CATCH_ALL
; 852  : 		this->_Getal().deallocate(_Pnode, 1);

  000f8	6a 01		 push	 1
  000fa	8b 4d e8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000fd	51		 push	 ecx
  000fe	8d 55 e3	 lea	 edx, DWORD PTR $T6[ebp]
  00101	52		 push	 edx
  00102	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	e8 00 00 00 00	 call	 ?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Getal
  0010a	8b c8		 mov	 ecx, eax
  0010c	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::deallocate

; 853  : 		_RERAISE;

  00111	6a 00		 push	 0
  00113	6a 00		 push	 0
  00115	e8 00 00 00 00	 call	 __CxxThrowException@8

; 854  : 		_CATCH_END

  0011a	b8 00 00 00 00	 mov	 eax, $LN7@Buyheadnod
  0011f	c3		 ret	 0
$LN4@Buyheadnod:
  00120	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00127	eb 07		 jmp	 SHORT __tryend$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ$1
$LN7@Buyheadnod:
  00129	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ$1:

; 855  : 
; 856  : 		this->_Color(_Pnode) = this->_Black;

  00130	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00133	50		 push	 eax
  00134	e8 00 00 00 00	 call	 ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Color
  00139	83 c4 04	 add	 esp, 4
  0013c	c6 00 01	 mov	 BYTE PTR [eax], 1

; 857  : 		this->_Isnil(_Pnode) = true;

  0013f	8b 4d e8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00142	51		 push	 ecx
  00143	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Isnil
  00148	83 c4 04	 add	 esp, 4
  0014b	c6 00 01	 mov	 BYTE PTR [eax], 1

; 858  : 		return (_Pnode);

  0014e	8b 45 e8	 mov	 eax, DWORD PTR __Pnode$[ebp]
$LN3@Buyheadnod:

; 859  : 		}

  00151	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00154	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0015b	59		 pop	 ecx
  0015c	5f		 pop	 edi
  0015d	5e		 pop	 esi
  0015e	5b		 pop	 ebx
  0015f	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00162	33 cd		 xor	 ecx, ebp
  00164	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00169	8b e5		 mov	 esp, ebp
  0016b	5d		 pop	 ebp
  0016c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a c0	 mov	 ecx, DWORD PTR [edx-64]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00014	33 c8		 xor	 ecx, eax
  00016	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ
  00020	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBIN@std@@V?$allocator@U?$pair@$$CBIN@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<unsigned int const ,double>,std::allocator<std::pair<unsigned int const ,double> > > >::_Buyheadnode
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >, COMDAT
; _this$ = ecx

; 571  : 	_Tree_val()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 574  : 		this->_Mysize = 0;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 575  : 		}

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT

; 761  : 		{	// get maximum size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 762  : 		return (_Al.max_size());

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00006	e8 00 00 00 00	 call	 ?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size

; 763  : 		}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAIABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 45   : 		this->_Adopt(_Plist);

  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Plist$[ebp]
  00012	52		 push	 edx
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 46   : 		}

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Pnode$1 = -8						; size = 4
_this$ = -4						; size = 4
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 59   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Isnil
  00014	83 c4 04	 add	 esp, 4
  00017	0f be 10	 movsx	 edx, BYTE PTR [eax]
  0001a	85 d2		 test	 edx, edx
  0001c	74 05		 je	 SHORT $LN6@operator
  0001e	e9 8d 00 00 00	 jmp	 $LN5@operator
$LN6@operator:

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 08		 mov	 ecx, DWORD PTR [eax]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  0002e	83 c4 04	 add	 esp, 4
  00031	8b 10		 mov	 edx, DWORD PTR [eax]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Isnil
  00039	83 c4 04	 add	 esp, 4
  0003c	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0003f	85 c0		 test	 eax, eax
  00041	75 20		 jne	 SHORT $LN2@operator

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 11		 mov	 edx, DWORD PTR [ecx]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  0004e	83 c4 04	 add	 esp, 4
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Min
  00059	83 c4 04	 add	 esp, 4
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	89 01		 mov	 DWORD PTR [ecx], eax

; 65   : 		else

  00061	eb 4d		 jmp	 SHORT $LN5@operator
$LN2@operator:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  00063	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00066	8b 02		 mov	 eax, DWORD PTR [edx]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Parent
  0006e	83 c4 04	 add	 esp, 4
  00071	8b 08		 mov	 ecx, DWORD PTR [eax]
  00073	89 4d f8	 mov	 DWORD PTR __Pnode$1[ebp], ecx
  00076	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$1[ebp]
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Isnil
  0007f	83 c4 04	 add	 esp, 4
  00082	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00085	85 c0		 test	 eax, eax
  00087	75 1f		 jne	 SHORT $LN1@operator
  00089	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$1[ebp]
  0008c	51		 push	 ecx
  0008d	e8 00 00 00 00	 call	 ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >::_Right
  00092	83 c4 04	 add	 esp, 4
  00095	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00098	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0009a	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0009c	75 0a		 jne	 SHORT $LN1@operator

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0009e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a1	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$1[ebp]
  000a4	89 02		 mov	 DWORD PTR [edx], eax
  000a6	eb bb		 jmp	 SHORT $LN2@operator
$LN1@operator:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  000a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$1[ebp]
  000ae	89 11		 mov	 DWORD PTR [ecx], edx
$LN5@operator:

; 72   : 			}
; 73   : 		return (*this);

  000b0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 74   : 		}

  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBIN@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned int const ,double> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

  00007	6a 00		 push	 0
  00009	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>
  00012	83 c4 08	 add	 esp, 8

; 592  : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >::allocate

; 877  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

  00007	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 629  : 		}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

  00007	6a 00		 push	 0
  00009	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Allocate@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@0@IPAU10@@Z ; std::_Allocate<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >
  00012	83 c4 08	 add	 esp, 8

; 592  : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@PAE@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAPAE@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@PAE@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@PAE@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAPAE@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@PAE@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned char * *> >::_Wrap_alloc<std::allocator<unsigned char * *> ><std::_Wrap_alloc<std::allocator<unsigned char *> > >, COMDAT
; _this$ = ecx

; 846  : 		{	// construct from a related allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??$?0PAE@?$allocator@PAPAE@std@@QAE@ABV?$allocator@PAE@1@@Z ; std::allocator<unsigned char * *>::allocator<unsigned char * *><unsigned char *>

; 847  : 		}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@PAE@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAPAE@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@PAE@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned char * *> >::_Wrap_alloc<std::allocator<unsigned char * *> ><std::_Wrap_alloc<std::allocator<unsigned char *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAPAE@?$_Wrap_alloc@V?$allocator@PAE@std@@@std@@QAEXPAPAPAE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAPAE@?$_Wrap_alloc@V?$allocator@PAE@std@@@std@@QAEXPAPAPAE@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned char *> >::destroy<unsigned char * *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$destroy@PAPAE@?$allocator_traits@V?$allocator@PAE@std@@@std@@SAXAAV?$allocator@PAE@1@PAPAPAE@Z ; std::allocator_traits<std::allocator<unsigned char *> >::destroy<unsigned char * *>
  00014	83 c4 08	 add	 esp, 8

; 910  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??$destroy@PAPAE@?$_Wrap_alloc@V?$allocator@PAE@std@@@std@@QAEXPAPAPAE@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned char *> >::destroy<unsigned char * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR __V0$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$forward@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00017	51		 push	 ecx
  00018	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001b	52		 push	 edx
  0001c	e8 00 00 00 00	 call	 ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> >::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> ><std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 846  : 		{	// construct from a related allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *><std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 847  : 		}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??$?0U?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> >::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> ><std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$destroy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
  00014	83 c4 08	 add	 esp, 8

; 910  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??$destroy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAE@?$_Wrap_alloc@V?$allocator@PAE@std@@@std@@QAEXPAPAE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAE@?$_Wrap_alloc@V?$allocator@PAE@std@@@std@@QAEXPAPAE@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned char *> >::destroy<unsigned char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$destroy@PAE@?$allocator_traits@V?$allocator@PAE@std@@@std@@SAXAAV?$allocator@PAE@1@PAPAE@Z ; std::allocator_traits<std::allocator<unsigned char *> >::destroy<unsigned char *>
  00014	83 c4 08	 add	 esp, 8

; 910  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??$destroy@PAE@?$_Wrap_alloc@V?$allocator@PAE@std@@@std@@QAEXPAPAE@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned char *> >::destroy<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
  00014	83 c4 08	 add	 esp, 8

; 910  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *>, COMDAT

; 85   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 89   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::destroy<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$destroy@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::destroy<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *>
  00014	83 c4 08	 add	 esp, 8

; 910  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::destroy<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00014	83 c4 08	 add	 esp, 8

; 910  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAV12@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAV12@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 416  : 		_Ptr_cat(_First, _Dest)));

  00004	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
  00017	0f b6 55 ff	 movzx	 edx, BYTE PTR $T1[ebp]
  0001b	52		 push	 edx
  0001c	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00023	51		 push	 ecx
  00024	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00027	52		 push	 edx
  00028	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
  00031	83 c4 14	 add	 esp, 20			; 00000014H

; 417  : 	}

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??$_Uninitialized_copy@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAV12@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_default_fill_n@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,unsigned int,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >, COMDAT

; 668  : 	{	// copy _Count * _Val_type(_First)() to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 669  : 	_Uninit_def_fill_n(_First, _Count, _Al,
; 670  : 		_Val_type(_First), _Ptr_cat(_First, _First));

  00004	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
  00017	0f b6 55 ff	 movzx	 edx, BYTE PTR $T1[ebp]
  0001b	52		 push	 edx
  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??$_Val_type@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@@Z ; std::_Val_type<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *>
  00025	83 c4 04	 add	 esp, 4
  00028	50		 push	 eax
  00029	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  0002c	51		 push	 ecx
  0002d	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00030	52		 push	 edx
  00031	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ??$_Uninit_def_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IPAV12@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
  0003a	83 c4 14	 add	 esp, 20			; 00000014H

; 671  : 	}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??$_Uninitialized_default_fill_n@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,unsigned int,std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >, COMDAT

; 79   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 80   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
  00017	0f b6 55 ff	 movzx	 edx, BYTE PTR $T1[ebp]
  0001b	52		 push	 edx
  0001c	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00023	51		 push	 ecx
  00024	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00027	52		 push	 edx
  00028	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >
  0002d	83 c4 10	 add	 esp, 16			; 00000010H

; 81   : 	}

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR __V0$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00017	51		 push	 ecx
  00018	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001b	52		 push	 edx
  0001c	e8 00 00 00 00	 call	 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Tmp$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 46   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 47   : 	_Ty _Tmp = _Move(_Left);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Move@AAD@std@@YA$$QADAAD@Z ; std::_Move<char &>
  00019	83 c4 04	 add	 esp, 4
  0001c	8a 08		 mov	 cl, BYTE PTR [eax]
  0001e	88 4d fb	 mov	 BYTE PTR __Tmp$[ebp], cl

; 48   : 	_Left = _Move(_Right);

  00021	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  00024	52		 push	 edx
  00025	e8 00 00 00 00	 call	 ??$_Move@AAD@std@@YA$$QADAAD@Z ; std::_Move<char &>
  0002a	83 c4 04	 add	 esp, 4
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00030	8a 10		 mov	 dl, BYTE PTR [eax]
  00032	88 11		 mov	 BYTE PTR [ecx], dl

; 49   : 	_Right = _Move(_Tmp);

  00034	8d 45 fb	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$_Move@AAD@std@@YA$$QADAAD@Z ; std::_Move<char &>
  0003d	83 c4 04	 add	 esp, 4
  00040	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00043	8a 10		 mov	 dl, BYTE PTR [eax]
  00045	88 11		 mov	 BYTE PTR [ecx], dl

; 50   : 	}

  00047	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004a	33 cd		 xor	 ecx, ebp
  0004c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@U?$pair@$$CBIN@std@@@std@@YAPAU?$pair@$$CBIN@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBIN@std@@@std@@YAPAU?$pair@$$CBIN@0@AAU10@@Z PROC ; std::addressof<std::pair<unsigned int const ,double> >, COMDAT

; 85   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 89   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U?$pair@$$CBIN@std@@@std@@YAPAU?$pair@$$CBIN@0@AAU10@@Z ENDP ; std::addressof<std::pair<unsigned int const ,double> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBIN@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBIN@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@$$CBIN@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBIN@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::destroy<std::pair<unsigned int const ,double> >, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$destroy@U?$pair@$$CBIN@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@1@PAU?$pair@$$CBIN@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::destroy<std::pair<unsigned int const ,double> >
  00014	83 c4 08	 add	 esp, 8

; 910  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??$destroy@U?$pair@$$CBIN@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBIN@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::destroy<std::pair<unsigned int const ,double> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z PROC ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 23   : 	void *_Ptr = 0;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

  0000b	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0000f	75 02		 jne	 SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

  00011	eb 28		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00013	81 7d 08 aa aa
	aa 0a		 cmp	 DWORD PTR __Count$[ebp], 178956970 ; 0aaaaaaaH
  0001a	77 19		 ja	 SHORT $LN1@Allocate
  0001c	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0001f	6b c0 18	 imul	 eax, 24			; 00000018H
  00022	50		 push	 eax
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??2@YAPAXI@Z
  00029	83 c4 04	 add	 esp, 4
  0002c	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0002f	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  00033	75 06		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0003b	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ENDP ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAPAV10@@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAPAV10@@Z PROC ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 23   : 	void *_Ptr = 0;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

  0000b	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0000f	75 02		 jne	 SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

  00011	eb 28		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00013	81 7d 08 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  0001a	77 19		 ja	 SHORT $LN1@Allocate
  0001c	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0001f	c1 e0 02	 shl	 eax, 2
  00022	50		 push	 eax
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??2@YAPAXI@Z
  00029	83 c4 04	 add	 esp, 4
  0002c	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0002f	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  00033	75 06		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0003b	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??$_Allocate@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAPAV10@@Z ENDP ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::construct<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *,std::_Tree_node<std::pair<unsigned int const ,double>,void *> * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR __V0$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$forward@AAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<unsigned int const ,double>,void *> * &>
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00017	51		 push	 ecx
  00018	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001b	52		 push	 edx
  0001c	e8 00 00 00 00	 call	 ??$construct@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@AAPAU31@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::construct<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *,std::_Tree_node<std::pair<unsigned int const ,double>,void *> * &>
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??$construct@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::construct<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *,std::_Tree_node<std::pair<unsigned int const ,double>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z PROC ; std::_Allocate<std::_Container_proxy>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 23   : 	void *_Ptr = 0;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

  0000b	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0000f	75 02		 jne	 SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

  00011	eb 28		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00013	81 7d 08 ff ff
	ff 1f		 cmp	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH
  0001a	77 19		 ja	 SHORT $LN1@Allocate
  0001c	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0001f	c1 e0 03	 shl	 eax, 3
  00022	50		 push	 eax
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??2@YAPAXI@Z
  00029	83 c4 04	 add	 esp, 4
  0002c	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0002f	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  00033	75 06		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0003b	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ENDP ; std::_Allocate<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@0@IPAU10@@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@0@IPAU10@@Z PROC ; std::_Allocate<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 23   : 	void *_Ptr = 0;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

  0000b	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0000f	75 02		 jne	 SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

  00011	eb 28		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00013	81 7d 08 ff ff
	ff 07		 cmp	 DWORD PTR __Count$[ebp], 134217727 ; 07ffffffH
  0001a	77 19		 ja	 SHORT $LN1@Allocate
  0001c	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0001f	c1 e0 05	 shl	 eax, 5
  00022	50		 push	 eax
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??2@YAPAXI@Z
  00029	83 c4 04	 add	 esp, 4
  0002c	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0002f	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  00033	75 06		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  0003b	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??$_Allocate@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@0@IPAU10@@Z ENDP ; std::_Allocate<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$?0PAE@?$allocator@PAPAE@std@@QAE@ABV?$allocator@PAE@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAE@?$allocator@PAPAE@std@@QAE@ABV?$allocator@PAE@1@@Z PROC ; std::allocator<unsigned char * *>::allocator<unsigned char * *><unsigned char *>, COMDAT
; _this$ = ecx

; 574  : 		allocator(const allocator<_Other>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 575  : 		{	// construct from a related allocator (do nothing)
; 576  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??$?0PAE@?$allocator@PAPAE@std@@QAE@ABV?$allocator@PAE@1@@Z ENDP ; std::allocator<unsigned char * *>::allocator<unsigned char * *><unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAPAE@?$allocator_traits@V?$allocator@PAE@std@@@std@@SAXAAV?$allocator@PAE@1@PAPAPAE@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAPAE@?$allocator_traits@V?$allocator@PAE@std@@@std@@SAXAAV?$allocator@PAE@1@PAPAPAE@Z PROC ; std::allocator_traits<std::allocator<unsigned char *> >::destroy<unsigned char * *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	e8 00 00 00 00	 call	 ??$destroy@PAPAE@?$allocator@PAE@std@@QAEXPAPAPAE@Z ; std::allocator<unsigned char *>::destroy<unsigned char * *>

; 758  : 		}

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??$destroy@PAPAE@?$allocator_traits@V?$allocator@PAE@std@@@std@@SAXAAV?$allocator@PAE@1@PAPAPAE@Z ENDP ; std::allocator_traits<std::allocator<unsigned char *> >::destroy<unsigned char * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT

; 1775 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z PROC ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 10	 mov	 eax, DWORD PTR __V0$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??$forward@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
  0000c	83 c4 04	 add	 esp, 4
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00017	e8 00 00 00 00	 call	 ?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABV31@@Z ENDP ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *><std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 574  : 		allocator(const allocator<_Other>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 575  : 		{	// construct from a related allocator (do nothing)
; 576  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *><std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	e8 00 00 00 00	 call	 ??$destroy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>

; 758  : 		}

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??$destroy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAE@?$allocator_traits@V?$allocator@PAE@std@@@std@@SAXAAV?$allocator@PAE@1@PAPAE@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAE@?$allocator_traits@V?$allocator@PAE@std@@@std@@SAXAAV?$allocator@PAE@1@PAPAE@Z PROC ; std::allocator_traits<std::allocator<unsigned char *> >::destroy<unsigned char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	e8 00 00 00 00	 call	 ??$destroy@PAE@?$allocator@PAE@std@@QAEXPAPAE@Z ; std::allocator<unsigned char *>::destroy<unsigned char *>

; 758  : 		}

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??$destroy@PAE@?$allocator_traits@V?$allocator@PAE@std@@@std@@SAXAAV?$allocator@PAE@1@PAPAE@Z ENDP ; std::allocator_traits<std::allocator<unsigned char *> >::destroy<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	e8 00 00 00 00	 call	 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>

; 758  : 		}

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::destroy<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	e8 00 00 00 00	 call	 ??$destroy@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@@Z ; std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >::destroy<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *>

; 758  : 		}

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??$destroy@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::destroy<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	e8 00 00 00 00	 call	 ??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 758  : 		}

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 437  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 438  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 439  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 440  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 401  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 402  : 	_DEBUG_RANGE(_First, _Last);
; 403  : 	_DEBUG_POINTER(_Dest);
; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00007	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000a	c1 f8 02	 sar	 eax, 2
  0000d	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00010	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  00013	c1 e1 02	 shl	 ecx, 2
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001e	50		 push	 eax
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
  00028	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  0002b	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 407  : 	}

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@00AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@@Z PROC ; std::_Val_type<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *>, COMDAT

; 710  : 	{	// return value type from arbitrary argument

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 711  : 	return (0);

  00003	33 c0		 xor	 eax, eax

; 712  : 	}

  00005	5d		 pop	 ebp
  00006	c3		 ret	 0
??$_Val_type@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@@Z ENDP ; std::_Val_type<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninit_def_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IPAV12@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_def_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IPAV12@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_def_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 659  : 	{	// copy _Count * _Valty() to raw _First, using _Al, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 660  : 	_Fill_n(_First, _Count, (_Valty)0);

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0000b	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00016	52		 push	 edx
  00017	e8 00 00 00 00	 call	 ??$_Fill_n@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IPAV12@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@IABQAV10@@Z ; std::_Fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 661  : 	}

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??$_Uninit_def_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IPAV12@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IAAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_def_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >, COMDAT

; 96   : 	{	// destroy [_First, _Last), scalar type (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 97   : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@YAXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z PROC ; std::forward<std::_Container_proxy>, COMDAT

; 1775 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ENDP ; std::forward<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 10	 mov	 eax, DWORD PTR __V0$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
  0000c	83 c4 04	 add	 esp, 4
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00017	e8 00 00 00 00	 call	 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$_Move@AAD@std@@YA$$QADAAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAD@std@@YA$$QADAAD@Z PROC			; std::_Move<char &>, COMDAT

; 1798 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1799 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1800 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAD@std@@YA$$QADAAD@Z ENDP			; std::_Move<char &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBIN@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@1@PAU?$pair@$$CBIN@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U?$pair@$$CBIN@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@1@PAU?$pair@$$CBIN@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::destroy<std::pair<unsigned int const ,double> >, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	e8 00 00 00 00	 call	 ??$destroy@U?$pair@$$CBIN@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBIN@1@@Z ; std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >::destroy<std::pair<unsigned int const ,double> >

; 758  : 		}

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??$destroy@U?$pair@$$CBIN@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@1@PAU?$pair@$$CBIN@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::destroy<std::pair<unsigned int const ,double> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<unsigned int const ,double>,void *> * &>, COMDAT

; 1775 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<unsigned int const ,double>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::construct<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *,std::_Tree_node<std::pair<unsigned int const ,double>,void *> * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 10	 mov	 eax, DWORD PTR __V0$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??$forward@AAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<unsigned int const ,double>,void *> * &>
  0000c	83 c4 04	 add	 esp, 4
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00017	e8 00 00 00 00	 call	 ??$construct@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@AAPAU21@@Z ; std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >::construct<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *,std::_Tree_node<std::pair<unsigned int const ,double>,void *> * &>
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$construct@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> > >::construct<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *,std::_Tree_node<std::pair<unsigned int const ,double>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv74 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct, COMDAT
; _this$ = ecx

; 605  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	50		 push	 eax
  0002c	6a 18		 push	 24			; 00000018H
  0002e	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00033	83 c4 08	 add	 esp, 8
  00036	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	83 7d f0 00	 cmp	 DWORD PTR $T3[ebp], 0
  00044	74 11		 je	 SHORT $LN3@construct
  00046	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  00049	51		 push	 ecx
  0004a	8b 4d f0	 mov	 ecx, DWORD PTR $T3[ebp]
  0004d	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00052	89 45 ec	 mov	 DWORD PTR tv74[ebp], eax
  00055	eb 07		 jmp	 SHORT $LN4@construct
$LN3@construct:
  00057	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct:
  0005e	8b 55 ec	 mov	 edx, DWORD PTR tv74[ebp]
  00061	89 55 e4	 mov	 DWORD PTR $T2[ebp], edx
  00064	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 607  : 		}

  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -2						; size = 1
$T2 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 733  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8d 45 ff	 lea	 eax, DWORD PTR $T2[ebp]
  0000c	50		 push	 eax
  0000d	8d 4d fe	 lea	 ecx, DWORD PTR $T1[ebp]
  00010	51		 push	 ecx
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
  00019	8b c8		 mov	 ecx, eax
  0001b	e8 00 00 00 00	 call	 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
  00020	50		 push	 eax
  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 734  : 		_Tidy();

  00029	6a 00		 push	 0
  0002b	6a 00		 push	 0
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 735  : 		assign(_Right, 0, npos);

  00035	6a ff		 push	 -1
  00037	6a 00		 push	 0
  00039	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  0003c	52		 push	 edx
  0003d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 736  : 		}

  00045	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ PROC ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 806  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 807  : 		return (_Mytraits::select_on_container_copy_construction(*this));

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	50		 push	 eax
  0000d	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
  00016	83 c4 08	 add	 esp, 8
  00019	50		 push	 eax
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001d	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
  00022	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 808  : 		}

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 835  : 		{	// construct by copying base

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@ABV01@@Z ; std::allocator<char>::allocator<char>

; 836  : 		}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 767  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 768  : 		return (_Al.select_on_container_copy_construction());

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	e8 00 00 00 00	 call	 ?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ ; std::allocator<char>::select_on_container_copy_construction
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 769  : 		}

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ PROC ; std::allocator<char>::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 544  : 		{	// return this allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 545  : 		return (*this);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@ABV01@@Z ; std::allocator<char>::allocator<char>
  00013	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 546  : 		}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ ENDP ; std::allocator<char>::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAPAE@?$allocator@PAE@std@@QAEXPAPAPAE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAPAE@?$allocator@PAE@std@@QAEXPAPAPAE@Z PROC ; std::allocator<unsigned char *>::destroy<unsigned char * *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
??$destroy@PAPAE@?$allocator@PAE@std@@QAEXPAPAPAE@Z ENDP ; std::allocator<unsigned char *>::destroy<unsigned char * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
??$destroy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAE@?$allocator@PAE@std@@QAEXPAPAE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAE@?$allocator@PAE@std@@QAEXPAPAE@Z PROC	; std::allocator<unsigned char *>::destroy<unsigned char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
??$destroy@PAE@?$allocator@PAE@std@@QAEXPAPAE@Z ENDP	; std::allocator<unsigned char *>::destroy<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z PROC ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ENDP ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >::destroy<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >::destroy<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();

  00007	6a 00		 push	 0
  00009	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000c	e8 00 00 00 00	 call	 ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z

; 624  : 		}

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
??$destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IPAV12@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@IABQAV10@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill_n@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IPAV12@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@IABQAV10@@Z PROC ; std::_Fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 2677 : 	{	// copy _Val _Count times through [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2678 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00003	eb 12		 jmp	 SHORT $LN3@Fill_n
$LN2@Fill_n:
  00005	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00008	83 e8 01	 sub	 eax, 1
  0000b	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00011	83 c1 04	 add	 ecx, 4
  00014	89 4d 08	 mov	 DWORD PTR __Dest$[ebp], ecx
$LN3@Fill_n:
  00017	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0001b	76 0c		 jbe	 SHORT $LN1@Fill_n

; 2679 : 		*_Dest = _Val;

  0001d	8b 55 08	 mov	 edx, DWORD PTR __Dest$[ebp]
  00020	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00023	8b 08		 mov	 ecx, DWORD PTR [eax]
  00025	89 0a		 mov	 DWORD PTR [edx], ecx
  00027	eb dc		 jmp	 SHORT $LN2@Fill_n
$LN1@Fill_n:

; 2680 : 	return (_Dest);

  00029	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]

; 2681 : 	}

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$_Fill_n@PAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IPAV12@@std@@YAPAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAPAV10@IABQAV10@@Z ENDP ; std::_Fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv74 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z PROC ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	50		 push	 eax
  0002c	6a 08		 push	 8
  0002e	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00033	83 c4 08	 add	 esp, 8
  00036	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	83 7d f0 00	 cmp	 DWORD PTR $T3[ebp], 0
  00044	74 21		 je	 SHORT $LN3@construct
  00046	8b 4d 0c	 mov	 ecx, DWORD PTR __V0$[ebp]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
  0004f	83 c4 04	 add	 esp, 4
  00052	8b 10		 mov	 edx, DWORD PTR [eax]
  00054	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00057	8b 4d f0	 mov	 ecx, DWORD PTR $T3[ebp]
  0005a	89 11		 mov	 DWORD PTR [ecx], edx
  0005c	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0005f	8b 55 f0	 mov	 edx, DWORD PTR $T3[ebp]
  00062	89 55 ec	 mov	 DWORD PTR tv74[ebp], edx
  00065	eb 07		 jmp	 SHORT $LN4@construct
$LN3@construct:
  00067	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@construct:
  0006e	8b 45 ec	 mov	 eax, DWORD PTR tv74[ebp]
  00071	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
  00074	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ENDP ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBIN@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBIN@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@$$CBIN@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBIN@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >::destroy<std::pair<unsigned int const ,double> >, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
??$destroy@U?$pair@$$CBIN@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBIN@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >::destroy<std::pair<unsigned int const ,double> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >::construct<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *,std::_Tree_node<std::pair<unsigned int const ,double>,void *> * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@AAPAU21@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	50		 push	 eax
  0002c	6a 04		 push	 4
  0002e	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00033	83 c4 08	 add	 esp, 8
  00036	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	83 7d f0 00	 cmp	 DWORD PTR $T3[ebp], 0
  00044	74 1b		 je	 SHORT $LN3@construct
  00046	8b 4d 0c	 mov	 ecx, DWORD PTR __V0$[ebp]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ??$forward@AAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<unsigned int const ,double>,void *> * &>
  0004f	83 c4 04	 add	 esp, 4
  00052	8b 55 f0	 mov	 edx, DWORD PTR $T3[ebp]
  00055	8b 00		 mov	 eax, DWORD PTR [eax]
  00057	89 02		 mov	 DWORD PTR [edx], eax
  00059	8b 4d f0	 mov	 ecx, DWORD PTR $T3[ebp]
  0005c	89 4d ec	 mov	 DWORD PTR tv73[ebp], ecx
  0005f	eb 07		 jmp	 SHORT $LN4@construct
$LN3@construct:
  00061	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN4@construct:
  00068	8b 55 ec	 mov	 edx, DWORD PTR tv73[ebp]
  0006b	89 55 e4	 mov	 DWORD PTR $T2[ebp], edx
  0006e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00075	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00078	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007f	59		 pop	 ecx
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@AAPAU21@@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@AAPAU21@@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@AAPAU21@@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@PAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBIN@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBIN@std@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<unsigned int const ,double>,void *> >::construct<std::_Tree_node<std::pair<unsigned int const ,double>,void *> *,std::_Tree_node<std::pair<unsigned int const ,double>,void *> * &>
; Function compile flags: /Odtp
;	COMDAT ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0d		 je	 SHORT $LN1@scalar
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??3@YAXPAX@Z
  00021	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 569  : 	allocator(const allocator<_Ty>&) _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 570  : 		{	// construct by copying (do nothing)
; 571  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 50   : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 51   : 		}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??0_Container_proxy@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Container_proxy@std@@QAE@XZ PROC			; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 67   : 		{	// construct from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 68   : 		}

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0_Container_proxy@std@@QAE@XZ ENDP			; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlchecked.h
;	COMDAT ?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S1max$ = 12						; size = 4
__S2$ = 16						; size = 4
__N$ = 20						; size = 4
?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z PROC		; ATL::Checked::memcpy_s, COMDAT

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 69   : 	ATLMFC_CRT_ERRORCHECK(::memcpy_s(_S1, _S1max, _S2, _N));

  00003	8b 45 14	 mov	 eax, DWORD PTR __N$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 10	 mov	 ecx, DWORD PTR __S2$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 0c	 mov	 edx, DWORD PTR __S1max$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 08	 mov	 eax, DWORD PTR __S1$[ebp]
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memcpy_s
  00019	83 c4 10	 add	 esp, 16			; 00000010H
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?AfxCrtErrorCheck@@YAHH@Z ; AfxCrtErrorCheck
  00022	83 c4 04	 add	 esp, 4

; 70   : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z ENDP		; ATL::Checked::memcpy_s
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlconv.h
;	COMDAT ??$AtlConvAllocMemory@D@ATL@@YAXPAPADHPADH@Z
_TEXT	SEGMENT
___atl_condVal$1 = -28					; size = 4
___atl_condVal$2 = -24					; size = 4
___atl_condVal$3 = -20					; size = 4
_ppReallocBuf$4 = -16					; size = 4
tv77 = -12						; size = 4
tv71 = -8						; size = 4
tv65 = -4						; size = 4
_ppBuff$ = 8						; size = 4
_nLength$ = 12						; size = 4
_pszFixedBuffer$ = 16					; size = 4
_nFixedBufferLength$ = 20				; size = 4
??$AtlConvAllocMemory@D@ATL@@YAXPAPADHPADH@Z PROC	; ATL::AtlConvAllocMemory<char>, COMDAT

; 118  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
$LN29@AtlConvAll:

; 119  : 	ATLENSURE_THROW(ppBuff != NULL, E_INVALIDARG);

  00006	83 7d 08 00	 cmp	 DWORD PTR _ppBuff$[ebp], 0
  0000a	74 09		 je	 SHORT $LN32@AtlConvAll
  0000c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
  00013	eb 07		 jmp	 SHORT $LN33@AtlConvAll
$LN32@AtlConvAll:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv65[ebp], 0
$LN33@AtlConvAll:
  0001c	8b 45 fc	 mov	 eax, DWORD PTR tv65[ebp]
  0001f	89 45 ec	 mov	 DWORD PTR ___atl_condVal$3[ebp], eax
$LN25@AtlConvAll:
  00022	33 c9		 xor	 ecx, ecx
  00024	75 fc		 jne	 SHORT $LN25@AtlConvAll
  00026	83 7d ec 00	 cmp	 DWORD PTR ___atl_condVal$3[ebp], 0
  0002a	75 0a		 jne	 SHORT $LN28@AtlConvAll
  0002c	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00031	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN28@AtlConvAll:
  00036	33 d2		 xor	 edx, edx
  00038	75 cc		 jne	 SHORT $LN29@AtlConvAll
$LN22@AtlConvAll:

; 120  : 	ATLENSURE_THROW(nLength >= 0, E_INVALIDARG);

  0003a	83 7d 0c 00	 cmp	 DWORD PTR _nLength$[ebp], 0
  0003e	7c 09		 jl	 SHORT $LN34@AtlConvAll
  00040	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
  00047	eb 07		 jmp	 SHORT $LN35@AtlConvAll
$LN34@AtlConvAll:
  00049	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN35@AtlConvAll:
  00050	8b 45 f8	 mov	 eax, DWORD PTR tv71[ebp]
  00053	89 45 e8	 mov	 DWORD PTR ___atl_condVal$2[ebp], eax
$LN18@AtlConvAll:
  00056	33 c9		 xor	 ecx, ecx
  00058	75 fc		 jne	 SHORT $LN18@AtlConvAll
  0005a	83 7d e8 00	 cmp	 DWORD PTR ___atl_condVal$2[ebp], 0
  0005e	75 0a		 jne	 SHORT $LN21@AtlConvAll
  00060	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00065	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN21@AtlConvAll:
  0006a	33 d2		 xor	 edx, edx
  0006c	75 cc		 jne	 SHORT $LN22@AtlConvAll
$LN15@AtlConvAll:

; 121  : 	ATLENSURE_THROW(pszFixedBuffer != NULL, E_INVALIDARG);

  0006e	83 7d 10 00	 cmp	 DWORD PTR _pszFixedBuffer$[ebp], 0
  00072	74 09		 je	 SHORT $LN36@AtlConvAll
  00074	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv77[ebp], 1
  0007b	eb 07		 jmp	 SHORT $LN37@AtlConvAll
$LN36@AtlConvAll:
  0007d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
$LN37@AtlConvAll:
  00084	8b 45 f4	 mov	 eax, DWORD PTR tv77[ebp]
  00087	89 45 e4	 mov	 DWORD PTR ___atl_condVal$1[ebp], eax
$LN11@AtlConvAll:
  0008a	33 c9		 xor	 ecx, ecx
  0008c	75 fc		 jne	 SHORT $LN11@AtlConvAll
  0008e	83 7d e4 00	 cmp	 DWORD PTR ___atl_condVal$1[ebp], 0
  00092	75 0a		 jne	 SHORT $LN14@AtlConvAll
  00094	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00099	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN14@AtlConvAll:
  0009e	33 d2		 xor	 edx, edx
  000a0	75 cc		 jne	 SHORT $LN15@AtlConvAll

; 122  : 
; 123  : 	//if buffer malloced, try to realloc.
; 124  : 	if (*ppBuff != pszFixedBuffer)

  000a2	8b 45 08	 mov	 eax, DWORD PTR _ppBuff$[ebp]
  000a5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a7	3b 4d 10	 cmp	 ecx, DWORD PTR _pszFixedBuffer$[ebp]
  000aa	74 53		 je	 SHORT $LN8@AtlConvAll

; 125  : 	{
; 126  : 		if( nLength > nFixedBufferLength )

  000ac	8b 55 0c	 mov	 edx, DWORD PTR _nLength$[ebp]
  000af	3b 55 14	 cmp	 edx, DWORD PTR _nFixedBufferLength$[ebp]
  000b2	7e 32		 jle	 SHORT $LN7@AtlConvAll

; 127  : 		{
; 128  : 			_CharType* ppReallocBuf = static_cast< _CharType* >( _recalloc(*ppBuff, nLength,sizeof( _CharType ) ) );

  000b4	6a 01		 push	 1
  000b6	8b 45 0c	 mov	 eax, DWORD PTR _nLength$[ebp]
  000b9	50		 push	 eax
  000ba	8b 4d 08	 mov	 ecx, DWORD PTR _ppBuff$[ebp]
  000bd	8b 11		 mov	 edx, DWORD PTR [ecx]
  000bf	52		 push	 edx
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___recalloc
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c9	89 45 f0	 mov	 DWORD PTR _ppReallocBuf$4[ebp], eax

; 129  : 			if (ppReallocBuf == NULL) 

  000cc	83 7d f0 00	 cmp	 DWORD PTR _ppReallocBuf$4[ebp], 0
  000d0	75 0a		 jne	 SHORT $LN6@AtlConvAll

; 130  : 			{
; 131  : 				AtlThrow( E_OUTOFMEMORY );

  000d2	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  000d7	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN6@AtlConvAll:

; 132  : 			}
; 133  : 			*ppBuff = ppReallocBuf;

  000dc	8b 45 08	 mov	 eax, DWORD PTR _ppBuff$[ebp]
  000df	8b 4d f0	 mov	 ecx, DWORD PTR _ppReallocBuf$4[ebp]
  000e2	89 08		 mov	 DWORD PTR [eax], ecx

; 134  : 		} else

  000e4	eb 17		 jmp	 SHORT $LN5@AtlConvAll
$LN7@AtlConvAll:

; 135  : 		{
; 136  : 			free(*ppBuff);

  000e6	8b 55 08	 mov	 edx, DWORD PTR _ppBuff$[ebp]
  000e9	8b 02		 mov	 eax, DWORD PTR [edx]
  000eb	50		 push	 eax
  000ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000f2	83 c4 04	 add	 esp, 4

; 137  : 			*ppBuff=pszFixedBuffer;

  000f5	8b 4d 08	 mov	 ecx, DWORD PTR _ppBuff$[ebp]
  000f8	8b 55 10	 mov	 edx, DWORD PTR _pszFixedBuffer$[ebp]
  000fb	89 11		 mov	 DWORD PTR [ecx], edx
$LN5@AtlConvAll:

; 138  : 		}
; 139  : 
; 140  : 	} else //Buffer is not currently malloced.

  000fd	eb 26		 jmp	 SHORT $LN4@AtlConvAll
$LN8@AtlConvAll:

; 141  : 	{
; 142  : 		if( nLength > nFixedBufferLength )

  000ff	8b 45 0c	 mov	 eax, DWORD PTR _nLength$[ebp]
  00102	3b 45 14	 cmp	 eax, DWORD PTR _nFixedBufferLength$[ebp]
  00105	7e 16		 jle	 SHORT $LN3@AtlConvAll

; 143  : 		{
; 144  : 			*ppBuff = static_cast< _CharType* >( calloc(nLength,sizeof( _CharType ) ) );

  00107	6a 01		 push	 1
  00109	8b 4d 0c	 mov	 ecx, DWORD PTR _nLength$[ebp]
  0010c	51		 push	 ecx
  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  00113	83 c4 08	 add	 esp, 8
  00116	8b 55 08	 mov	 edx, DWORD PTR _ppBuff$[ebp]
  00119	89 02		 mov	 DWORD PTR [edx], eax

; 145  : 		} else

  0011b	eb 08		 jmp	 SHORT $LN4@AtlConvAll
$LN3@AtlConvAll:

; 146  : 		{			
; 147  : 			*ppBuff=pszFixedBuffer;

  0011d	8b 45 08	 mov	 eax, DWORD PTR _ppBuff$[ebp]
  00120	8b 4d 10	 mov	 ecx, DWORD PTR _pszFixedBuffer$[ebp]
  00123	89 08		 mov	 DWORD PTR [eax], ecx
$LN4@AtlConvAll:

; 148  : 		}
; 149  : 	}
; 150  : 
; 151  : 	if (*ppBuff == NULL)

  00125	8b 55 08	 mov	 edx, DWORD PTR _ppBuff$[ebp]
  00128	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0012b	75 0a		 jne	 SHORT $LN31@AtlConvAll

; 152  : 	{
; 153  : 		AtlThrow( E_OUTOFMEMORY );

  0012d	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00132	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN31@AtlConvAll:

; 154  : 	}
; 155  : }

  00137	8b e5		 mov	 esp, ebp
  00139	5d		 pop	 ebp
  0013a	c3		 ret	 0
??$AtlConvAllocMemory@D@ATL@@YAXPAPADHPADH@Z ENDP	; ATL::AtlConvAllocMemory<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\afx.h
;	COMDAT ?AfxCrtErrorCheck@@YAHH@Z
_TEXT	SEGMENT
tv64 = -4						; size = 4
_error$ = 8						; size = 4
?AfxCrtErrorCheck@@YAHH@Z PROC				; AfxCrtErrorCheck, COMDAT

; 496  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 497  : 	switch(error)

  00004	8b 45 08	 mov	 eax, DWORD PTR _error$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv64[ebp], eax
  0000a	83 7d fc 50	 cmp	 DWORD PTR tv64[ebp], 80	; 00000050H
  0000e	77 23		 ja	 SHORT $LN1@AfxCrtErro
  00010	8b 4d fc	 mov	 ecx, DWORD PTR tv64[ebp]
  00013	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN9@AfxCrtErro[ecx]
  0001a	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN10@AfxCrtErro[edx*4]
$LN4@AfxCrtErro:

; 498  : 	{
; 499  : 	case ENOMEM:
; 500  : 		AfxThrowMemoryException();

  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?AfxThrowMemoryException@@YGXXZ

; 501  : 		break;

  00027	eb 10		 jmp	 SHORT $LN5@AfxCrtErro
$LN3@AfxCrtErro:

; 502  : 	case EINVAL:
; 503  : 	case ERANGE:
; 504  : 		AfxThrowInvalidArgException();

  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?AfxThrowInvalidArgException@@YGXXZ

; 505  : 		break;

  0002f	eb 08		 jmp	 SHORT $LN5@AfxCrtErro
$LN2@AfxCrtErro:

; 506  : 	case STRUNCATE:
; 507  : 	case 0:
; 508  : 		break;

  00031	eb 06		 jmp	 SHORT $LN5@AfxCrtErro
$LN1@AfxCrtErro:

; 509  : 	default:
; 510  : 		AfxThrowInvalidArgException();

  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?AfxThrowInvalidArgException@@YGXXZ
$LN5@AfxCrtErro:

; 511  : 		break;
; 512  : 	}
; 513  : 	return error;

  00039	8b 45 08	 mov	 eax, DWORD PTR _error$[ebp]
$LN8@AfxCrtErro:

; 514  : }

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
$LN10@AfxCrtErro:
  00040	00 00 00 00	 DD	 $LN2@AfxCrtErro
  00044	00 00 00 00	 DD	 $LN4@AfxCrtErro
  00048	00 00 00 00	 DD	 $LN3@AfxCrtErro
  0004c	00 00 00 00	 DD	 $LN1@AfxCrtErro
$LN9@AfxCrtErro:
  00050	00		 DB	 0
  00051	03		 DB	 3
  00052	03		 DB	 3
  00053	03		 DB	 3
  00054	03		 DB	 3
  00055	03		 DB	 3
  00056	03		 DB	 3
  00057	03		 DB	 3
  00058	03		 DB	 3
  00059	03		 DB	 3
  0005a	03		 DB	 3
  0005b	03		 DB	 3
  0005c	01		 DB	 1
  0005d	03		 DB	 3
  0005e	03		 DB	 3
  0005f	03		 DB	 3
  00060	03		 DB	 3
  00061	03		 DB	 3
  00062	03		 DB	 3
  00063	03		 DB	 3
  00064	03		 DB	 3
  00065	03		 DB	 3
  00066	02		 DB	 2
  00067	03		 DB	 3
  00068	03		 DB	 3
  00069	03		 DB	 3
  0006a	03		 DB	 3
  0006b	03		 DB	 3
  0006c	03		 DB	 3
  0006d	03		 DB	 3
  0006e	03		 DB	 3
  0006f	03		 DB	 3
  00070	03		 DB	 3
  00071	03		 DB	 3
  00072	02		 DB	 2
  00073	03		 DB	 3
  00074	03		 DB	 3
  00075	03		 DB	 3
  00076	03		 DB	 3
  00077	03		 DB	 3
  00078	03		 DB	 3
  00079	03		 DB	 3
  0007a	03		 DB	 3
  0007b	03		 DB	 3
  0007c	03		 DB	 3
  0007d	03		 DB	 3
  0007e	03		 DB	 3
  0007f	03		 DB	 3
  00080	03		 DB	 3
  00081	03		 DB	 3
  00082	03		 DB	 3
  00083	03		 DB	 3
  00084	03		 DB	 3
  00085	03		 DB	 3
  00086	03		 DB	 3
  00087	03		 DB	 3
  00088	03		 DB	 3
  00089	03		 DB	 3
  0008a	03		 DB	 3
  0008b	03		 DB	 3
  0008c	03		 DB	 3
  0008d	03		 DB	 3
  0008e	03		 DB	 3
  0008f	03		 DB	 3
  00090	03		 DB	 3
  00091	03		 DB	 3
  00092	03		 DB	 3
  00093	03		 DB	 3
  00094	03		 DB	 3
  00095	03		 DB	 3
  00096	03		 DB	 3
  00097	03		 DB	 3
  00098	03		 DB	 3
  00099	03		 DB	 3
  0009a	03		 DB	 3
  0009b	03		 DB	 3
  0009c	03		 DB	 3
  0009d	03		 DB	 3
  0009e	03		 DB	 3
  0009f	03		 DB	 3
  000a0	00		 DB	 0
?AfxCrtErrorCheck@@YAHH@Z ENDP				; AfxCrtErrorCheck
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlconv.h
;	COMDAT ??$AtlConvFreeMemory@D@ATL@@YAXPAD0H@Z
_TEXT	SEGMENT
_pBuff$ = 8						; size = 4
_pszFixedBuffer$ = 12					; size = 4
_nFixedBufferLength$ = 16				; size = 4
??$AtlConvFreeMemory@D@ATL@@YAXPAD0H@Z PROC		; ATL::AtlConvFreeMemory<char>, COMDAT

; 162  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 163  : 	(nFixedBufferLength);
; 164  : 	if( pBuff != pszFixedBuffer )

  00003	8b 45 08	 mov	 eax, DWORD PTR _pBuff$[ebp]
  00006	3b 45 0c	 cmp	 eax, DWORD PTR _pszFixedBuffer$[ebp]
  00009	74 0d		 je	 SHORT $LN2@AtlConvFre

; 165  : 	{
; 166  : 		free( pBuff );

  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _pBuff$[ebp]
  0000e	51		 push	 ecx
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00015	83 c4 04	 add	 esp, 4
$LN2@AtlConvFre:

; 167  : 	} 	
; 168  : #ifdef _DEBUG
; 169  : 	else
; 170  : 	{		
; 171  : 		memset(pszFixedBuffer,ATLCONV_DEADLAND_FILL,nFixedBufferLength*sizeof(_CharType));
; 172  : 	}
; 173  : #endif
; 174  : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$AtlConvFreeMemory@D@ATL@@YAXPAD0H@Z ENDP		; ATL::AtlConvFreeMemory<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrowImpl@ATL@@YGXJ@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
?AtlThrowImpl@ATL@@YGXJ@Z PROC				; ATL::AtlThrowImpl, COMDAT

; 65   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 66   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 67   : #ifdef _AFX
; 68   : 	if( hr == E_OUTOFMEMORY )

  00003	81 7d 08 0e 00
	07 80		 cmp	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
  0000a	75 08		 jne	 SHORT $LN2@AtlThrowIm

; 69   : 	{
; 70   : 		AfxThrowMemoryException();

  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?AfxThrowMemoryException@@YGXXZ

; 71   : 	}
; 72   : 	else

  00012	eb 0a		 jmp	 SHORT $LN4@AtlThrowIm
$LN2@AtlThrowIm:

; 73   : 	{
; 74   : 		AfxThrowOleException( hr );

  00014	8b 45 08	 mov	 eax, DWORD PTR _hr$[ebp]
  00017	50		 push	 eax
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?AfxThrowOleException@@YGXJ@Z
$LN4@AtlThrowIm:

; 75   : 	}
; 76   : #else
; 77   : 	throw CAtlException( hr );
; 78   : #endif
; 79   : };

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?AtlThrowImpl@ATL@@YGXJ@Z ENDP				; ATL::AtlThrowImpl
_TEXT	ENDS
END
