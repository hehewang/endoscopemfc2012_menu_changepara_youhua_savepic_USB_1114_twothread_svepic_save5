; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

	TITLE	E:\work_wm\HXIJY_code\endoscopemfc2012_menu_changepara_youhua_savepic_USB_1114_twothread_svepic_save5\src\EndoScopeMFC\packQueue.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

__have_init_pack DD 01H DUP (?)
_BSS	ENDS
_current_pack_lock DD 0ffffffffH
	ORG $+2
$SG4294952330 DB 'pack lock', 00H
PUBLIC	?InitPackQueue@@YAXXZ				; InitPackQueue
PUBLIC	?ReadPackQueue@@YAHPAEPAH@Z			; ReadPackQueue
PUBLIC	?WritePackQueue@@YAXPAEH@Z			; WritePackQueue
_packQueue DB	0546014H DUP (?)
_BSS	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\packqueue.cpp
;	COMDAT ?WritePackQueue@@YAXPAEH@Z
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_length$ = 12						; size = 4
?WritePackQueue@@YAXPAEH@Z PROC				; WritePackQueue, COMDAT

; 50   : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 51   : 	if(_have_init_pack == 0){

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR __have_init_pack, 0
  0000a	75 0f		 jne	 SHORT $LN5@WritePackQ

; 52   : 		_have_init_pack = 1;

  0000c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR __have_init_pack, 1

; 53   : 		InitPackQueue();

  00016	e8 00 00 00 00	 call	 ?InitPackQueue@@YAXXZ	; InitPackQueue
$LN5@WritePackQ:

; 54   : 	}
; 55   : 	if(current_pack_lock) WaitForSingleObject(current_pack_lock, INFINITE);

  0001b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _current_pack_lock, 0
  00022	74 0e		 je	 SHORT $LN4@WritePackQ
  00024	6a ff		 push	 -1
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR _current_pack_lock
  0002b	50		 push	 eax
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
$LN4@WritePackQ:

; 56   : 	packQueue.num++;

  00032	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _packQueue+8
  00038	83 c1 01	 add	 ecx, 1
  0003b	89 0d 08 00 00
	00		 mov	 DWORD PTR _packQueue+8, ecx

; 57   : 	if(packQueue.num>SEND_BUF_MAX_NUM)

  00041	83 3d 08 00 00
	00 02		 cmp	 DWORD PTR _packQueue+8, 2
  00048	7e 1e		 jle	 SHORT $LN3@WritePackQ

; 58   : 	{
; 59   : 		TRACE("fifo is full*******************************8!\n");
; 60   : 		
; 61   : 		packQueue.font = 0;

  0004a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _packQueue, 0

; 62   : 		packQueue.rear = 0;

  00054	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _packQueue+4, 0

; 63   : 		packQueue.num = 1;

  0005e	c7 05 08 00 00
	00 01 00 00 00	 mov	 DWORD PTR _packQueue+8, 1
$LN3@WritePackQ:

; 64   : 		
; 65   : 	}
; 66   : 	packQueue.len[packQueue.rear]=length;

  00068	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _packQueue+4
  0006e	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  00071	89 04 95 0c 00
	00 00		 mov	 DWORD PTR _packQueue[edx*4+12], eax

; 67   : 	memcpy(packQueue.packQueBuf[packQueue.rear],buffer,length);

  00078	8b 4d 0c	 mov	 ecx, DWORD PTR _length$[ebp]
  0007b	51		 push	 ecx
  0007c	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  0007f	52		 push	 edx
  00080	a1 04 00 00 00	 mov	 eax, DWORD PTR _packQueue+4
  00085	69 c0 00 30 2a
	00		 imul	 eax, 2764800		; 002a3000H
  0008b	05 14 00 00 00	 add	 eax, OFFSET _packQueue+20
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 _memcpy
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH

; 68   : 	packQueue.rear++;

  00099	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _packQueue+4
  0009f	83 c1 01	 add	 ecx, 1
  000a2	89 0d 04 00 00
	00		 mov	 DWORD PTR _packQueue+4, ecx

; 69   : 	if(packQueue.rear>=SEND_BUF_MAX_NUM)

  000a8	83 3d 04 00 00
	00 02		 cmp	 DWORD PTR _packQueue+4, 2
  000af	7c 0a		 jl	 SHORT $LN2@WritePackQ

; 70   : 	{
; 71   : 		packQueue.rear=0;

  000b1	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _packQueue+4, 0
$LN2@WritePackQ:

; 72   : 	}
; 73   : 	if(current_pack_lock) ReleaseMutex(current_pack_lock);

  000bb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _current_pack_lock, 0
  000c2	74 0d		 je	 SHORT $LN6@WritePackQ
  000c4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _current_pack_lock
  000ca	52		 push	 edx
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4
$LN6@WritePackQ:

; 74   : }

  000d1	5d		 pop	 ebp
  000d2	c3		 ret	 0
?WritePackQueue@@YAXPAEH@Z ENDP				; WritePackQueue
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\packqueue.cpp
;	COMDAT ?ReadPackQueue@@YAHPAEPAH@Z
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_length$ = 12						; size = 4
?ReadPackQueue@@YAHPAEPAH@Z PROC			; ReadPackQueue, COMDAT

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 78   : 	if(_have_init_pack == 0){

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR __have_init_pack, 0
  0000a	75 0f		 jne	 SHORT $LN6@ReadPackQu

; 79   : 		_have_init_pack = 1;

  0000c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR __have_init_pack, 1

; 80   : 		InitPackQueue();

  00016	e8 00 00 00 00	 call	 ?InitPackQueue@@YAXXZ	; InitPackQueue
$LN6@ReadPackQu:

; 81   : 	}
; 82   : 	*length = 0;

  0001b	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 83   : 	if(current_pack_lock) WaitForSingleObject(current_pack_lock, INFINITE);

  00024	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _current_pack_lock, 0
  0002b	74 0f		 je	 SHORT $LN5@ReadPackQu
  0002d	6a ff		 push	 -1
  0002f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _current_pack_lock
  00035	51		 push	 ecx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
$LN5@ReadPackQu:

; 84   : 	if(packQueue.num<=0){

  0003c	83 3d 08 00 00
	00 00		 cmp	 DWORD PTR _packQueue+8, 0
  00043	7f 1b		 jg	 SHORT $LN4@ReadPackQu

; 85   : 		if(current_pack_lock) ReleaseMutex(current_pack_lock);

  00045	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _current_pack_lock, 0
  0004c	74 0d		 je	 SHORT $LN3@ReadPackQu
  0004e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _current_pack_lock
  00054	52		 push	 edx
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4
$LN3@ReadPackQu:

; 86   : 		return -1;

  0005b	83 c8 ff	 or	 eax, -1
  0005e	eb 7f		 jmp	 SHORT $LN7@ReadPackQu
$LN4@ReadPackQu:

; 87   : 	}
; 88   : 
; 89   : 	*length=packQueue.len[packQueue.font];

  00060	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  00063	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _packQueue
  00069	8b 14 8d 0c 00
	00 00		 mov	 edx, DWORD PTR _packQueue[ecx*4+12]
  00070	89 10		 mov	 DWORD PTR [eax], edx

; 90   : 	memcpy(buffer,packQueue.packQueBuf[packQueue.font],*length);

  00072	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  00075	8b 08		 mov	 ecx, DWORD PTR [eax]
  00077	51		 push	 ecx
  00078	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _packQueue
  0007e	69 d2 00 30 2a
	00		 imul	 edx, 2764800		; 002a3000H
  00084	81 c2 14 00 00
	00		 add	 edx, OFFSET _packQueue+20
  0008a	52		 push	 edx
  0008b	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 _memcpy
  00094	83 c4 0c	 add	 esp, 12			; 0000000cH

; 91   : 
; 92   : 	packQueue.font++;	

  00097	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _packQueue
  0009d	83 c1 01	 add	 ecx, 1
  000a0	89 0d 00 00 00
	00		 mov	 DWORD PTR _packQueue, ecx

; 93   : 	if(packQueue.font>=SEND_BUF_MAX_NUM)

  000a6	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR _packQueue, 2
  000ad	7c 0a		 jl	 SHORT $LN2@ReadPackQu

; 94   : 	{
; 95   : 		packQueue.font = 0;

  000af	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _packQueue, 0
$LN2@ReadPackQu:

; 96   : 	}
; 97   : 	packQueue.num--;

  000b9	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _packQueue+8
  000bf	83 ea 01	 sub	 edx, 1
  000c2	89 15 08 00 00
	00		 mov	 DWORD PTR _packQueue+8, edx

; 98   : 	if(current_pack_lock) ReleaseMutex(current_pack_lock);

  000c8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _current_pack_lock, 0
  000cf	74 0c		 je	 SHORT $LN1@ReadPackQu
  000d1	a1 00 00 00 00	 mov	 eax, DWORD PTR _current_pack_lock
  000d6	50		 push	 eax
  000d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4
$LN1@ReadPackQu:

; 99   : 	return 0;

  000dd	33 c0		 xor	 eax, eax
$LN7@ReadPackQu:

; 100  : }

  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
?ReadPackQueue@@YAHPAEPAH@Z ENDP			; ReadPackQueue
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\packqueue.cpp
;	COMDAT ?InitPackQueue@@YAXXZ
_TEXT	SEGMENT
_dwRet$ = -4						; size = 4
?InitPackQueue@@YAXXZ PROC				; InitPackQueue, COMDAT

; 32   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 33   : 	//printf("init queque!*************************************\n");
; 34   : 	current_pack_lock = CreateMutex(NULL, FALSE, "pack lock");

  00004	68 00 00 00 00	 push	 OFFSET $SG4294952330
  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateMutexA@12
  00013	a3 00 00 00 00	 mov	 DWORD PTR _current_pack_lock, eax

; 35   : 	DWORD dwRet = GetLastError();

  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0001e	89 45 fc	 mov	 DWORD PTR _dwRet$[ebp], eax

; 36   : 	if(current_pack_lock){

  00021	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _current_pack_lock, 0
  00028	74 1f		 je	 SHORT $LN2@InitPackQu

; 37   : 		if (ERROR_ALREADY_EXISTS == dwRet){

  0002a	81 7d fc b7 00
	00 00		 cmp	 DWORD PTR _dwRet$[ebp], 183 ; 000000b7H
  00031	75 16		 jne	 SHORT $LN2@InitPackQu

; 38   : 			CloseHandle(current_pack_lock);

  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR _current_pack_lock
  00038	50		 push	 eax
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 39   : 			current_pack_lock = 0 ;

  0003f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _current_pack_lock, 0
$LN2@InitPackQu:

; 40   : 		}
; 41   : 	}
; 42   : 	packQueue.font = 0;

  00049	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _packQueue, 0

; 43   : 	packQueue.rear = 0;

  00053	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _packQueue+4, 0

; 44   : 	packQueue.num = 0;

  0005d	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR _packQueue+8, 0

; 45   : 	_have_init_pack = 1;

  00067	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR __have_init_pack, 1

; 46   : }

  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?InitPackQueue@@YAXXZ ENDP				; InitPackQueue
_TEXT	ENDS
END
