; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

	TITLE	E:\work_wm\HXIJY_code\endoscopemfc2012_menu_changepara_youhua_savepic_USB_1114_twothread_svepic_save5\src\EndoScopeMFC\frameQueue.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	__imp__CreateMutexA@12:PROC
	ALIGN	4

__have_init_fifo DD 01H DUP (?)
_queueLock DD	03H DUP (?)
_BSS	ENDS
	ORG $+3
$SG4294953303 DB 'frame lock', 00H
PUBLIC	?InitQueue@@YAXXZ				; InitQueue
PUBLIC	?WriteQueue@@YAXPAEH@Z				; WriteQueue
PUBLIC	?ReadQueue@@YAHPAEPAH@Z				; ReadQueue
PUBLIC	?resetQueue@@YAXXZ				; resetQueue
_dataQueue DB	07e9040H DUP (?)
_BSS	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\framequeue.cpp
;	COMDAT ?resetQueue@@YAXXZ
_TEXT	SEGMENT
_i$ = -4						; size = 4
?resetQueue@@YAXXZ PROC					; resetQueue, COMDAT

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 73   : 	int i=0;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 74   : 	for(i=0;i<MAX_CHANNEL_NUM;i++)

  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00012	eb 09		 jmp	 SHORT $LN3@resetQueue
$LN2@resetQueue:
  00014	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00017	83 c0 01	 add	 eax, 1
  0001a	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN3@resetQueue:
  0001d	83 7d fc 03	 cmp	 DWORD PTR _i$[ebp], 3
  00021	7d 3b		 jge	 SHORT $LN4@resetQueue

; 75   : 	{
; 76   : 		dataQueue.channelQueue[i].font = 0;

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00026	69 c9 14 30 2a
	00		 imul	 ecx, 2764820		; 002a3014H
  0002c	c7 81 00 30 2a
	00 00 00 00 00	 mov	 DWORD PTR _dataQueue[ecx+2764800], 0

; 77   : 		dataQueue.channelQueue[i].rear = 0;

  00036	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00039	69 d2 14 30 2a
	00		 imul	 edx, 2764820		; 002a3014H
  0003f	c7 82 04 30 2a
	00 00 00 00 00	 mov	 DWORD PTR _dataQueue[edx+2764804], 0

; 78   : 		dataQueue.channelQueue[i].num = 0;

  00049	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0004c	69 c0 14 30 2a
	00		 imul	 eax, 2764820		; 002a3014H
  00052	c7 80 08 30 2a
	00 00 00 00 00	 mov	 DWORD PTR _dataQueue[eax+2764808], 0

; 79   : 	}

  0005c	eb b6		 jmp	 SHORT $LN2@resetQueue
$LN4@resetQueue:

; 80   : }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
?resetQueue@@YAXXZ ENDP					; resetQueue
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\framequeue.cpp
;	COMDAT ?ReadQueue@@YAHPAEPAH@Z
_TEXT	SEGMENT
_i$ = -4						; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 4
?ReadQueue@@YAHPAEPAH@Z PROC				; ReadQueue, COMDAT

; 117  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 118  : 	if(!_have_init_fifo)InitQueue();

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR __have_init_fifo, 0
  0000b	75 05		 jne	 SHORT $LN3@ReadQueue
  0000d	e8 00 00 00 00	 call	 ?InitQueue@@YAXXZ	; InitQueue
$LN3@ReadQueue:

; 119  : 	int i = 0;

  00012	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 120  : #if defined(__WIN32__) || defined(_WIN32)
; 121  : 	WaitForSingleObject(queueLock[i], INFINITE);

  00019	6a ff		 push	 -1
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001e	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _queueLock[eax*4]
  00025	51		 push	 ecx
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 122  : #else
; 123  : 	pthread_mutex_lock(&queueLock[i]);
; 124  : #endif
; 125  : 	if(dataQueue.channelQueue[i].num<=0){

  0002c	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0002f	69 d2 14 30 2a
	00		 imul	 edx, 2764820		; 002a3014H
  00035	83 ba 08 30 2a
	00 00		 cmp	 DWORD PTR _dataQueue[edx+2764808], 0
  0003c	7f 19		 jg	 SHORT $LN2@ReadQueue

; 126  : #if defined(__WIN32__) || defined(_WIN32)
; 127  : 		ReleaseMutex(queueLock[i]);

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00041	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _queueLock[eax*4]
  00048	51		 push	 ecx
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 128  : #else
; 129  : 		pthread_mutex_unlock(&queueLock[i]);
; 130  : #endif
; 131  : 		return -1;

  0004f	83 c8 ff	 or	 eax, -1
  00052	e9 d6 00 00 00	 jmp	 $LN4@ReadQueue
$LN2@ReadQueue:

; 132  : 	}
; 133  : 	*length=dataQueue.channelQueue[i].len[dataQueue.channelQueue[i].font];

  00057	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0005a	69 d2 14 30 2a
	00		 imul	 edx, 2764820		; 002a3014H
  00060	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00063	69 c0 14 30 2a
	00		 imul	 eax, 2764820		; 002a3014H
  00069	8b 88 00 30 2a
	00		 mov	 ecx, DWORD PTR _dataQueue[eax+2764800]
  0006f	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  00072	8b 8c 8a 10 30
	2a 00		 mov	 ecx, DWORD PTR _dataQueue[edx+ecx*4+2764816]
  00079	89 08		 mov	 DWORD PTR [eax], ecx

; 134  : 	memcpy(buffer,dataQueue.channelQueue[i].queueBuf[dataQueue.channelQueue[i].font],*length);

  0007b	8b 55 0c	 mov	 edx, DWORD PTR _length$[ebp]
  0007e	8b 02		 mov	 eax, DWORD PTR [edx]
  00080	50		 push	 eax
  00081	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00084	69 c9 14 30 2a
	00		 imul	 ecx, 2764820		; 002a3014H
  0008a	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0008d	69 d2 14 30 2a
	00		 imul	 edx, 2764820		; 002a3014H
  00093	8b 82 00 30 2a
	00		 mov	 eax, DWORD PTR _dataQueue[edx+2764800]
  00099	69 c0 00 30 2a
	00		 imul	 eax, 2764800		; 002a3000H
  0009f	8d 8c 01 00 00
	00 00		 lea	 ecx, DWORD PTR _dataQueue[ecx+eax]
  000a6	51		 push	 ecx
  000a7	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 _memcpy
  000b0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 135  : 	dataQueue.channelQueue[i].font++;	

  000b3	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000b6	69 c0 14 30 2a
	00		 imul	 eax, 2764820		; 002a3014H
  000bc	8b 88 00 30 2a
	00		 mov	 ecx, DWORD PTR _dataQueue[eax+2764800]
  000c2	83 c1 01	 add	 ecx, 1
  000c5	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000c8	69 d2 14 30 2a
	00		 imul	 edx, 2764820		; 002a3014H
  000ce	89 8a 00 30 2a
	00		 mov	 DWORD PTR _dataQueue[edx+2764800], ecx

; 136  : 	if(dataQueue.channelQueue[i].font>=MAX_BUF_NUM)

  000d4	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000d7	69 c0 14 30 2a
	00		 imul	 eax, 2764820		; 002a3014H
  000dd	83 b8 00 30 2a
	00 01		 cmp	 DWORD PTR _dataQueue[eax+2764800], 1
  000e4	7c 13		 jl	 SHORT $LN1@ReadQueue

; 137  : 	{
; 138  : 		dataQueue.channelQueue[i].font = 0;

  000e6	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000e9	69 c9 14 30 2a
	00		 imul	 ecx, 2764820		; 002a3014H
  000ef	c7 81 00 30 2a
	00 00 00 00 00	 mov	 DWORD PTR _dataQueue[ecx+2764800], 0
$LN1@ReadQueue:

; 139  : 	}
; 140  : 	dataQueue.channelQueue[i].num--;

  000f9	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000fc	69 d2 14 30 2a
	00		 imul	 edx, 2764820		; 002a3014H
  00102	8b 82 08 30 2a
	00		 mov	 eax, DWORD PTR _dataQueue[edx+2764808]
  00108	83 e8 01	 sub	 eax, 1
  0010b	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0010e	69 c9 14 30 2a
	00		 imul	 ecx, 2764820		; 002a3014H
  00114	89 81 08 30 2a
	00		 mov	 DWORD PTR _dataQueue[ecx+2764808], eax

; 141  : #if defined(__WIN32__) || defined(_WIN32)
; 142  : 	ReleaseMutex(queueLock[i]);

  0011a	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0011d	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _queueLock[edx*4]
  00124	50		 push	 eax
  00125	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 143  : #else
; 144  : 	pthread_mutex_unlock(&queueLock[i]);
; 145  : #endif
; 146  : 	return 0;

  0012b	33 c0		 xor	 eax, eax
$LN4@ReadQueue:

; 147  : }

  0012d	8b e5		 mov	 esp, ebp
  0012f	5d		 pop	 ebp
  00130	c3		 ret	 0
?ReadQueue@@YAHPAEPAH@Z ENDP				; ReadQueue
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\framequeue.cpp
;	COMDAT ?WriteQueue@@YAXPAEH@Z
_TEXT	SEGMENT
_i$ = -4						; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 4
?WriteQueue@@YAXPAEH@Z PROC				; WriteQueue, COMDAT

; 83   : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 84   : 	if(!_have_init_fifo)InitQueue();

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR __have_init_fifo, 0
  0000b	75 05		 jne	 SHORT $LN4@WriteQueue
  0000d	e8 00 00 00 00	 call	 ?InitQueue@@YAXXZ	; InitQueue
$LN4@WriteQueue:

; 85   : 	int i =0;

  00012	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 86   : 	if(length>MAX_BUF_LEN)length=MAX_BUF_LEN;

  00019	81 7d 0c 00 30
	2a 00		 cmp	 DWORD PTR _length$[ebp], 2764800 ; 002a3000H
  00020	7e 07		 jle	 SHORT $LN3@WriteQueue
  00022	c7 45 0c 00 30
	2a 00		 mov	 DWORD PTR _length$[ebp], 2764800 ; 002a3000H
$LN3@WriteQueue:

; 87   : #if defined(__WIN32__) || defined(_WIN32)
; 88   : 	WaitForSingleObject(queueLock[i], INFINITE);

  00029	6a ff		 push	 -1
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0002e	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _queueLock[eax*4]
  00035	51		 push	 ecx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 89   : #else
; 90   : 	pthread_mutex_lock(&queueLock[i]);
; 91   : #endif
; 92   : 	dataQueue.channelQueue[i].num++;

  0003c	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0003f	69 d2 14 30 2a
	00		 imul	 edx, 2764820		; 002a3014H
  00045	8b 82 08 30 2a
	00		 mov	 eax, DWORD PTR _dataQueue[edx+2764808]
  0004b	83 c0 01	 add	 eax, 1
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00051	69 c9 14 30 2a
	00		 imul	 ecx, 2764820		; 002a3014H
  00057	89 81 08 30 2a
	00		 mov	 DWORD PTR _dataQueue[ecx+2764808], eax

; 93   : 	if(dataQueue.channelQueue[i].num>MAX_BUF_NUM)

  0005d	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00060	69 d2 14 30 2a
	00		 imul	 edx, 2764820		; 002a3014H
  00066	83 ba 08 30 2a
	00 01		 cmp	 DWORD PTR _dataQueue[edx+2764808], 1
  0006d	7e 39		 jle	 SHORT $LN2@WriteQueue

; 94   : 	{
; 95   : 		TRACE("***** write queue is full!****\n");
; 96   : 		dataQueue.channelQueue[i].font = 0;

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00072	69 c0 14 30 2a
	00		 imul	 eax, 2764820		; 002a3014H
  00078	c7 80 00 30 2a
	00 00 00 00 00	 mov	 DWORD PTR _dataQueue[eax+2764800], 0

; 97   : 		dataQueue.channelQueue[i].rear = 0;

  00082	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00085	69 c9 14 30 2a
	00		 imul	 ecx, 2764820		; 002a3014H
  0008b	c7 81 04 30 2a
	00 00 00 00 00	 mov	 DWORD PTR _dataQueue[ecx+2764804], 0

; 98   : 		dataQueue.channelQueue[i].num = 1;

  00095	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00098	69 d2 14 30 2a
	00		 imul	 edx, 2764820		; 002a3014H
  0009e	c7 82 08 30 2a
	00 01 00 00 00	 mov	 DWORD PTR _dataQueue[edx+2764808], 1
$LN2@WriteQueue:

; 99   : 	}
; 100  : 	dataQueue.channelQueue[i].len[dataQueue.channelQueue[i].rear]=length;

  000a8	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000ab	69 c0 14 30 2a
	00		 imul	 eax, 2764820		; 002a3014H
  000b1	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000b4	69 c9 14 30 2a
	00		 imul	 ecx, 2764820		; 002a3014H
  000ba	8b 91 04 30 2a
	00		 mov	 edx, DWORD PTR _dataQueue[ecx+2764804]
  000c0	8b 4d 0c	 mov	 ecx, DWORD PTR _length$[ebp]
  000c3	89 8c 90 10 30
	2a 00		 mov	 DWORD PTR _dataQueue[eax+edx*4+2764816], ecx

; 101  : 	memset(dataQueue.channelQueue[i].queueBuf[dataQueue.channelQueue[i].rear],0,MAX_BUF_LEN);

  000ca	68 00 30 2a 00	 push	 2764800			; 002a3000H
  000cf	6a 00		 push	 0
  000d1	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000d4	69 d2 14 30 2a
	00		 imul	 edx, 2764820		; 002a3014H
  000da	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000dd	69 c0 14 30 2a
	00		 imul	 eax, 2764820		; 002a3014H
  000e3	8b 88 04 30 2a
	00		 mov	 ecx, DWORD PTR _dataQueue[eax+2764804]
  000e9	69 c9 00 30 2a
	00		 imul	 ecx, 2764800		; 002a3000H
  000ef	8d 94 0a 00 00
	00 00		 lea	 edx, DWORD PTR _dataQueue[edx+ecx]
  000f6	52		 push	 edx
  000f7	e8 00 00 00 00	 call	 _memset
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 102  : 	memcpy(dataQueue.channelQueue[i].queueBuf[dataQueue.channelQueue[i].rear],buffer,length);

  000ff	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  00102	50		 push	 eax
  00103	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00106	51		 push	 ecx
  00107	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0010a	69 d2 14 30 2a
	00		 imul	 edx, 2764820		; 002a3014H
  00110	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00113	69 c0 14 30 2a
	00		 imul	 eax, 2764820		; 002a3014H
  00119	8b 88 04 30 2a
	00		 mov	 ecx, DWORD PTR _dataQueue[eax+2764804]
  0011f	69 c9 00 30 2a
	00		 imul	 ecx, 2764800		; 002a3000H
  00125	8d 94 0a 00 00
	00 00		 lea	 edx, DWORD PTR _dataQueue[edx+ecx]
  0012c	52		 push	 edx
  0012d	e8 00 00 00 00	 call	 _memcpy
  00132	83 c4 0c	 add	 esp, 12			; 0000000cH

; 103  : 	dataQueue.channelQueue[i].rear++;

  00135	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00138	69 c0 14 30 2a
	00		 imul	 eax, 2764820		; 002a3014H
  0013e	8b 88 04 30 2a
	00		 mov	 ecx, DWORD PTR _dataQueue[eax+2764804]
  00144	83 c1 01	 add	 ecx, 1
  00147	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0014a	69 d2 14 30 2a
	00		 imul	 edx, 2764820		; 002a3014H
  00150	89 8a 04 30 2a
	00		 mov	 DWORD PTR _dataQueue[edx+2764804], ecx

; 104  : 
; 105  : 	if(dataQueue.channelQueue[i].rear>=MAX_BUF_NUM)

  00156	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00159	69 c0 14 30 2a
	00		 imul	 eax, 2764820		; 002a3014H
  0015f	83 b8 04 30 2a
	00 01		 cmp	 DWORD PTR _dataQueue[eax+2764804], 1
  00166	7c 13		 jl	 SHORT $LN1@WriteQueue

; 106  : 	{
; 107  : 		dataQueue.channelQueue[i].rear=0;

  00168	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0016b	69 c9 14 30 2a
	00		 imul	 ecx, 2764820		; 002a3014H
  00171	c7 81 04 30 2a
	00 00 00 00 00	 mov	 DWORD PTR _dataQueue[ecx+2764804], 0
$LN1@WriteQueue:

; 108  : 	}
; 109  : #if defined(__WIN32__) || defined(_WIN32)
; 110  : 	ReleaseMutex(queueLock[i]);

  0017b	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0017e	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _queueLock[edx*4]
  00185	50		 push	 eax
  00186	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 111  : #else
; 112  : 	pthread_mutex_unlock(&queueLock[i]);
; 113  : #endif
; 114  : }

  0018c	8b e5		 mov	 esp, ebp
  0018e	5d		 pop	 ebp
  0018f	c3		 ret	 0
?WriteQueue@@YAXPAEH@Z ENDP				; WriteQueue
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\framequeue.cpp
;	COMDAT ?InitQueue@@YAXXZ
_TEXT	SEGMENT
_i$ = -4						; size = 4
?InitQueue@@YAXXZ PROC					; InitQueue, COMDAT

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 51   : 	int i=0;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 52   : 	if (_have_init_fifo>0)return;

  0000b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR __have_init_fifo, 0
  00012	7e 02		 jle	 SHORT $LN5@InitQueue
  00014	eb 7e		 jmp	 SHORT $LN6@InitQueue
$LN5@InitQueue:

; 53   : 	for(i=0;i<MAX_CHANNEL_NUM;i++)

  00016	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0001d	eb 09		 jmp	 SHORT $LN4@InitQueue
$LN3@InitQueue:
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00022	83 c0 01	 add	 eax, 1
  00025	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@InitQueue:
  00028	83 7d fc 03	 cmp	 DWORD PTR _i$[ebp], 3
  0002c	7d 5c		 jge	 SHORT $LN2@InitQueue

; 54   : 	{
; 55   : 		dataQueue.channelQueue[i].font = 0;

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00031	69 c9 14 30 2a
	00		 imul	 ecx, 2764820		; 002a3014H
  00037	c7 81 00 30 2a
	00 00 00 00 00	 mov	 DWORD PTR _dataQueue[ecx+2764800], 0

; 56   : 		dataQueue.channelQueue[i].rear = 0;

  00041	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00044	69 d2 14 30 2a
	00		 imul	 edx, 2764820		; 002a3014H
  0004a	c7 82 04 30 2a
	00 00 00 00 00	 mov	 DWORD PTR _dataQueue[edx+2764804], 0

; 57   : 		dataQueue.channelQueue[i].num = 0;

  00054	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00057	69 c0 14 30 2a
	00		 imul	 eax, 2764820		; 002a3014H
  0005d	c7 80 08 30 2a
	00 00 00 00 00	 mov	 DWORD PTR _dataQueue[eax+2764808], 0

; 58   : #if defined(__WIN32__) || defined(_WIN32)
; 59   : 		queueLock[i] = CreateMutex(NULL,FALSE,"frame lock");

  00067	68 00 00 00 00	 push	 OFFSET $SG4294953303
  0006c	6a 00		 push	 0
  0006e	6a 00		 push	 0
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateMutexA@12
  00076	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00079	89 04 8d 00 00
	00 00		 mov	 DWORD PTR _queueLock[ecx*4], eax

; 60   : 		if(queueLock[i]==NULL){
; 61   : 			TRACE("==== %d %d===\n",__LINE__,i);
; 62   : 		}
; 63   : 		Sleep(10);

  00080	6a 0a		 push	 10			; 0000000aH
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 64   : #else
; 65   : 		pthread_mutex_init(&queueLock,NULL);
; 66   : #endif
; 67   : 	}

  00088	eb 95		 jmp	 SHORT $LN3@InitQueue
$LN2@InitQueue:

; 68   : 	_have_init_fifo = 1;

  0008a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR __have_init_fifo, 1
$LN6@InitQueue:

; 69   : }

  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
?InitQueue@@YAXXZ ENDP					; InitQueue
_TEXT	ENDS
END
