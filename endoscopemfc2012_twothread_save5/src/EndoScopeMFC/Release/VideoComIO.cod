; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

	TITLE	E:\work_wm\HXIJY_code\endoscopemfc2012_menu_changepara_youhua_savepic_USB_1114_twothread_svepic_save5\src\EndoScopeMFC\VideoComIO.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R2CVideoComIO@@8				; CVideoComIO::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CVideoComIO@@8			; CVideoComIO::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3CVideoComIO@@8				; CVideoComIO::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCVideoComIO@@@8				; CVideoComIO `RTTI Type Descriptor'
PUBLIC	??_R4CVideoComIO@@6B@				; CVideoComIO::`RTTI Complete Object Locator'
PUBLIC	??_7CVideoComIO@@6B@				; CVideoComIO::`vftable'
;	COMDAT ??_7CVideoComIO@@6B@
CONST	SEGMENT
??_7CVideoComIO@@6B@ DD FLAT:??_R4CVideoComIO@@6B@	; CVideoComIO::`vftable'
	DD	FLAT:??_ECVideoComIO@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4CVideoComIO@@6B@
rdata$r	SEGMENT
??_R4CVideoComIO@@6B@ DD 00H				; CVideoComIO::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCVideoComIO@@@8
	DD	FLAT:??_R3CVideoComIO@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCVideoComIO@@@8
_DATA	SEGMENT
??_R0?AVCVideoComIO@@@8 DD FLAT:??_7type_info@@6B@	; CVideoComIO `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCVideoComIO@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CVideoComIO@@8
rdata$r	SEGMENT
??_R3CVideoComIO@@8 DD 00H				; CVideoComIO::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CVideoComIO@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CVideoComIO@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CVideoComIO@@8 DD FLAT:??_R0?AVCVideoComIO@@@8 ; CVideoComIO::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CVideoComIO@@8
rdata$r	ENDS
;	COMDAT ??_R2CVideoComIO@@8
rdata$r	SEGMENT
??_R2CVideoComIO@@8 DD FLAT:??_R1A@?0A@EA@CVideoComIO@@8 ; CVideoComIO::`RTTI Base Class Array'
	ORG $+2
$SG4294928552 DB 'Error', 00H
PUBLIC	?OnRecv@CVideoComIO@@QAEIPAX@Z			; CVideoComIO::OnRecv
PUBLIC	?RecvHandler@CVideoComIO@@SAIPAX@Z		; CVideoComIO::RecvHandler
PUBLIC	?Release@CVideoComIO@@QAEXXZ			; CVideoComIO::Release
PUBLIC	??_GCVideoComIO@@UAEPAXI@Z			; CVideoComIO::`scalar deleting destructor'
PUBLIC	??0CVideoComIO@@QAE@XZ				; CVideoComIO::CVideoComIO
PUBLIC	??1CVideoComIO@@UAE@XZ				; CVideoComIO::~CVideoComIO
PUBLIC	?Initialize@CVideoComIO@@QAE_NV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ; CVideoComIO::Initialize
PUBLIC	?SendData@CVideoComIO@@QAEHPAEH@Z		; CVideoComIO::SendData
EXTRN	??_ECVideoComIO@@UAEPAXI@Z:PROC			; CVideoComIO::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?SendData@CVideoComIO@@QAEHPAEH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SendData@CVideoComIO@@QAEHPAEH@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SendData@CVideoComIO@@QAEHPAEH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SendData@CVideoComIO@@QAEHPAEH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?SendData@CVideoComIO@@QAEHPAEH@Z DD 00H
	DD	00H
	DD	01H
	DD	03H
	DD	FLAT:__catchsym$?SendData@CVideoComIO@@QAEHPAEH@Z$4
__catchsym$?SendData@CVideoComIO@@QAEHPAEH@Z$4 DD 00H
	DD	FLAT:??_R0PAVCMemoryException@@@8
	DD	0ffffffb0H
	DD	FLAT:__catch$?SendData@CVideoComIO@@QAEHPAEH@Z$0
	DD	00H
	DD	FLAT:??_R0PAVCFileException@@@8
	DD	0ffffffacH
	DD	FLAT:__catch$?SendData@CVideoComIO@@QAEHPAEH@Z$1
	DD	00H
	DD	FLAT:??_R0PAVCException@@@8
	DD	0ffffffa8H
	DD	FLAT:__catch$?SendData@CVideoComIO@@QAEHPAEH@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Initialize@CVideoComIO@@QAE_NV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Initialize@CVideoComIO@@QAE_NV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Initialize@CVideoComIO@@QAE_NV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Initialize@CVideoComIO@@QAE_NV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?OnRecv@CVideoComIO@@QAEIPAX@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?OnRecv@CVideoComIO@@QAEIPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?OnRecv@CVideoComIO@@QAEIPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnRecv@CVideoComIO@@QAEIPAX@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?OnRecv@CVideoComIO@@QAEIPAX@Z$1
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\videocomio.cpp
;	COMDAT ?SendData@CVideoComIO@@QAEHPAEH@Z
_TEXT	SEGMENT
_RTN$ = -76						; size = 4
_this$ = -72						; size = 4
_i$2 = -68						; size = 4
_sndsize$ = -64						; size = 2
_pBuf$ = -60						; size = 4
_dwWrite$ = -56						; size = 4
_sndBuf$ = -52						; size = 32
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_buf$ = 8						; size = 4
_size$ = 12						; size = 4
?SendData@CVideoComIO@@QAEHPAEH@Z PROC			; CVideoComIO::SendData, COMDAT
; _this$ = ecx

; 136  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SendData@CVideoComIO@@QAEHPAEH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 48	 sub	 esp, 72			; 00000048H
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001f	53		 push	 ebx
  00020	56		 push	 esi
  00021	57		 push	 edi
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002f	89 4d b8	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 	/*int nWriteLog = GetPrivateProfileInt("CFG","WriteLog",0,"testBitmap.ini");
; 138  : 	if ( 1 == nWriteLog )
; 139  : 	{
; 140  : 	CString sLog;
; 141  : 	sLog.Format("-----------------------------------------------------CurB:%03d,F:%03d,E:%02d,V:%02d,N:%d",g_nAvg,g_nPeek,g_nExposure,buf[5],999);
; 142  : 	WriteLog(sLog);
; 143  : 	}*/
; 144  : 	if (m_bExitFlag)

  00032	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00039	85 c9		 test	 ecx, ecx
  0003b	74 07		 je	 SHORT $LN5@SendData

; 145  : 	{
; 146  : 		return FALSE;

  0003d	33 c0		 xor	 eax, eax
  0003f	e9 ed 00 00 00	 jmp	 $LN6@SendData
$LN5@SendData:

; 147  : 	}
; 148  : 	DWORD dwWrite = 0;

  00044	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _dwWrite$[ebp], 0

; 149  : 	//添加发送协议
; 150  : 	BYTE* pBuf;
; 151  : 	
; 152  : 	//长度(不包含两位帧头)
; 153  : 	WORD sndsize = size;

  0004b	66 8b 55 0c	 mov	 dx, WORD PTR _size$[ebp]
  0004f	66 89 55 c0	 mov	 WORD PTR _sndsize$[ebp], dx

; 154  : 	
; 155  : 	BYTE sndBuf[32];
; 156  : 	memset(sndBuf, 0, sizeof(sndBuf));

  00053	33 c0		 xor	 eax, eax
  00055	89 45 cc	 mov	 DWORD PTR _sndBuf$[ebp], eax
  00058	89 45 d0	 mov	 DWORD PTR _sndBuf$[ebp+4], eax
  0005b	89 45 d4	 mov	 DWORD PTR _sndBuf$[ebp+8], eax
  0005e	89 45 d8	 mov	 DWORD PTR _sndBuf$[ebp+12], eax
  00061	89 45 dc	 mov	 DWORD PTR _sndBuf$[ebp+16], eax
  00064	89 45 e0	 mov	 DWORD PTR _sndBuf$[ebp+20], eax
  00067	89 45 e4	 mov	 DWORD PTR _sndBuf$[ebp+24], eax
  0006a	89 45 e8	 mov	 DWORD PTR _sndBuf$[ebp+28], eax

; 157  : 	pBuf = sndBuf;

  0006d	8d 4d cc	 lea	 ecx, DWORD PTR _sndBuf$[ebp]
  00070	89 4d c4	 mov	 DWORD PTR _pBuf$[ebp], ecx

; 158  : 	
; 159  : 	//帧起始
; 160  : 	*(BYTE*)pBuf = 0xA5;

  00073	8b 55 c4	 mov	 edx, DWORD PTR _pBuf$[ebp]
  00076	c6 02 a5	 mov	 BYTE PTR [edx], 165	; 000000a5H

; 161  : 	pBuf++;

  00079	8b 45 c4	 mov	 eax, DWORD PTR _pBuf$[ebp]
  0007c	83 c0 01	 add	 eax, 1
  0007f	89 45 c4	 mov	 DWORD PTR _pBuf$[ebp], eax

; 162  : 	*(BYTE*)pBuf = 0x5A;

  00082	8b 4d c4	 mov	 ecx, DWORD PTR _pBuf$[ebp]
  00085	c6 01 5a	 mov	 BYTE PTR [ecx], 90	; 0000005aH

; 163  : 	pBuf++;

  00088	8b 55 c4	 mov	 edx, DWORD PTR _pBuf$[ebp]
  0008b	83 c2 01	 add	 edx, 1
  0008e	89 55 c4	 mov	 DWORD PTR _pBuf$[ebp], edx

; 164  : 
; 165  : 	for( int i=0; i<sndsize; i++)

  00091	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00098	eb 09		 jmp	 SHORT $LN4@SendData
$LN3@SendData:
  0009a	8b 45 bc	 mov	 eax, DWORD PTR _i$2[ebp]
  0009d	83 c0 01	 add	 eax, 1
  000a0	89 45 bc	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@SendData:
  000a3	0f b7 4d c0	 movzx	 ecx, WORD PTR _sndsize$[ebp]
  000a7	39 4d bc	 cmp	 DWORD PTR _i$2[ebp], ecx
  000aa	7d 18		 jge	 SHORT $LN2@SendData

; 166  : 	{
; 167  : 		*(BYTE*)pBuf = buf[i];

  000ac	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  000af	03 55 bc	 add	 edx, DWORD PTR _i$2[ebp]
  000b2	8b 45 c4	 mov	 eax, DWORD PTR _pBuf$[ebp]
  000b5	8a 0a		 mov	 cl, BYTE PTR [edx]
  000b7	88 08		 mov	 BYTE PTR [eax], cl

; 168  : 		pBuf++;		

  000b9	8b 55 c4	 mov	 edx, DWORD PTR _pBuf$[ebp]
  000bc	83 c2 01	 add	 edx, 1
  000bf	89 55 c4	 mov	 DWORD PTR _pBuf$[ebp], edx

; 169  : 	}

  000c2	eb d6		 jmp	 SHORT $LN3@SendData
$LN2@SendData:

; 170  :  	//帧结束
; 171  : // 	*(BYTE*)pBuf = 0x97;
; 172  : // 	pBuf++;
; 173  : // 	*(BYTE*)pBuf = 0x98;
; 174  : // 	pBuf++;
; 175  : 	BOOL RTN = FALSE;

  000c4	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _RTN$[ebp], 0
  000cb	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 176  : 	try
; 177  : 	{
; 178  : 		RTN = WriteFile(m_hCom, (LPCVOID)sndBuf, sndsize+2, &dwWrite, NULL);

  000d2	6a 00		 push	 0
  000d4	8d 45 c8	 lea	 eax, DWORD PTR _dwWrite$[ebp]
  000d7	50		 push	 eax
  000d8	0f b7 4d c0	 movzx	 ecx, WORD PTR _sndsize$[ebp]
  000dc	83 c1 02	 add	 ecx, 2
  000df	51		 push	 ecx
  000e0	8d 55 cc	 lea	 edx, DWORD PTR _sndBuf$[ebp]
  000e3	52		 push	 edx
  000e4	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  000e7	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000ea	51		 push	 ecx
  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  000f1	89 45 b4	 mov	 DWORD PTR _RTN$[ebp], eax
  000f4	eb 12		 jmp	 SHORT $LN8@SendData
__catch$?SendData@CVideoComIO@@QAEHPAEH@Z$0:

; 179  : 	}

  000f6	b8 00 00 00 00	 mov	 eax, $LN13@SendData
  000fb	c3		 ret	 0
__catch$?SendData@CVideoComIO@@QAEHPAEH@Z$1:

; 180  : 	catch (CMemoryException* e)
; 181  : 	{
; 182  : 		
; 183  : 	}

  000fc	b8 00 00 00 00	 mov	 eax, $LN15@SendData
  00101	c3		 ret	 0
__catch$?SendData@CVideoComIO@@QAEHPAEH@Z$2:

; 187  : 	catch (CException* e)
; 188  : 	{
; 189  : 	}

  00102	b8 00 00 00 00	 mov	 eax, $LN17@SendData
  00107	c3		 ret	 0
$LN8@SendData:
  00108	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0010f	eb 09		 jmp	 SHORT $LN16@SendData
$LN17@SendData:
  00111	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00118	eb 14		 jmp	 SHORT __tryend$?SendData@CVideoComIO@@QAEHPAEH@Z$3
$LN16@SendData:
  0011a	eb 09		 jmp	 SHORT $LN14@SendData
$LN15@SendData:
  0011c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 184  : 	catch (CFileException* e)
; 185  : 	{
; 186  : 	}

  00123	eb 09		 jmp	 SHORT __tryend$?SendData@CVideoComIO@@QAEHPAEH@Z$3
$LN14@SendData:
  00125	eb 07		 jmp	 SHORT __tryend$?SendData@CVideoComIO@@QAEHPAEH@Z$3
$LN13@SendData:
  00127	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?SendData@CVideoComIO@@QAEHPAEH@Z$3:

; 190  : 
; 191  : 	//打出log代码，实际发布时屏蔽
; 192  : 	/*
; 193  : 	CString cstemp;
; 194  : 	CString csbuf;
; 195  : 	for(int j = 0; j<(pBuf-sndBuf); j++)
; 196  : 	{
; 197  : 		cstemp.Format(_T("%02X "),(unsigned char)sndBuf[j]);
; 198  : 		csbuf = csbuf + cstemp;
; 199  : 	}
; 200  : 	
; 201  : 	TRACE(csbuf);	
; 202  : 	CString filePath;
; 203  : 	filePath = ReturnPath();
; 204  : 	filePath += "\\Voice\\SendCOMLOG.txt";
; 205  : 	WriteComLog(csbuf,filePath);*/
; 206  : 	
; 207  : 	return RTN;

  0012e	8b 45 b4	 mov	 eax, DWORD PTR _RTN$[ebp]
$LN6@SendData:

; 208  : }

  00131	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00134	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013b	59		 pop	 ecx
  0013c	5f		 pop	 edi
  0013d	5e		 pop	 esi
  0013e	5b		 pop	 ebx
  0013f	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00142	33 cd		 xor	 ecx, ebp
  00144	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00149	8b e5		 mov	 esp, ebp
  0014b	5d		 pop	 ebp
  0014c	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?SendData@CVideoComIO@@QAEHPAEH@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00014	33 c8		 xor	 ecx, eax
  00016	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SendData@CVideoComIO@@QAEHPAEH@Z
  00020	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SendData@CVideoComIO@@QAEHPAEH@Z ENDP			; CVideoComIO::SendData
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\videocomio.cpp
;	COMDAT ?Initialize@CVideoComIO@@QAE_NV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
_TEXT	SEGMENT
$T2 = -77						; size = 1
$T3 = -76						; size = 1
$T4 = -75						; size = 1
$T5 = -74						; size = 1
$T6 = -73						; size = 1
_this$ = -72						; size = 4
_lpMsgBuf$7 = -68					; size = 4
_dcb$ = -64						; size = 28
_timeouts$ = -36					; size = 20
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_comName$ = 8						; size = 4
_nBaudRate$ = 12					; size = 4
?Initialize@CVideoComIO@@QAE_NV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z PROC ; CVideoComIO::Initialize, COMDAT
; _this$ = ecx

; 38   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Initialize@CVideoComIO@@QAE_NV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d b8	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 39   : 
; 40   : 	// 初始化变量
; 41   : 	m_rSize = 0;

  00032	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 42   : 	memset(m_rBuf, 0, sizeof(m_rBuf));

  0003c	33 c9		 xor	 ecx, ecx
  0003e	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  00041	83 c2 18	 add	 edx, 24			; 00000018H
  00044	89 0a		 mov	 DWORD PTR [edx], ecx
  00046	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00049	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0004c	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  0004f	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  00052	89 4a 14	 mov	 DWORD PTR [edx+20], ecx
  00055	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
  00058	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 43   : 
; 44   : 	// 打开串口
; 45   : 	m_hCom = CreateFile(comName,
; 46   : 						GENERIC_READ | GENERIC_WRITE,
; 47   : 						0,    // Exclusive access 
; 48   : 						NULL, // No security attributes 
; 49   : 						OPEN_EXISTING,
; 50   : 						0,    // FILE_FLAG_OVERLAPPED
; 51   : 						NULL);

  0005b	6a 00		 push	 0
  0005d	6a 00		 push	 0
  0005f	6a 03		 push	 3
  00061	6a 00		 push	 0
  00063	6a 00		 push	 0
  00065	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  0006a	8d 4d 08	 lea	 ecx, DWORD PTR _comName$[ebp]
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  00073	50		 push	 eax
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  0007a	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 52   : 	if (m_hCom == INVALID_HANDLE_VALUE) {

  00080	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  00083	83 7a 08 ff	 cmp	 DWORD PTR [edx+8], -1
  00087	75 1c		 jne	 SHORT $LN5@Initialize

; 53   : 		// 打开失败
; 54   : //		AfxMessageBox(_T("打开COM失败"));
; 55   : 		return false;

  00089	c6 45 b3 00	 mov	 BYTE PTR $T2[ebp], 0
  0008d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00094	8d 4d 08	 lea	 ecx, DWORD PTR _comName$[ebp]
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0009d	8a 45 b3	 mov	 al, BYTE PTR $T2[ebp]
  000a0	e9 7c 01 00 00	 jmp	 $LN6@Initialize
$LN5@Initialize:

; 56   : 	}
; 57   : 
; 58   : 	if(nBaudRate>0) {

  000a5	83 7d 0c 00	 cmp	 DWORD PTR _nBaudRate$[ebp], 0
  000a9	7e 09		 jle	 SHORT $LN4@Initialize

; 59   : 		// 设置比特率
; 60   : 		m_nBaudRate = nBaudRate;

  000ab	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d 0c	 mov	 ecx, DWORD PTR _nBaudRate$[ebp]
  000b1	89 48 10	 mov	 DWORD PTR [eax+16], ecx
$LN4@Initialize:

; 61   : 	}
; 62   : 
; 63   : 	// 取得指定串口的当前状态
; 64   : 	DCB dcb;
; 65   : 	if(!GetCommState(m_hCom,(LPDCB)&dcb)) {

  000b4	8d 55 c0	 lea	 edx, DWORD PTR _dcb$[ebp]
  000b7	52		 push	 edx
  000b8	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000be	51		 push	 ecx
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCommState@8
  000c5	85 c0		 test	 eax, eax
  000c7	75 1c		 jne	 SHORT $LN3@Initialize

; 66   : 		return false;

  000c9	c6 45 b4 00	 mov	 BYTE PTR $T3[ebp], 0
  000cd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000d4	8d 4d 08	 lea	 ecx, DWORD PTR _comName$[ebp]
  000d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000dd	8a 45 b4	 mov	 al, BYTE PTR $T3[ebp]
  000e0	e9 3c 01 00 00	 jmp	 $LN6@Initialize
$LN3@Initialize:

; 67   : 	}
; 68   : 
; 69   : 	dcb.BaudRate = (DWORD)m_nBaudRate;

  000e5	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  000e8	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000eb	89 45 c4	 mov	 DWORD PTR _dcb$[ebp+4], eax

; 70   : 	dcb.ByteSize = 8;

  000ee	c6 45 d2 08	 mov	 BYTE PTR _dcb$[ebp+18], 8

; 71   : 	dcb.Parity = NOPARITY;

  000f2	c6 45 d3 00	 mov	 BYTE PTR _dcb$[ebp+19], 0

; 72   : 	dcb.StopBits = ONESTOPBIT;

  000f6	c6 45 d4 00	 mov	 BYTE PTR _dcb$[ebp+20], 0

; 73   : 	dcb.fBinary = 1;

  000fa	8b 4d c8	 mov	 ecx, DWORD PTR _dcb$[ebp+8]
  000fd	83 c9 01	 or	 ecx, 1
  00100	89 4d c8	 mov	 DWORD PTR _dcb$[ebp+8], ecx

; 74   : 
; 75   : 	// 设置指定串口状态
; 76   : 	if(!SetCommState(m_hCom, &dcb)) {

  00103	8d 55 c0	 lea	 edx, DWORD PTR _dcb$[ebp]
  00106	52		 push	 edx
  00107	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  0010a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0010d	51		 push	 ecx
  0010e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCommState@8
  00114	85 c0		 test	 eax, eax
  00116	75 57		 jne	 SHORT $LN2@Initialize

; 77   : 		LPVOID lpMsgBuf;
; 78   : 		FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
; 79   : 					  FORMAT_MESSAGE_FROM_SYSTEM | 
; 80   : 					  FORMAT_MESSAGE_IGNORE_INSERTS,
; 81   : 					  NULL,
; 82   : 					  GetLastError(),
; 83   : 					  0, 
; 84   : 					  (LPTSTR)&lpMsgBuf,
; 85   : 					  0,
; 86   : 					  NULL);

  00118	6a 00		 push	 0
  0011a	6a 00		 push	 0
  0011c	8d 55 bc	 lea	 edx, DWORD PTR _lpMsgBuf$7[ebp]
  0011f	52		 push	 edx
  00120	6a 00		 push	 0
  00122	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00128	50		 push	 eax
  00129	6a 00		 push	 0
  0012b	68 00 13 00 00	 push	 4864			; 00001300H
  00130	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FormatMessageA@28

; 87   : 		MessageBox(NULL, (LPCTSTR)lpMsgBuf, _T("Error"), MB_OK | MB_ICONINFORMATION);

  00136	6a 40		 push	 64			; 00000040H
  00138	68 00 00 00 00	 push	 OFFSET $SG4294928552
  0013d	8b 45 bc	 mov	 eax, DWORD PTR _lpMsgBuf$7[ebp]
  00140	50		 push	 eax
  00141	6a 00		 push	 0
  00143	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 88   : 		LocalFree(lpMsgBuf);

  00149	8b 4d bc	 mov	 ecx, DWORD PTR _lpMsgBuf$7[ebp]
  0014c	51		 push	 ecx
  0014d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalFree@4

; 89   : 		return false;

  00153	c6 45 b6 00	 mov	 BYTE PTR $T5[ebp], 0
  00157	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0015e	8d 4d 08	 lea	 ecx, DWORD PTR _comName$[ebp]
  00161	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00167	8a 45 b6	 mov	 al, BYTE PTR $T5[ebp]
  0016a	e9 b2 00 00 00	 jmp	 $LN6@Initialize
$LN2@Initialize:

; 90   : 	}
; 91   : 	
; 92   : 	// 设置超时
; 93   : 	COMMTIMEOUTS timeouts;
; 94   : 	timeouts.ReadIntervalTimeout			= MAXDWORD; // 读间隔超时

  0016f	c7 45 dc ff ff
	ff ff		 mov	 DWORD PTR _timeouts$[ebp], -1

; 95   : 	timeouts.ReadTotalTimeoutMultiplier		= 0; // 读时间系数

  00176	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _timeouts$[ebp+4], 0

; 96   : 	timeouts.ReadTotalTimeoutConstant		= 0; // 读时间常量

  0017d	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _timeouts$[ebp+8], 0

; 97   : 	timeouts.WriteTotalTimeoutMultiplier	= 0; // 写时间系数

  00184	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _timeouts$[ebp+12], 0

; 98   : 	timeouts.WriteTotalTimeoutConstant		= 1000; // 写时间常量(1秒后写超时)

  0018b	c7 45 ec e8 03
	00 00		 mov	 DWORD PTR _timeouts$[ebp+16], 1000 ; 000003e8H

; 99   : 
; 100  : 	if (!SetCommTimeouts(m_hCom, &timeouts)) {

  00192	8d 55 dc	 lea	 edx, DWORD PTR _timeouts$[ebp]
  00195	52		 push	 edx
  00196	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  00199	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0019c	51		 push	 ecx
  0019d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCommTimeouts@8
  001a3	85 c0		 test	 eax, eax
  001a5	75 19		 jne	 SHORT $LN1@Initialize

; 101  : 		// 设置超时失败
; 102  : 		return false;

  001a7	c6 45 b5 00	 mov	 BYTE PTR $T4[ebp], 0
  001ab	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001b2	8d 4d 08	 lea	 ecx, DWORD PTR _comName$[ebp]
  001b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001bb	8a 45 b5	 mov	 al, BYTE PTR $T4[ebp]
  001be	eb 61		 jmp	 SHORT $LN6@Initialize
$LN1@Initialize:

; 103  : 	}
; 104  : 
; 105  : 	// 设置串口读缓冲和写缓冲的大小
; 106  : 	SetupComm(m_hCom, 1024*4, 512*4);

  001c0	68 00 08 00 00	 push	 2048			; 00000800H
  001c5	68 00 10 00 00	 push	 4096			; 00001000H
  001ca	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  001cd	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  001d0	50		 push	 eax
  001d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetupComm@12

; 107  : 
; 108  : 	// 清空串口读写缓冲区
; 109  : 	PurgeComm(m_hCom, PURGE_RXCLEAR | PURGE_TXCLEAR);

  001d7	6a 0c		 push	 12			; 0000000cH
  001d9	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  001dc	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001df	52		 push	 edx
  001e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PurgeComm@8

; 110  : 
; 111  : 	// 启动线程
; 112  : 	/*tmpTheApp->*/m_comThread = AfxBeginThread(CVideoComIO::RecvHandler, this, THREAD_PRIORITY_HIGHEST);

  001e6	6a 00		 push	 0
  001e8	6a 00		 push	 0
  001ea	6a 00		 push	 0
  001ec	6a 02		 push	 2
  001ee	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  001f1	50		 push	 eax
  001f2	68 00 00 00 00	 push	 OFFSET ?RecvHandler@CVideoComIO@@SAIPAX@Z ; CVideoComIO::RecvHandler
  001f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?AfxBeginThread@@YGPAVCWinThread@@P6AIPAX@Z0HIKPAU_SECURITY_ATTRIBUTES@@@Z
  001fd	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  00200	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 113  : 	m_bExitFlag = FALSE;

  00203	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  00206	c6 42 04 00	 mov	 BYTE PTR [edx+4], 0

; 114  : 
; 115  : 	return true;

  0020a	c6 45 b7 01	 mov	 BYTE PTR $T6[ebp], 1
  0020e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00215	8d 4d 08	 lea	 ecx, DWORD PTR _comName$[ebp]
  00218	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0021e	8a 45 b7	 mov	 al, BYTE PTR $T6[ebp]
$LN6@Initialize:

; 116  : }

  00221	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00224	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0022b	59		 pop	 ecx
  0022c	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0022f	33 cd		 xor	 ecx, ebp
  00231	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00236	8b e5		 mov	 esp, ebp
  00238	5d		 pop	 ebp
  00239	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Initialize@CVideoComIO@@QAE_NV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _comName$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?Initialize@CVideoComIO@@QAE_NV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Initialize@CVideoComIO@@QAE_NV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Initialize@CVideoComIO@@QAE_NV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ENDP ; CVideoComIO::Initialize
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\videocomio.cpp
;	COMDAT ??1CVideoComIO@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CVideoComIO@@UAE@XZ PROC				; CVideoComIO::~CVideoComIO, COMDAT
; _this$ = ecx

; 33   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CVideoComIO@@6B@

; 34   : 	Release();

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?Release@CVideoComIO@@QAEXXZ ; CVideoComIO::Release

; 35   : }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1CVideoComIO@@UAE@XZ ENDP				; CVideoComIO::~CVideoComIO
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\videocomio.cpp
;	COMDAT ??0CVideoComIO@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CVideoComIO@@QAE@XZ PROC				; CVideoComIO::CVideoComIO, COMDAT
; _this$ = ecx

; 23   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CVideoComIO@@6B@

; 24   : 	// 初始化
; 25   : 	m_hCom = INVALID_HANDLE_VALUE;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 08 ff ff
	ff ff		 mov	 DWORD PTR [ecx+8], -1

; 26   : 	m_nBaudRate = CBR_9600; // 初始化波特率

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 10 80 25
	00 00		 mov	 DWORD PTR [edx+16], 9600 ; 00002580H

; 27   : 	m_bExitFlag = TRUE;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1

; 28   : 	m_comThread = NULL;

  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 29   : 	m_pDataHandler = NULL;

  00035	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00038	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], 0

; 30   : }

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
??0CVideoComIO@@QAE@XZ ENDP				; CVideoComIO::CVideoComIO
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GCVideoComIO@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCVideoComIO@@UAEPAXI@Z PROC				; CVideoComIO::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CVideoComIO@@UAE@XZ	; CVideoComIO::~CVideoComIO
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0d		 je	 SHORT $LN1@scalar
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??3@YAXPAX@Z
  00021	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??_GCVideoComIO@@UAEPAXI@Z ENDP				; CVideoComIO::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\videocomio.cpp
;	COMDAT ?Release@CVideoComIO@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Release@CVideoComIO@@QAEXXZ PROC			; CVideoComIO::Release, COMDAT
; _this$ = ecx

; 120  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 121  : 	if(!m_bExitFlag)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0000e	85 c9		 test	 ecx, ecx
  00010	75 19		 jne	 SHORT $LN2@Release

; 122  : 	{
; 123  : 		m_bExitFlag = TRUE;

  00012	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00015	c6 42 04 01	 mov	 BYTE PTR [edx+4], 1

; 124  : 		::WaitForSingleObject(m_comThread->m_hThread,10);

  00019	6a 0a		 push	 10			; 0000000aH
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00021	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00024	52		 push	 edx
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
$LN2@Release:

; 125  : 	}
; 126  : 	if(m_hCom != INVALID_HANDLE_VALUE) 

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 78 08 ff	 cmp	 DWORD PTR [eax+8], -1
  00032	74 17		 je	 SHORT $LN3@Release

; 127  : 	{
; 128  : 		CloseHandle(m_hCom);

  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0003a	52		 push	 edx
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 129  : 		m_hCom = INVALID_HANDLE_VALUE;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	c7 40 08 ff ff
	ff ff		 mov	 DWORD PTR [eax+8], -1
$LN3@Release:

; 130  : 	}
; 131  : 
; 132  : }

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?Release@CVideoComIO@@QAEXXZ ENDP			; CVideoComIO::Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\videocomio.cpp
;	COMDAT ?RecvHandler@CVideoComIO@@SAIPAX@Z
_TEXT	SEGMENT
_lpParam$ = 8						; size = 4
?RecvHandler@CVideoComIO@@SAIPAX@Z PROC			; CVideoComIO::RecvHandler, COMDAT

; 212  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 213  : 	return ((CVideoComIO*)(lpParam))->OnRecv(lpParam);

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpParam$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _lpParam$[ebp]
  0000a	e8 00 00 00 00	 call	 ?OnRecv@CVideoComIO@@QAEIPAX@Z ; CVideoComIO::OnRecv

; 214  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?RecvHandler@CVideoComIO@@SAIPAX@Z ENDP			; CVideoComIO::RecvHandler
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\videocomio.cpp
;	COMDAT ?OnRecv@CVideoComIO@@QAEIPAX@Z
_TEXT	SEGMENT
_pCom$ = -84						; size = 4
$T2 = -80						; size = 4
$T3 = -76						; size = 4
_bRet$ = -72						; size = 4
_j$4 = -68						; size = 4
_this$ = -64						; size = 4
_dbgbuf$ = -60						; size = 4
_dbgtemp$ = -56						; size = 4
_dwSize$ = -52						; size = 4
_buf$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lpParam$ = 8						; size = 4
?OnRecv@CVideoComIO@@QAEIPAX@Z PROC			; CVideoComIO::OnRecv, COMDAT
; _this$ = ecx

; 218  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnRecv@CVideoComIO@@QAEIPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d c0	 mov	 DWORD PTR _this$[ebp], ecx

; 219  : 	CVideoComIO* pCom =(CVideoComIO*)lpParam;

  0002b	8b 45 08	 mov	 eax, DWORD PTR _lpParam$[ebp]
  0002e	89 45 ac	 mov	 DWORD PTR _pCom$[ebp], eax

; 220  : 	DWORD dwSize=0;

  00031	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _dwSize$[ebp], 0

; 221  : 	BOOL bRet = TRUE;

  00038	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR _bRet$[ebp], 1

; 222  : 	BYTE buf[32] = {0};

  0003f	c6 45 d0 00	 mov	 BYTE PTR _buf$[ebp], 0
  00043	33 c9		 xor	 ecx, ecx
  00045	89 4d d1	 mov	 DWORD PTR _buf$[ebp+1], ecx
  00048	89 4d d5	 mov	 DWORD PTR _buf$[ebp+5], ecx
  0004b	89 4d d9	 mov	 DWORD PTR _buf$[ebp+9], ecx
  0004e	89 4d dd	 mov	 DWORD PTR _buf$[ebp+13], ecx
  00051	89 4d e1	 mov	 DWORD PTR _buf$[ebp+17], ecx
  00054	89 4d e5	 mov	 DWORD PTR _buf$[ebp+21], ecx
  00057	89 4d e9	 mov	 DWORD PTR _buf$[ebp+25], ecx
  0005a	66 89 4d ed	 mov	 WORD PTR _buf$[ebp+29], cx
  0005e	88 4d ef	 mov	 BYTE PTR _buf$[ebp+31], cl

; 223  : 	CString dbgbuf,dbgtemp;

  00061	8d 4d c4	 lea	 ecx, DWORD PTR _dbgbuf$[ebp]
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0006a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00071	8d 4d c8	 lea	 ecx, DWORD PTR _dbgtemp$[ebp]
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0007a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
$LN15@OnRecv:

; 224  : 
; 225  : 	while (1) 

  0007e	ba 01 00 00 00	 mov	 edx, 1
  00083	85 d2		 test	 edx, edx
  00085	0f 84 02 02 00
	00		 je	 $LN14@OnRecv

; 226  : 	{		
; 227  : 		dwSize = 0;

  0008b	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _dwSize$[ebp], 0

; 228  :  		bRet = ReadFile(m_hCom,			  // 串口句柄
; 229  : 						m_rBuf + m_rSize, // 缓冲
; 230  : 						1,				  // 完成一次读串口操作需要读出的字节数总数
; 231  : 						&dwSize,	      // 完成一次读串口操作后实际读出的字节总数
; 232  : 						NULL );

  00092	6a 00		 push	 0
  00094	8d 45 cc	 lea	 eax, DWORD PTR _dwSize$[ebp]
  00097	50		 push	 eax
  00098	6a 01		 push	 1
  0009a	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000a0	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	8d 4c 10 18	 lea	 ecx, DWORD PTR [eax+edx+24]
  000a7	51		 push	 ecx
  000a8	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  000ab	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000ae	50		 push	 eax
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  000b5	89 45 b8	 mov	 DWORD PTR _bRet$[ebp], eax

; 233  : 
; 234  : 
; 235  : 		// 串口无效，关闭串口就退出了线程
; 236  : 		if(!bRet) {

  000b8	83 7d b8 00	 cmp	 DWORD PTR _bRet$[ebp], 0
  000bc	75 2c		 jne	 SHORT $LN13@OnRecv

; 237  : 			return 0;

  000be	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0
  000c5	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000c9	8d 4d c8	 lea	 ecx, DWORD PTR _dbgtemp$[ebp]
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000d2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000d9	8d 4d c4	 lea	 ecx, DWORD PTR _dbgbuf$[ebp]
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000e2	8b 45 b4	 mov	 eax, DWORD PTR $T3[ebp]
  000e5	e9 ca 01 00 00	 jmp	 $LN16@OnRecv
$LN13@OnRecv:

; 238  : 		}
; 239  : 
; 240  : 		// 如果读到数据
; 241  : 		if(dwSize > 0) 

  000ea	83 7d cc 00	 cmp	 DWORD PTR _dwSize$[ebp], 0
  000ee	0f 86 8c 01 00
	00		 jbe	 $LN12@OnRecv

; 242  : 		{
; 243  : 			m_rSize += dwSize;

  000f4	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  000f7	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000fa	03 55 cc	 add	 edx, DWORD PTR _dwSize$[ebp]
  000fd	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00100	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 244  : 		
; 245  : 			//检查起始位A55A
; 246  : 			if( m_rSize==1 )

  00103	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00106	83 79 14 01	 cmp	 DWORD PTR [ecx+20], 1
  0010a	75 41		 jne	 SHORT $LN11@OnRecv

; 247  : 			{
; 248  : 				if(m_rBuf[0] != 0xA5 )

  0010c	ba 01 00 00 00	 mov	 edx, 1
  00111	6b d2 00	 imul	 edx, 0
  00114	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00117	0f b6 4c 10 18	 movzx	 ecx, BYTE PTR [eax+edx+24]
  0011c	81 f9 a5 00 00
	00		 cmp	 ecx, 165		; 000000a5H
  00122	74 29		 je	 SHORT $LN11@OnRecv

; 249  : 				{
; 250  : 					//把接收数位置零
; 251  : 					m_rSize = 0;

  00124	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  00127	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 252  : 					//清BUF
; 253  : 					memset(m_rBuf,0,sizeof(m_rBuf));

  0012e	33 c0		 xor	 eax, eax
  00130	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00133	83 c1 18	 add	 ecx, 24			; 00000018H
  00136	89 01		 mov	 DWORD PTR [ecx], eax
  00138	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0013b	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0013e	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00141	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00144	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00147	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  0014a	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN11@OnRecv:

; 254  : 				}
; 255  : 			}
; 256  : 			
; 257  : 			if(m_rSize==2)

  0014d	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  00150	83 7a 14 02	 cmp	 DWORD PTR [edx+20], 2
  00154	75 3e		 jne	 SHORT $LN9@OnRecv

; 258  : 			{
; 259  : 				if(m_rBuf[1] != 0x5A )

  00156	b8 01 00 00 00	 mov	 eax, 1
  0015b	c1 e0 00	 shl	 eax, 0
  0015e	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00161	0f b6 54 01 18	 movzx	 edx, BYTE PTR [ecx+eax+24]
  00166	83 fa 5a	 cmp	 edx, 90			; 0000005aH
  00169	74 29		 je	 SHORT $LN9@OnRecv

; 260  : 				{
; 261  : 					m_rSize = 0;

  0016b	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  0016e	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 262  : 					memset(m_rBuf,0,sizeof(m_rBuf));

  00175	33 c9		 xor	 ecx, ecx
  00177	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  0017a	83 c2 18	 add	 edx, 24			; 00000018H
  0017d	89 0a		 mov	 DWORD PTR [edx], ecx
  0017f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00182	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00185	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00188	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  0018b	89 4a 14	 mov	 DWORD PTR [edx+20], ecx
  0018e	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
  00191	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx
$LN9@OnRecv:

; 263  : 				}
; 264  : 			}
; 265  : 
; 266  : 			//接收指定长度帧
; 267  : 			if( m_rBuf[2]==(m_rSize-3) )

  00194	b8 01 00 00 00	 mov	 eax, 1
  00199	d1 e0		 shl	 eax, 1
  0019b	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  0019e	0f b6 54 01 18	 movzx	 edx, BYTE PTR [ecx+eax+24]
  001a3	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  001a6	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001a9	83 e9 03	 sub	 ecx, 3
  001ac	3b d1		 cmp	 edx, ecx
  001ae	0f 85 98 00 00
	00		 jne	 $LN7@OnRecv

; 268  : 			{					
; 269  : 				for( int j = 0; j < m_rSize ; j++ )

  001b4	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _j$4[ebp], 0
  001bb	eb 09		 jmp	 SHORT $LN6@OnRecv
$LN5@OnRecv:
  001bd	8b 55 bc	 mov	 edx, DWORD PTR _j$4[ebp]
  001c0	83 c2 01	 add	 edx, 1
  001c3	89 55 bc	 mov	 DWORD PTR _j$4[ebp], edx
$LN6@OnRecv:
  001c6	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  001c9	8b 4d bc	 mov	 ecx, DWORD PTR _j$4[ebp]
  001cc	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  001cf	73 12		 jae	 SHORT $LN4@OnRecv

; 270  : 				{
; 271  : 					buf[j] = m_rBuf[j];

  001d1	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  001d4	03 55 bc	 add	 edx, DWORD PTR _j$4[ebp]
  001d7	8b 45 bc	 mov	 eax, DWORD PTR _j$4[ebp]
  001da	8a 4a 18	 mov	 cl, BYTE PTR [edx+24]
  001dd	88 4c 05 d0	 mov	 BYTE PTR _buf$[ebp+eax], cl

; 272  : 				}

  001e1	eb da		 jmp	 SHORT $LN5@OnRecv
$LN4@OnRecv:

; 273  : 
; 274  : 				//给主窗口发送消息
; 275  : 				if ( m_pDataHandler )

  001e3	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  001e6	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  001ea	74 1d		 je	 SHORT $LN3@OnRecv

; 276  : 					m_pDataHandler->ProcessData(buf,m_rSize);

  001ec	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  001ef	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001f2	51		 push	 ecx
  001f3	8d 55 d0	 lea	 edx, DWORD PTR _buf$[ebp]
  001f6	52		 push	 edx
  001f7	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  001fa	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  001fd	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  00200	8b 01		 mov	 eax, DWORD PTR [ecx]
  00202	8b 4a 38	 mov	 ecx, DWORD PTR [edx+56]
  00205	8b 10		 mov	 edx, DWORD PTR [eax]
  00207	ff d2		 call	 edx
$LN3@OnRecv:

; 277  : 
; 278  : 				m_rSize = 0;

  00209	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  0020c	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 279  : 				memset(m_rBuf,0,sizeof(m_rBuf));

  00213	33 c9		 xor	 ecx, ecx
  00215	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  00218	83 c2 18	 add	 edx, 24			; 00000018H
  0021b	89 0a		 mov	 DWORD PTR [edx], ecx
  0021d	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00220	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  00223	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00226	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  00229	89 4a 14	 mov	 DWORD PTR [edx+20], ecx
  0022c	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
  0022f	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 280  : 
; 281  : 
; 282  : 				//打出log代码，实际发布时屏蔽
; 283  : 				/*dbgbuf.Empty();
; 284  : 				dbgtemp.Empty();
; 285  : 				for(int x = 0; x < j+2; x++)
; 286  : 				{
; 287  : 					dbgtemp.Format(_T("%02X "),buf[x]);
; 288  : 					dbgbuf = dbgbuf + dbgtemp;
; 289  : 				}
; 290  : 				CString filePath;
; 291  : 				filePath = ReturnPath();
; 292  : 				filePath += "\\Voice\\COMLOG.txt";
; 293  : 				WriteComLog(dbgbuf,filePath);
; 294  : 				TRACE(dbgbuf);*/
; 295  : 				//缓冲清理					
; 296  : 				memset(buf,0,32);	

  00232	33 c0		 xor	 eax, eax
  00234	89 45 d0	 mov	 DWORD PTR _buf$[ebp], eax
  00237	89 45 d4	 mov	 DWORD PTR _buf$[ebp+4], eax
  0023a	89 45 d8	 mov	 DWORD PTR _buf$[ebp+8], eax
  0023d	89 45 dc	 mov	 DWORD PTR _buf$[ebp+12], eax
  00240	89 45 e0	 mov	 DWORD PTR _buf$[ebp+16], eax
  00243	89 45 e4	 mov	 DWORD PTR _buf$[ebp+20], eax
  00246	89 45 e8	 mov	 DWORD PTR _buf$[ebp+24], eax
  00249	89 45 ec	 mov	 DWORD PTR _buf$[ebp+28], eax
$LN7@OnRecv:

; 297  : 			}
; 298  : 
; 299  : 
; 300  : 			//接收长度太长的情况下清空
; 301  : 			if( m_rSize>=64 )

  0024c	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  0024f	83 79 14 40	 cmp	 DWORD PTR [ecx+20], 64	; 00000040H
  00253	72 29		 jb	 SHORT $LN2@OnRecv

; 302  : 			{
; 303  : 				m_rSize=0;

  00255	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  00258	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 304  : 				memset(m_rBuf, 0, sizeof(m_rBuf));

  0025f	33 c0		 xor	 eax, eax
  00261	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00264	83 c1 18	 add	 ecx, 24			; 00000018H
  00267	89 01		 mov	 DWORD PTR [ecx], eax
  00269	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0026c	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0026f	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00272	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00275	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  00278	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  0027b	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN2@OnRecv:

; 305  : 			}
; 306  : 		}
; 307  : 		// 没有读到数据
; 308  : 		else {

  0027e	eb 08		 jmp	 SHORT $LN1@OnRecv
$LN12@OnRecv:

; 309  : 			Sleep(1);

  00280	6a 01		 push	 1
  00282	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
$LN1@OnRecv:

; 310  : 		}
; 311  : 	}

  00288	e9 f1 fd ff ff	 jmp	 $LN15@OnRecv
$LN14@OnRecv:

; 312  : 	return 1;

  0028d	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
  00294	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00298	8d 4d c8	 lea	 ecx, DWORD PTR _dbgtemp$[ebp]
  0029b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  002a1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  002a8	8d 4d c4	 lea	 ecx, DWORD PTR _dbgbuf$[ebp]
  002ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  002b1	8b 45 b0	 mov	 eax, DWORD PTR $T2[ebp]
$LN16@OnRecv:

; 313  : }

  002b4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002b7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002be	59		 pop	 ecx
  002bf	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002c2	33 cd		 xor	 ecx, ebp
  002c4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002c9	8b e5		 mov	 esp, ebp
  002cb	5d		 pop	 ebp
  002cc	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnRecv@CVideoComIO@@QAEIPAX@Z$0:
  00000	8d 4d c4	 lea	 ecx, DWORD PTR _dbgbuf$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?OnRecv@CVideoComIO@@QAEIPAX@Z$1:
  00009	8d 4d c8	 lea	 ecx, DWORD PTR _dbgtemp$[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?OnRecv@CVideoComIO@@QAEIPAX@Z:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnRecv@CVideoComIO@@QAEIPAX@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnRecv@CVideoComIO@@QAEIPAX@Z ENDP			; CVideoComIO::OnRecv
END
