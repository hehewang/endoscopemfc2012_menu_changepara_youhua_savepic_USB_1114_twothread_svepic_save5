; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

	TITLE	E:\work_wm\HXIJY_code\endoscopemfc2012_menu_changepara_youhua_savepic_USB_1114_twothread_svepic_save5\src\EndoScopeMFC\EDSCapture.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R2CEDSCapture@@8				; CEDSCapture::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CEDSCapture@@8			; CEDSCapture::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3CEDSCapture@@8				; CEDSCapture::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCEDSCapture@@@8				; CEDSCapture `RTTI Type Descriptor'
PUBLIC	??_R4CEDSCapture@@6B@				; CEDSCapture::`RTTI Complete Object Locator'
PUBLIC	__GUID_6b652fff_11fe_4fce_92ad_0266b5d7c78f
PUBLIC	??_7CEDSCapture@@6B@				; CEDSCapture::`vftable'
PUBLIC	?classCEDSCapture@CEDSCapture@@2UCRuntimeClass@@B ; CEDSCapture::classCEDSCapture
PUBLIC	?g_nprocess@@3HA				; g_nprocess
EXTRN	__imp_?GetOccDialogInfo@CWnd@@MAEPAU_AFX_OCC_DIALOG_INFO@@XZ:PROC
EXTRN	__imp_?SetOccDialogInfo@CWnd@@MAEHPAU_AFX_OCC_DIALOG_INFO@@@Z:PROC
EXTRN	__imp_?CheckAutoCenter@CWnd@@UAEHXZ:PROC
EXTRN	__imp_?PreTranslateMessage@CWnd@@UAEHPAUtagMSG@@@Z:PROC
EXTRN	__imp_?OnCommand@CWnd@@MAEHIJ@Z:PROC
EXTRN	__imp_?OnCmdMsg@CCmdTarget@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z:PROC
EXTRN	__imp___vsnprintf_s:PROC
EXTRN	__imp_?_Orphan_all@_Container_base0@std@@QAEXXZ:PROC
EXTRN	?GetThisMessageMap@CWnd@@KGPBUAFX_MSGMAP@@XZ:PROC ; CWnd::GetThisMessageMap
EXTRN	?GetOccDialogInfo@CWnd@@MAEPAU_AFX_OCC_DIALOG_INFO@@XZ:PROC ; CWnd::GetOccDialogInfo
EXTRN	?SetOccDialogInfo@CWnd@@MAEHPAU_AFX_OCC_DIALOG_INFO@@@Z:PROC ; CWnd::SetOccDialogInfo
EXTRN	?CheckAutoCenter@CWnd@@UAEHXZ:PROC		; CWnd::CheckAutoCenter
EXTRN	?PreTranslateMessage@CWnd@@UAEHPAUtagMSG@@@Z:PROC ; CWnd::PreTranslateMessage
EXTRN	?OnCommand@CWnd@@MAEHIJ@Z:PROC			; CWnd::OnCommand
EXTRN	?OnCmdMsg@CCmdTarget@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z:PROC ; CCmdTarget::OnCmdMsg
EXTRN	__imp__CoTaskMemFree@4:PROC
EXTRN	_IID_IMediaEvent:BYTE
EXTRN	_IID_IVideoWindow:BYTE
EXTRN	_IID_IMediaControl:BYTE
EXTRN	_IID_ICaptureGraphBuilder2:BYTE
EXTRN	_IID_IGraphBuilder:BYTE
EXTRN	__imp__VariantInit@4:PROC
EXTRN	_IID_IPropertyBag:BYTE
EXTRN	_IID_ICreateDevEnum:BYTE
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	__imp__GetParent@4:PROC
EXTRN	__imp_?MessageBoxA@CWnd@@QAEHPBD0I@Z:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_CLSID_NullRenderer:BYTE
EXTRN	_IID_IBaseFilter:BYTE
EXTRN	__imp__CoCreateInstance@20:PROC
EXTRN	_CLSID_SampleGrabber:BYTE
EXTRN	__imp_?GetThisMessageMap@CWnd@@KGPBUAFX_MSGMAP@@XZ:PROC
EXTRN	__imp_??1CWnd@@UAE@XZ:PROC
EXTRN	__imp_??0CWnd@@QAE@XZ:PROC
EXTRN	__imp_?GetThisClass@CWnd@@SGPAUCRuntimeClass@@XZ:PROC
?g_nprocess@@3HA DD 01H DUP (?)				; g_nprocess
_BSS	ENDS
;	COMDAT ?classCEDSCapture@CEDSCapture@@2UCRuntimeClass@@B
CONST	SEGMENT
?classCEDSCapture@CEDSCapture@@2UCRuntimeClass@@B DD FLAT:$SG4294962993 ; CEDSCapture::classCEDSCapture
	DD	0d8H
	DD	0ffffH
	DD	00H
	DD	FLAT:?_GetBaseClass@CEDSCapture@@KGPAUCRuntimeClass@@XZ
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ??_7CEDSCapture@@6B@
CONST	SEGMENT
??_7CEDSCapture@@6B@ DD FLAT:??_R4CEDSCapture@@6B@	; CEDSCapture::`vftable'
	DD	FLAT:?GetRuntimeClass@CEDSCapture@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECEDSCapture@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CObject@@UBEXXZ
	DD	FLAT:?Dump@CObject@@UBEXAAVCDumpContext@@@Z
	DD	FLAT:?OnCmdMsg@CCmdTarget@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z
	DD	FLAT:?OnFinalRelease@CWnd@@UAEXXZ
	DD	FLAT:?IsInvokeAllowed@CCmdTarget@@UAEHJ@Z
	DD	FLAT:?GetDispatchIID@CCmdTarget@@UAEHPAU_GUID@@@Z
	DD	FLAT:?GetTypeInfoCount@CCmdTarget@@UAEIXZ
	DD	FLAT:?GetTypeLibCache@CCmdTarget@@UAEPAVCTypeLibCache@@XZ
	DD	FLAT:?GetTypeLib@CCmdTarget@@UAEJKPAPAUITypeLib@@@Z
	DD	FLAT:?GetMessageMap@CEDSCapture@@MBEPBUAFX_MSGMAP@@XZ
	DD	FLAT:?GetCommandMap@CCmdTarget@@MBEPBUAFX_OLECMDMAP@@XZ
	DD	FLAT:?GetDispatchMap@CCmdTarget@@MBEPBUAFX_DISPMAP@@XZ
	DD	FLAT:?GetConnectionMap@CCmdTarget@@MBEPBUAFX_CONNECTIONMAP@@XZ
	DD	FLAT:?GetInterfaceMap@CWnd@@MBEPBUAFX_INTERFACEMAP@@XZ
	DD	FLAT:?GetEventSinkMap@CCmdTarget@@MBEPBUAFX_EVENTSINKMAP@@XZ
	DD	FLAT:?OnCreateAggregates@CCmdTarget@@UAEHXZ
	DD	FLAT:?GetInterfaceHook@CCmdTarget@@UAEPAUIUnknown@@PBX@Z
	DD	FLAT:?GetExtraConnectionPoints@CCmdTarget@@MAEHPAVCPtrArray@@@Z
	DD	FLAT:?GetConnectionHook@CCmdTarget@@MAEPAUIConnectionPoint@@ABU_GUID@@@Z
	DD	FLAT:?PreSubclassWindow@CWnd@@UAEXXZ
	DD	FLAT:?Create@CWnd@@UAEHPBD0KABUtagRECT@@PAV1@IPAUCCreateContext@@@Z
	DD	FLAT:?CreateEx@CWnd@@UAEHKPBD0KABUtagRECT@@PAV1@IPAX@Z
	DD	FLAT:?CreateEx@CWnd@@UAEHKPBD0KHHHHPAUHWND__@@PAUHMENU__@@PAX@Z
	DD	FLAT:?DestroyWindow@CWnd@@UAEHXZ
	DD	FLAT:?PreCreateWindow@CWnd@@UAEHAAUtagCREATESTRUCTA@@@Z
	DD	FLAT:?CalcWindowRect@CWnd@@UAEXPAUtagRECT@@I@Z
	DD	FLAT:?GetMenu@CWnd@@UBEPAVCMenu@@XZ
	DD	FLAT:?SetMenu@CWnd@@UAEHPAVCMenu@@@Z
	DD	FLAT:?OnToolHitTest@CWnd@@UBEHVCPoint@@PAUtagTOOLINFOA@@@Z
	DD	FLAT:?GetScrollBarCtrl@CWnd@@UBEPAVCScrollBar@@H@Z
	DD	FLAT:?WinHelpA@CWnd@@UAEXKI@Z
	DD	FLAT:?HtmlHelpA@CWnd@@UAEXKI@Z
	DD	FLAT:?WinHelpInternal@CWnd@@UAEXKI@Z
	DD	FLAT:?ContinueModal@CWnd@@UAEHXZ
	DD	FLAT:?EndModalLoop@CWnd@@UAEXH@Z
	DD	FLAT:?OnDrawIconicThumbnailOrLivePreview@CWnd@@UAEXAAVCDC@@VCRect@@VCSize@@HAAH@Z
	DD	FLAT:?EnsureStdObj@CWnd@@UAEJXZ
	DD	FLAT:?get_accParent@CWnd@@UAEJPAPAUIDispatch@@@Z
	DD	FLAT:?get_accChildCount@CWnd@@UAEJPAJ@Z
	DD	FLAT:?get_accChild@CWnd@@UAEJUtagVARIANT@@PAPAUIDispatch@@@Z
	DD	FLAT:?get_accName@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accValue@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accDescription@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accRole@CWnd@@UAEJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?get_accState@CWnd@@UAEJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?get_accHelp@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accHelpTopic@CWnd@@UAEJPAPA_WUtagVARIANT@@PAJ@Z
	DD	FLAT:?get_accKeyboardShortcut@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?get_accFocus@CWnd@@UAEJPAUtagVARIANT@@@Z
	DD	FLAT:?get_accSelection@CWnd@@UAEJPAUtagVARIANT@@@Z
	DD	FLAT:?get_accDefaultAction@CWnd@@UAEJUtagVARIANT@@PAPA_W@Z
	DD	FLAT:?accSelect@CWnd@@UAEJJUtagVARIANT@@@Z
	DD	FLAT:?accLocation@CWnd@@UAEJPAJ000UtagVARIANT@@@Z
	DD	FLAT:?accNavigate@CWnd@@UAEJJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?accHitTest@CWnd@@UAEJJJPAUtagVARIANT@@@Z
	DD	FLAT:?accDoDefaultAction@CWnd@@UAEJUtagVARIANT@@@Z
	DD	FLAT:?put_accName@CWnd@@UAEJUtagVARIANT@@PA_W@Z
	DD	FLAT:?put_accValue@CWnd@@UAEJUtagVARIANT@@PA_W@Z
	DD	FLAT:?SetProxy@CWnd@@UAEJPAUIAccessibleProxy@@@Z
	DD	FLAT:?CreateAccessibleProxy@CWnd@@UAEJIJPAJ@Z
	DD	FLAT:?OnCommand@CWnd@@MAEHIJ@Z
	DD	FLAT:?OnNotify@CWnd@@MAEHIJPAJ@Z
	DD	FLAT:?GetSuperWndProcAddr@CWnd@@MAEPAP6GJPAUHWND__@@IIJ@ZXZ
	DD	FLAT:?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z
	DD	FLAT:?BeginModalState@CWnd@@UAEXXZ
	DD	FLAT:?EndModalState@CWnd@@UAEXXZ
	DD	FLAT:?PreTranslateMessage@CWnd@@UAEHPAUtagMSG@@@Z
	DD	FLAT:?OnAmbientProperty@CWnd@@UAEHPAVCOleControlSite@@JPAUtagVARIANT@@@Z
	DD	FLAT:?WindowProc@CWnd@@MAEJIIJ@Z
	DD	FLAT:?OnWndMsg@CWnd@@MAEHIIJPAJ@Z
	DD	FLAT:?DefWindowProcA@CWnd@@MAEJIIJ@Z
	DD	FLAT:?PostNcDestroy@CWnd@@MAEXXZ
	DD	FLAT:?OnChildNotify@CWnd@@MAEHIIJPAJ@Z
	DD	FLAT:?OnTouchInputs@CWnd@@MAEHIPAUtagTOUCHINPUT@@@Z
	DD	FLAT:?OnTouchInput@CWnd@@MAEHVCPoint@@HHPAUtagTOUCHINPUT@@@Z
	DD	FLAT:?GetGestureStatus@CWnd@@MAEKVCPoint@@@Z
	DD	FLAT:?OnGestureZoom@CWnd@@MAEHVCPoint@@J@Z
	DD	FLAT:?OnGesturePan@CWnd@@MAEHVCPoint@@0@Z
	DD	FLAT:?OnGestureRotate@CWnd@@MAEHVCPoint@@N@Z
	DD	FLAT:?OnGestureTwoFingerTap@CWnd@@MAEHVCPoint@@@Z
	DD	FLAT:?OnGesturePressAndTap@CWnd@@MAEHVCPoint@@J@Z
	DD	FLAT:?CheckAutoCenter@CWnd@@UAEHXZ
	DD	FLAT:?IsFrameWnd@CWnd@@UBEHXZ
	DD	FLAT:?CreateControlContainer@CWnd@@MAEHPAPAVCOleControlContainer@@@Z
	DD	FLAT:?CreateControlSite@CWnd@@MAEHPAVCOleControlContainer@@PAPAVCOleControlSite@@IABU_GUID@@@Z
	DD	FLAT:?SetOccDialogInfo@CWnd@@MAEHPAU_AFX_OCC_DIALOG_INFO@@@Z
	DD	FLAT:?GetOccDialogInfo@CWnd@@MAEPAU_AFX_OCC_DIALOG_INFO@@XZ
CONST	ENDS
;	COMDAT ?_messageEntries@?1??GetThisMessageMap@CEDSCapture@@KGPBUAFX_MSGMAP@@XZ@4QBUAFX_MSGMAP_ENTRY@@B
CONST	SEGMENT
?_messageEntries@?1??GetThisMessageMap@CEDSCapture@@KGPBUAFX_MSGMAP@@XZ@4QBUAFX_MSGMAP_ENTRY@@B DD 00H ; `CEDSCapture::GetThisMessageMap'::`2'::_messageEntries
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ?messageMap@?1??GetThisMessageMap@CEDSCapture@@KGPBUAFX_MSGMAP@@XZ@4U3@B
CONST	SEGMENT
?messageMap@?1??GetThisMessageMap@CEDSCapture@@KGPBUAFX_MSGMAP@@XZ@4U3@B DD FLAT:?GetThisMessageMap@CWnd@@KGPBUAFX_MSGMAP@@XZ ; `CEDSCapture::GetThisMessageMap'::`2'::messageMap
	DD	FLAT:?_messageEntries@?1??GetThisMessageMap@CEDSCapture@@KGPBUAFX_MSGMAP@@XZ@4QBUAFX_MSGMAP_ENTRY@@B
CONST	ENDS
;	COMDAT __GUID_6b652fff_11fe_4fce_92ad_0266b5d7c78f
CONST	SEGMENT
__GUID_6b652fff_11fe_4fce_92ad_0266b5d7c78f DD 06b652fffH
	DW	011feH
	DW	04fceH
	DB	092H
	DB	0adH
	DB	02H
	DB	066H
	DB	0b5H
	DB	0d7H
	DB	0c7H
	DB	08fH
CONST	ENDS
;	COMDAT ??_R4CEDSCapture@@6B@
rdata$r	SEGMENT
??_R4CEDSCapture@@6B@ DD 00H				; CEDSCapture::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCEDSCapture@@@8
	DD	FLAT:??_R3CEDSCapture@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCEDSCapture@@@8
_DATA	SEGMENT
??_R0?AVCEDSCapture@@@8 DD FLAT:??_7type_info@@6B@	; CEDSCapture `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCEDSCapture@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CEDSCapture@@8
rdata$r	SEGMENT
??_R3CEDSCapture@@8 DD 00H				; CEDSCapture::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CEDSCapture@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CEDSCapture@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CEDSCapture@@8 DD FLAT:??_R0?AVCEDSCapture@@@8 ; CEDSCapture::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CEDSCapture@@8
rdata$r	ENDS
;	COMDAT ??_R2CEDSCapture@@8
rdata$r	SEGMENT
??_R2CEDSCapture@@8 DD FLAT:??_R1A@?0A@EA@CEDSCapture@@8 ; CEDSCapture::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CWnd@@8
	DD	FLAT:??_R1A@?0A@EA@CCmdTarget@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
$SG4294963016 DB 00H
	ORG $+1
$SG4294963015 DB 00H, 00H
	ORG $+2
$SG4294962994 DB 'sec', 00H
$SG4294962993 DB 'CEDSCapture', 00H
$SG4294962992 DB 'Failed to get video interfaces!  hr=0x%x', 00H
	ORG $+3
$SG4294962991 DB 'Failed to set capture filter graph!  hr=0x%x', 00H
	ORG $+3
$SG4294962990 DB 0c6H, 089H, 091H, 098H, 'Uc', 0b7H, 083H, 00H, 00H
	ORG $+2
$SG4294962987 DB 'Fail to set media type!', 00H
$SG4294962985 DB 'Fail to put sample grabber in graph', 00H
$SG4294962989 DB 'Couldn''t add the capture filter to the graph!  hr=0x%x'
	DB	0dH, 0aH, 0dH, 0aH, 'If you have a working video capture devic'
	DB	'e, please make sure', 0dH, 0aH, 'that it is connected and is '
	DB	'not being used by another application.', 0dH, 0aH, 0dH, 0aH, 'T'
	DB	'he sample will now close.', 00H
	ORG $+3
$SG4294962986 DB 'G', 00H, 'r', 00H, 'a', 00H, 'b', 00H, 'b', 00H, 'e', 00H
	DB	'r', 00H, 00H, 00H
$SG4294962982 DB 'Couldn''t run the graph!  hr=0x%x', 00H
	ORG $+3
$SG4294962988 DB 'Fail to create SampleGrabber, maybe qedit.dll is not re'
	DB	'gistered?', 00H
	ORG $+3
$SG4294962984 DB 'N', 00H, 'u', 00H, 'l', 00H, 'l', 00H, 'R', 00H, 'e', 00H
	DB	'n', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG4294962983 DB 'Failt to read the connected media type', 00H
	ORG $+1
$SG4294962981 DB 'PlayCap Message', 00H
$SG4294962980 DB 'Couldn''t create system enumerator!  hr=0x%x', 00H
$SG4294962979 DB 'Couldn''t create class enumerator!  hr=0x%x', 00H
	ORG $+1
$SG4294962978 DB 'No Video Capture Hardware', 00H
	ORG $+2
$SG4294962977 DB 'No video capture device was detected.', 0dH, 0aH, 0dH, 0aH
	DB	'This sample requires a video capture device, such as a USB We'
	DB	'bCam,', 0dH, 0aH, 'to be installed and working properly.  The'
	DB	' sample will now close.', 00H
	ORG $+1
$SG4294962976 DB 'Couldn''t bind moniker to filter object!  hr=0x%x', 00H
	ORG $+3
$SG4294962975 DB 'F', 00H, 'r', 00H, 'i', 00H, 'e', 00H, 'n', 00H, 'd', 00H
	DB	'l', 00H, 'y', 00H, 'N', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 00H
	DB	00H
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@std@@@std@@YAXPAPAUIBaseFilter@@0AAU?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<IBaseFilter *> > >
PUBLIC	??$_Ptr_cat@PAUIBaseFilter@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUIBaseFilter@@0@Z ; std::_Ptr_cat<IBaseFilter *,IBaseFilter *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@std@@@std@@YAXPAPAUIBaseFilter@@0AAU?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<IBaseFilter *> > >
PUBLIC	??$_vsnprintf_s@$0EAA@@@YAHAAY0EAA@DIPBDPAD@Z	; _vsnprintf_s<1024>
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<IBaseFilter *> >::_Wrap_alloc<std::allocator<IBaseFilter *> >
PUBLIC	?deallocate@?$allocator@PAUIBaseFilter@@@std@@QAEXPAPAUIBaseFilter@@I@Z ; std::allocator<IBaseFilter *>::deallocate
PUBLIC	??0?$CComPtrBase@UIBaseFilter@@@ATL@@IAE@XZ	; ATL::CComPtrBase<IBaseFilter>::CComPtrBase<IBaseFilter>
PUBLIC	??8?$CComPtrBase@UISampleGrabber@@@ATL@@QBE_NPAUISampleGrabber@@@Z ; ATL::CComPtrBase<ISampleGrabber>::operator==
PUBLIC	??0?$CComPtrBase@UISampleGrabber@@@ATL@@IAE@PAUISampleGrabber@@@Z ; ATL::CComPtrBase<ISampleGrabber>::CComPtrBase<ISampleGrabber>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAUIBaseFilter@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<IBaseFilter *> >::_Vector_val<std::_Simple_types<IBaseFilter *> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@std@@QAEXPAPAUIBaseFilter@@I@Z ; std::_Wrap_alloc<std::allocator<IBaseFilter *> >::deallocate
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<IBaseFilter *,std::allocator<IBaseFilter *> > >::_Getal
PUBLIC	?_Destroy@?$vector@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@IAEXPAPAUIBaseFilter@@0@Z ; std::vector<IBaseFilter *,std::allocator<IBaseFilter *> >::_Destroy
PUBLIC	??0?$CComPtrBase@UIEnumMoniker@@@ATL@@IAE@PAUIEnumMoniker@@@Z ; ATL::CComPtrBase<IEnumMoniker>::CComPtrBase<IEnumMoniker>
PUBLIC	??0?$CComPtrBase@UICreateDevEnum@@@ATL@@IAE@PAUICreateDevEnum@@@Z ; ATL::CComPtrBase<ICreateDevEnum>::CComPtrBase<ICreateDevEnum>
PUBLIC	??0?$CComPtrBase@UIMoniker@@@ATL@@IAE@PAUIMoniker@@@Z ; ATL::CComPtrBase<IMoniker>::CComPtrBase<IMoniker>
PUBLIC	??0?$CComPtr@UIBaseFilter@@@ATL@@QAE@XZ		; ATL::CComPtr<IBaseFilter>::CComPtr<IBaseFilter>
PUBLIC	??9?$CComPtrBase@UISampleGrabber@@@ATL@@QBE_NPAUISampleGrabber@@@Z ; ATL::CComPtrBase<ISampleGrabber>::operator!=
PUBLIC	?Swap@?$CComPtrBase@UISampleGrabber@@@ATL@@IAEXAAV12@@Z ; ATL::CComPtrBase<ISampleGrabber>::Swap
PUBLIC	??0?$CComPtrBase@UISampleGrabber@@@ATL@@IAE@XZ	; ATL::CComPtrBase<ISampleGrabber>::CComPtrBase<ISampleGrabber>
PUBLIC	??0?$CComPtr@UISampleGrabber@@@ATL@@QAE@PAUISampleGrabber@@@Z ; ATL::CComPtr<ISampleGrabber>::CComPtr<ISampleGrabber>
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUIBaseFilter@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<IBaseFilter *,std::allocator<IBaseFilter *> > >::_Vector_alloc<0,std::_Vec_base_types<IBaseFilter *,std::allocator<IBaseFilter *> > >
PUBLIC	??0?$allocator@PAUIBaseFilter@@@std@@QAE@XZ	; std::allocator<IBaseFilter *>::allocator<IBaseFilter *>
PUBLIC	?_Tidy@?$vector@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@IAEXXZ ; std::vector<IBaseFilter *,std::allocator<IBaseFilter *> >::_Tidy
PUBLIC	??8?$CComPtrBase@UIEnumMoniker@@@ATL@@QBE_NPAUIEnumMoniker@@@Z ; ATL::CComPtrBase<IEnumMoniker>::operator==
PUBLIC	??C?$CComPtrBase@UIEnumMoniker@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIEnumMoniker@@@1@XZ ; ATL::CComPtrBase<IEnumMoniker>::operator->
PUBLIC	??I?$CComPtrBase@UIEnumMoniker@@@ATL@@QAEPAPAUIEnumMoniker@@XZ ; ATL::CComPtrBase<IEnumMoniker>::operator&
PUBLIC	??1?$CComPtrBase@UIEnumMoniker@@@ATL@@QAE@XZ	; ATL::CComPtrBase<IEnumMoniker>::~CComPtrBase<IEnumMoniker>
PUBLIC	??0?$CComPtr@UIEnumMoniker@@@ATL@@QAE@PAUIEnumMoniker@@@Z ; ATL::CComPtr<IEnumMoniker>::CComPtr<IEnumMoniker>
PUBLIC	??C?$CComPtrBase@UICreateDevEnum@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UICreateDevEnum@@@1@XZ ; ATL::CComPtrBase<ICreateDevEnum>::operator->
PUBLIC	??I?$CComPtrBase@UICreateDevEnum@@@ATL@@QAEPAPAUICreateDevEnum@@XZ ; ATL::CComPtrBase<ICreateDevEnum>::operator&
PUBLIC	??1?$CComPtrBase@UICreateDevEnum@@@ATL@@QAE@XZ	; ATL::CComPtrBase<ICreateDevEnum>::~CComPtrBase<ICreateDevEnum>
PUBLIC	??0?$CComPtr@UICreateDevEnum@@@ATL@@QAE@PAUICreateDevEnum@@@Z ; ATL::CComPtr<ICreateDevEnum>::CComPtr<ICreateDevEnum>
PUBLIC	??C?$CComPtrBase@UIMoniker@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIMoniker@@@1@XZ ; ATL::CComPtrBase<IMoniker>::operator->
PUBLIC	??I?$CComPtrBase@UIMoniker@@@ATL@@QAEPAPAUIMoniker@@XZ ; ATL::CComPtrBase<IMoniker>::operator&
PUBLIC	??1?$CComPtrBase@UIMoniker@@@ATL@@QAE@XZ	; ATL::CComPtrBase<IMoniker>::~CComPtrBase<IMoniker>
PUBLIC	??0?$CComPtr@UIMoniker@@@ATL@@QAE@PAUIMoniker@@@Z ; ATL::CComPtr<IMoniker>::CComPtr<IMoniker>
PUBLIC	??B?$CComPtrBase@UIBaseFilter@@@ATL@@QBEPAUIBaseFilter@@XZ ; ATL::CComPtrBase<IBaseFilter>::operator IBaseFilter *
PUBLIC	??1?$CComPtrBase@UIBaseFilter@@@ATL@@QAE@XZ	; ATL::CComPtrBase<IBaseFilter>::~CComPtrBase<IBaseFilter>
PUBLIC	??0?$CComQIPtr@UIBaseFilter@@$1?IID_IBaseFilter@@3U_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z ; ATL::CComQIPtr<IBaseFilter,&IID_IBaseFilter>::CComQIPtr<IBaseFilter,&IID_IBaseFilter>
PUBLIC	?CoCreateInstance@?$CComPtrBase@UISampleGrabber@@@ATL@@QAEJABU_GUID@@PAUIUnknown@@K@Z ; ATL::CComPtrBase<ISampleGrabber>::CoCreateInstance
PUBLIC	??7?$CComPtrBase@UISampleGrabber@@@ATL@@QBE_NXZ	; ATL::CComPtrBase<ISampleGrabber>::operator!
PUBLIC	??C?$CComPtrBase@UISampleGrabber@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UISampleGrabber@@@1@XZ ; ATL::CComPtrBase<ISampleGrabber>::operator->
PUBLIC	??B?$CComPtrBase@UISampleGrabber@@@ATL@@QBEPAUISampleGrabber@@XZ ; ATL::CComPtrBase<ISampleGrabber>::operator ISampleGrabber *
PUBLIC	??1?$CComPtrBase@UISampleGrabber@@@ATL@@QAE@XZ	; ATL::CComPtrBase<ISampleGrabber>::~CComPtrBase<ISampleGrabber>
PUBLIC	??4?$CComPtr@UISampleGrabber@@@ATL@@QAEPAUISampleGrabber@@PAU2@@Z ; ATL::CComPtr<ISampleGrabber>::operator=
PUBLIC	??0?$CComPtr@UISampleGrabber@@@ATL@@QAE@XZ	; ATL::CComPtr<ISampleGrabber>::CComPtr<ISampleGrabber>
PUBLIC	??1?$vector@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@QAE@XZ ; std::vector<IBaseFilter *,std::allocator<IBaseFilter *> >::~vector<IBaseFilter *,std::allocator<IBaseFilter *> >
PUBLIC	??0?$vector@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@QAE@XZ ; std::vector<IBaseFilter *,std::allocator<IBaseFilter *> >::vector<IBaseFilter *,std::allocator<IBaseFilter *> >
PUBLIC	?FreeMediaType@CEDSCapture@@IAEXAAU_AMMediaType@@@Z ; CEDSCapture::FreeMediaType
PUBLIC	?GetInterfaces@CEDSCapture@@IAEJXZ		; CEDSCapture::GetInterfaces
PUBLIC	?__autoclassinit@?$CComPtrBase@UIEnumMoniker@@@ATL@@QAEXI@Z ; ATL::CComPtrBase<IEnumMoniker>::__autoclassinit
PUBLIC	?__autoclassinit@?$CComPtrBase@UICreateDevEnum@@@ATL@@QAEXI@Z ; ATL::CComPtrBase<ICreateDevEnum>::__autoclassinit
PUBLIC	?__autoclassinit@?$CComPtrBase@UIMoniker@@@ATL@@QAEXI@Z ; ATL::CComPtrBase<IMoniker>::__autoclassinit
PUBLIC	?__autoclassinit@?$CComPtr@UIEnumMoniker@@@ATL@@QAEXI@Z ; ATL::CComPtr<IEnumMoniker>::__autoclassinit
PUBLIC	??1?$CComPtr@UIEnumMoniker@@@ATL@@QAE@XZ	; ATL::CComPtr<IEnumMoniker>::~CComPtr<IEnumMoniker>
PUBLIC	?__autoclassinit@?$CComPtr@UICreateDevEnum@@@ATL@@QAEXI@Z ; ATL::CComPtr<ICreateDevEnum>::__autoclassinit
PUBLIC	??1?$CComPtr@UICreateDevEnum@@@ATL@@QAE@XZ	; ATL::CComPtr<ICreateDevEnum>::~CComPtr<ICreateDevEnum>
PUBLIC	?__autoclassinit@?$CComPtr@UIMoniker@@@ATL@@QAEXI@Z ; ATL::CComPtr<IMoniker>::__autoclassinit
PUBLIC	??1?$CComPtr@UIMoniker@@@ATL@@QAE@XZ		; ATL::CComPtr<IMoniker>::~CComPtr<IMoniker>
PUBLIC	?FindCaptureDevice@CEDSCapture@@IAEJPAPAUIBaseFilter@@@Z ; CEDSCapture::FindCaptureDevice
PUBLIC	?Msg@CEDSCapture@@IAAXPADZZ			; CEDSCapture::Msg
PUBLIC	?Stop@CEDSCapture@@QAEXXZ			; CEDSCapture::Stop
PUBLIC	?Run@CEDSCapture@@QAEXXZ			; CEDSCapture::Run
PUBLIC	?Pause@CEDSCapture@@QAEXXZ			; CEDSCapture::Pause
PUBLIC	?__autoclassinit@?$CComPtrBase@UIBaseFilter@@@ATL@@QAEXI@Z ; ATL::CComPtrBase<IBaseFilter>::__autoclassinit
PUBLIC	?__autoclassinit@?$CComPtr@UIBaseFilter@@@ATL@@QAEXI@Z ; ATL::CComPtr<IBaseFilter>::__autoclassinit
PUBLIC	??1?$CComPtr@UIBaseFilter@@@ATL@@QAE@XZ		; ATL::CComPtr<IBaseFilter>::~CComPtr<IBaseFilter>
PUBLIC	?__autoclassinit@?$CComQIPtr@UIBaseFilter@@$1?IID_IBaseFilter@@3U_GUID@@B@ATL@@QAEXI@Z ; ATL::CComQIPtr<IBaseFilter,&IID_IBaseFilter>::__autoclassinit
PUBLIC	??1?$CComQIPtr@UIBaseFilter@@$1?IID_IBaseFilter@@3U_GUID@@B@ATL@@QAE@XZ ; ATL::CComQIPtr<IBaseFilter,&IID_IBaseFilter>::~CComQIPtr<IBaseFilter,&IID_IBaseFilter>
PUBLIC	?Init@CEDSCapture@@QAEJHPAUHWND__@@@Z		; CEDSCapture::Init
PUBLIC	?GetThisMessageMap@CEDSCapture@@KGPBUAFX_MSGMAP@@XZ ; CEDSCapture::GetThisMessageMap
PUBLIC	?GetMessageMap@CEDSCapture@@MBEPBUAFX_MSGMAP@@XZ ; CEDSCapture::GetMessageMap
PUBLIC	??1CEDSCapture@@UAE@XZ				; CEDSCapture::~CEDSCapture
PUBLIC	??1?$CComPtr@UISampleGrabber@@@ATL@@QAE@XZ	; ATL::CComPtr<ISampleGrabber>::~CComPtr<ISampleGrabber>
PUBLIC	??_GCEDSCapture@@UAEPAXI@Z			; CEDSCapture::`scalar deleting destructor'
PUBLIC	??0CEDSCapture@@QAE@XZ				; CEDSCapture::CEDSCapture
PUBLIC	?GetRuntimeClass@CEDSCapture@@UBEPAUCRuntimeClass@@XZ ; CEDSCapture::GetRuntimeClass
PUBLIC	?_GetBaseClass@CEDSCapture@@KGPAUCRuntimeClass@@XZ ; CEDSCapture::_GetBaseClass
EXTRN	??_ECEDSCapture@@UAEPAXI@Z:PROC			; CEDSCapture::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CEDSCapture@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CEDSCapture@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CEDSCapture@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CEDSCapture@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CEDSCapture@@QAE@XZ$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CEDSCapture@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CEDSCapture@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CEDSCapture@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CEDSCapture@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CEDSCapture@@UAE@XZ$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Init@CEDSCapture@@QAEJHPAUHWND__@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Init@CEDSCapture@@QAEJHPAUHWND__@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Init@CEDSCapture@@QAEJHPAUHWND__@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@CEDSCapture@@QAEJHPAUHWND__@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?FindCaptureDevice@CEDSCapture@@IAEJPAPAUIBaseFilter@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?FindCaptureDevice@CEDSCapture@@IAEJPAPAUIBaseFilter@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?FindCaptureDevice@CEDSCapture@@IAEJPAPAUIBaseFilter@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindCaptureDevice@CEDSCapture@@IAEJPAPAUIBaseFilter@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?FindCaptureDevice@CEDSCapture@@IAEJPAPAUIBaseFilter@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?FindCaptureDevice@CEDSCapture@@IAEJPAPAUIBaseFilter@@@Z$2
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\edscapture.cpp
;	COMDAT ?_GetBaseClass@CEDSCapture@@KGPAUCRuntimeClass@@XZ
_TEXT	SEGMENT
?_GetBaseClass@CEDSCapture@@KGPAUCRuntimeClass@@XZ PROC	; CEDSCapture::_GetBaseClass, COMDAT

; 30   : IMPLEMENT_DYNAMIC(CEDSCapture, CWnd)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetThisClass@CWnd@@SGPAUCRuntimeClass@@XZ
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_GetBaseClass@CEDSCapture@@KGPAUCRuntimeClass@@XZ ENDP	; CEDSCapture::_GetBaseClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\edscapture.cpp
;	COMDAT ?GetRuntimeClass@CEDSCapture@@UBEPAUCRuntimeClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRuntimeClass@CEDSCapture@@UBEPAUCRuntimeClass@@XZ PROC ; CEDSCapture::GetRuntimeClass, COMDAT
; _this$ = ecx

; 30   : IMPLEMENT_DYNAMIC(CEDSCapture, CWnd)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b8 00 00 00 00	 mov	 eax, OFFSET ?classCEDSCapture@CEDSCapture@@2UCRuntimeClass@@B ; CEDSCapture::classCEDSCapture
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetRuntimeClass@CEDSCapture@@UBEPAUCRuntimeClass@@XZ ENDP ; CEDSCapture::GetRuntimeClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\edscapture.cpp
;	COMDAT ??0CEDSCapture@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CEDSCapture@@QAE@XZ PROC				; CEDSCapture::CEDSCapture, COMDAT
; _this$ = ecx

; 32   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CEDSCapture@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWnd@@QAE@XZ
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00036	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CEDSCapture@@6B@
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	83 c1 7c	 add	 ecx, 124		; 0000007cH
  00045	e8 00 00 00 00	 call	 ??0?$vector@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@QAE@XZ ; std::vector<IBaseFilter *,std::allocator<IBaseFilter *> >::vector<IBaseFilter *,std::allocator<IBaseFilter *> >
  0004a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	81 c1 a4 00 00
	00		 add	 ecx, 164		; 000000a4H
  00057	e8 00 00 00 00	 call	 ??0CEDSGrabberCB@@QAE@XZ ; CEDSGrabberCB::CEDSGrabberCB
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  00065	e8 00 00 00 00	 call	 ??0?$CComPtr@UISampleGrabber@@@ATL@@QAE@XZ ; ATL::CComPtr<ISampleGrabber>::CComPtr<ISampleGrabber>

; 33   : 	m_hApp = NULL;

  0006a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	c7 81 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+152], 0

; 34   : 	m_dwGraphRegister = 0;	

  00077	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0007a	c7 82 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+156], 0

; 35   : 	m_pVW = NULL;

  00084	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00087	c7 80 c0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+192], 0

; 36   : 	m_pMC = NULL;

  00091	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	c7 81 c4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+196], 0

; 37   : 	m_pME = NULL;

  0009e	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000a1	c7 82 c8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+200], 0

; 38   : 	m_pGraph = NULL;

  000ab	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	c7 80 cc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+204], 0

; 39   : 	m_pCapture = NULL;

  000b8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	c7 81 d0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+208], 0

; 40   : 	m_pGrabber = NULL;

  000c5	6a 00		 push	 0
  000c7	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ca	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  000d0	e8 00 00 00 00	 call	 ??4?$CComPtr@UISampleGrabber@@@ATL@@QAEPAUISampleGrabber@@PAU2@@Z ; ATL::CComPtr<ISampleGrabber>::operator=

; 41   : 	
; 42   : 	m_psCurrent = Stopped;

  000d5	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000d8	c7 82 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+148], 0

; 43   : 	//g_bOneShot = FALSE;
; 44   : 	g_nprocess = 0;

  000e2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_nprocess@@3HA, 0 ; g_nprocess

; 45   : 
; 46   : }

  000ec	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000f3	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000f6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00100	59		 pop	 ecx
  00101	8b e5		 mov	 esp, ebp
  00103	5d		 pop	 ebp
  00104	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CEDSCapture@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CWnd@@UAE@XZ
__unwindfunclet$??0CEDSCapture@@QAE@XZ$1:
  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0000f	e9 00 00 00 00	 jmp	 ??1?$vector@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@QAE@XZ ; std::vector<IBaseFilter *,std::allocator<IBaseFilter *> >::~vector<IBaseFilter *,std::allocator<IBaseFilter *> >
__ehhandler$??0CEDSCapture@@QAE@XZ:
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001e	33 c8		 xor	 ecx, eax
  00020	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00025	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CEDSCapture@@QAE@XZ
  0002a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CEDSCapture@@QAE@XZ ENDP				; CEDSCapture::CEDSCapture
; Function compile flags: /Odtp
;	COMDAT ??_GCEDSCapture@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCEDSCapture@@UAEPAXI@Z PROC				; CEDSCapture::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CEDSCapture@@UAE@XZ	; CEDSCapture::~CEDSCapture
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 09		 je	 SHORT $LN1@scalar
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
$LN1@scalar:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??_GCEDSCapture@@UAEPAXI@Z ENDP				; CEDSCapture::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$CComPtr@UISampleGrabber@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CComPtr@UISampleGrabber@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<ISampleGrabber>::~CComPtr<ISampleGrabber>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CComPtrBase@UISampleGrabber@@@ATL@@QAE@XZ ; ATL::CComPtrBase<ISampleGrabber>::~CComPtrBase<ISampleGrabber>
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$CComPtr@UISampleGrabber@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<ISampleGrabber>::~CComPtr<ISampleGrabber>
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\edscapture.cpp
;	COMDAT ??1CEDSCapture@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CEDSCapture@@UAE@XZ PROC				; CEDSCapture::~CEDSCapture, COMDAT
; _this$ = ecx

; 49   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CEDSCapture@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CEDSCapture@@6B@
  0002f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 50   : 	//CloseInterfaces();	// 关闭接口
; 51   : 	//CoUninitialize();	// 结束COM
; 52   : 
; 53   : 	//g_CB.m_pBufferList.clear();
; 54   : }

  00036	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  0003f	e8 00 00 00 00	 call	 ??1?$CComPtr@UISampleGrabber@@@ATL@@QAE@XZ
  00044	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	81 c1 a4 00 00
	00		 add	 ecx, 164		; 000000a4H
  0004d	e8 00 00 00 00	 call	 ??1CEDSGrabberCB@@QAE@XZ ; CEDSGrabberCB::~CEDSGrabberCB
  00052	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00056	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0005c	e8 00 00 00 00	 call	 ??1?$vector@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@QAE@XZ ; std::vector<IBaseFilter *,std::allocator<IBaseFilter *> >::~vector<IBaseFilter *,std::allocator<IBaseFilter *> >
  00061	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00068	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWnd@@UAE@XZ
  00071	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00074	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007b	59		 pop	 ecx
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CEDSCapture@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CWnd@@UAE@XZ
__unwindfunclet$??1CEDSCapture@@UAE@XZ$1:
  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0000f	e9 00 00 00 00	 jmp	 ??1?$vector@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@QAE@XZ ; std::vector<IBaseFilter *,std::allocator<IBaseFilter *> >::~vector<IBaseFilter *,std::allocator<IBaseFilter *> >
__ehhandler$??1CEDSCapture@@UAE@XZ:
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001e	33 c8		 xor	 ecx, eax
  00020	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00025	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CEDSCapture@@UAE@XZ
  0002a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CEDSCapture@@UAE@XZ ENDP				; CEDSCapture::~CEDSCapture
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\edscapture.cpp
;	COMDAT ?GetMessageMap@CEDSCapture@@MBEPBUAFX_MSGMAP@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMessageMap@CEDSCapture@@MBEPBUAFX_MSGMAP@@XZ PROC	; CEDSCapture::GetMessageMap, COMDAT
; _this$ = ecx

; 56   : BEGIN_MESSAGE_MAP(CEDSCapture, CWnd)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	e8 00 00 00 00	 call	 ?GetThisMessageMap@CEDSCapture@@KGPBUAFX_MSGMAP@@XZ ; CEDSCapture::GetThisMessageMap
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetMessageMap@CEDSCapture@@MBEPBUAFX_MSGMAP@@XZ ENDP	; CEDSCapture::GetMessageMap
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\edscapture.cpp
;	COMDAT ?GetThisMessageMap@CEDSCapture@@KGPBUAFX_MSGMAP@@XZ
_TEXT	SEGMENT
?GetThisMessageMap@CEDSCapture@@KGPBUAFX_MSGMAP@@XZ PROC ; CEDSCapture::GetThisMessageMap, COMDAT

; 56   : BEGIN_MESSAGE_MAP(CEDSCapture, CWnd)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : END_MESSAGE_MAP()

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?messageMap@?1??GetThisMessageMap@CEDSCapture@@KGPBUAFX_MSGMAP@@XZ@4U3@B
  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?GetThisMessageMap@CEDSCapture@@KGPBUAFX_MSGMAP@@XZ ENDP ; CEDSCapture::GetThisMessageMap
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\edscapture.cpp
;	COMDAT ?Init@CEDSCapture@@QAEJHPAUHWND__@@@Z
_TEXT	SEGMENT
$T2 = -152						; size = 4
$T3 = -148						; size = 4
$T4 = -144						; size = 4
$T5 = -140						; size = 4
$T6 = -136						; size = 4
_vih$ = -132						; size = 4
tv200 = -128						; size = 4
tv353 = -124						; size = 4
tv288 = -120						; size = 4
tv336 = -116						; size = 4
tv319 = -112						; size = 4
_this$ = -108						; size = 4
_hr$ = -104						; size = 4
_mt$ = -100						; size = 72
_pNull$ = -28						; size = 4
_pSrcFilter$ = -24					; size = 4
_pGrabBase$ = -20					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_iDeviceID$ = 8						; size = 4
_hWnd$ = 12						; size = 4
?Init@CEDSCapture@@QAEJHPAUHWND__@@@Z PROC		; CEDSCapture::Init, COMDAT
; _this$ = ecx

; 62   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Init@CEDSCapture@@QAEJHPAUHWND__@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 4d 94	 mov	 DWORD PTR _this$[ebp], ecx

; 63   : 	HRESULT hr;
; 64   :     IBaseFilter *pSrcFilter=NULL;

  0002e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _pSrcFilter$[ebp], 0

; 65   : 	
; 66   : 	m_hApp = hWnd;

  00035	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 4d 0c	 mov	 ecx, DWORD PTR _hWnd$[ebp]
  0003b	89 88 98 00 00
	00		 mov	 DWORD PTR [eax+152], ecx

; 67   :     // Get DirectShow interfaces
; 68   :     hr = GetInterfaces();

  00041	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?GetInterfaces@CEDSCapture@@IAEJXZ ; CEDSCapture::GetInterfaces
  00049	89 45 98	 mov	 DWORD PTR _hr$[ebp], eax

; 69   :     if (FAILED(hr))

  0004c	83 7d 98 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00050	7d 1d		 jge	 SHORT $LN9@Init

; 70   :     {
; 71   :         Msg(TEXT("Failed to get video interfaces!  hr=0x%x"), hr);

  00052	8b 55 98	 mov	 edx, DWORD PTR _hr$[ebp]
  00055	52		 push	 edx
  00056	68 00 00 00 00	 push	 OFFSET $SG4294962992
  0005b	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ?Msg@CEDSCapture@@IAAXPADZZ ; CEDSCapture::Msg
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 72   :         return hr;

  00067	8b 45 98	 mov	 eax, DWORD PTR _hr$[ebp]
  0006a	e9 61 04 00 00	 jmp	 $LN10@Init
$LN9@Init:

; 73   :     }
; 74   : 
; 75   :     // Attach the filter graph to the capture graph
; 76   :     hr = m_pCapture->SetFiltergraph(m_pGraph);

  0006f	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	8b 91 cc 00 00
	00		 mov	 edx, DWORD PTR [ecx+204]
  00078	52		 push	 edx
  00079	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  0007c	8b 88 d0 00 00
	00		 mov	 ecx, DWORD PTR [eax+208]
  00082	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  00085	8b 82 d0 00 00
	00		 mov	 eax, DWORD PTR [edx+208]
  0008b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0008d	50		 push	 eax
  0008e	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00091	ff d2		 call	 edx
  00093	89 45 98	 mov	 DWORD PTR _hr$[ebp], eax

; 77   :     if (FAILED(hr))

  00096	83 7d 98 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0009a	7d 1d		 jge	 SHORT $LN8@Init

; 78   :     {
; 79   :         Msg(TEXT("Failed to set capture filter graph!  hr=0x%x"), hr);

  0009c	8b 45 98	 mov	 eax, DWORD PTR _hr$[ebp]
  0009f	50		 push	 eax
  000a0	68 00 00 00 00	 push	 OFFSET $SG4294962991
  000a5	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	51		 push	 ecx
  000a9	e8 00 00 00 00	 call	 ?Msg@CEDSCapture@@IAAXPADZZ ; CEDSCapture::Msg
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 80   :         return hr;

  000b1	8b 45 98	 mov	 eax, DWORD PTR _hr$[ebp]
  000b4	e9 17 04 00 00	 jmp	 $LN10@Init
$LN8@Init:

; 81   :     }
; 82   : 
; 83   :     // Use the system device enumerator and class enumerator to find
; 84   :     // a video capture/preview device, such as a desktop USB video camera.
; 85   : 	// 使用设备和类计数器寻找视频捕捉设备
; 86   :     hr = FindCaptureDevice(&pSrcFilter);

  000b9	8d 55 e8	 lea	 edx, DWORD PTR _pSrcFilter$[ebp]
  000bc	52		 push	 edx
  000bd	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	e8 00 00 00 00	 call	 ?FindCaptureDevice@CEDSCapture@@IAEJPAPAUIBaseFilter@@@Z ; CEDSCapture::FindCaptureDevice
  000c5	89 45 98	 mov	 DWORD PTR _hr$[ebp], eax

; 87   :     if (FAILED(hr))

  000c8	83 7d 98 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000cc	7d 08		 jge	 SHORT $LN7@Init

; 88   :     {
; 89   :         // Don't display a message because FindCaptureDevice will handle it
; 90   :         return hr;

  000ce	8b 45 98	 mov	 eax, DWORD PTR _hr$[ebp]
  000d1	e9 fa 03 00 00	 jmp	 $LN10@Init
$LN7@Init:

; 91   :     }
; 92   :    
; 93   :     // Add Capture filter to our graph.
; 94   :     hr = m_pGraph->AddFilter(pSrcFilter, L"视频捕获");

  000d6	68 00 00 00 00	 push	 OFFSET $SG4294962990
  000db	8b 45 e8	 mov	 eax, DWORD PTR _pSrcFilter$[ebp]
  000de	50		 push	 eax
  000df	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  000e2	8b 91 cc 00 00
	00		 mov	 edx, DWORD PTR [ecx+204]
  000e8	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	8b 88 cc 00 00
	00		 mov	 ecx, DWORD PTR [eax+204]
  000f1	8b 12		 mov	 edx, DWORD PTR [edx]
  000f3	51		 push	 ecx
  000f4	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000f7	ff d0		 call	 eax
  000f9	89 45 98	 mov	 DWORD PTR _hr$[ebp], eax

; 95   :     if (FAILED(hr))

  000fc	83 7d 98 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00100	7d 2b		 jge	 SHORT $LN6@Init

; 96   :     {
; 97   :         Msg(TEXT("Couldn't add the capture filter to the graph!  hr=0x%x\r\n\r\n") 
; 98   :             TEXT("If you have a working video capture device, please make sure\r\n")
; 99   :             TEXT("that it is connected and is not being used by another application.\r\n\r\n")
; 100  :             TEXT("The sample will now close."), hr);

  00102	8b 4d 98	 mov	 ecx, DWORD PTR _hr$[ebp]
  00105	51		 push	 ecx
  00106	68 00 00 00 00	 push	 OFFSET $SG4294962989
  0010b	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  0010e	52		 push	 edx
  0010f	e8 00 00 00 00	 call	 ?Msg@CEDSCapture@@IAAXPADZZ ; CEDSCapture::Msg
  00114	83 c4 0c	 add	 esp, 12			; 0000000cH

; 101  :         pSrcFilter->Release();

  00117	8b 45 e8	 mov	 eax, DWORD PTR _pSrcFilter$[ebp]
  0011a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0011c	8b 55 e8	 mov	 edx, DWORD PTR _pSrcFilter$[ebp]
  0011f	52		 push	 edx
  00120	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00123	ff d0		 call	 eax

; 102  :         return hr;

  00125	8b 45 98	 mov	 eax, DWORD PTR _hr$[ebp]
  00128	e9 a3 03 00 00	 jmp	 $LN10@Init
$LN6@Init:

; 103  :     }
; 104  : 
; 105  : 	// 创建一个接口
; 106  : 	hr = m_pGrabber.CoCreateInstance( CLSID_SampleGrabber );

  0012d	6a 17		 push	 23			; 00000017H
  0012f	6a 00		 push	 0
  00131	68 00 00 00 00	 push	 OFFSET _CLSID_SampleGrabber
  00136	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00139	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  0013f	e8 00 00 00 00	 call	 ?CoCreateInstance@?$CComPtrBase@UISampleGrabber@@@ATL@@QAEJABU_GUID@@PAUIUnknown@@K@Z ; ATL::CComPtrBase<ISampleGrabber>::CoCreateInstance
  00144	89 45 98	 mov	 DWORD PTR _hr$[ebp], eax

; 107  : 	if( !m_pGrabber ){

  00147	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  0014a	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  00150	e8 00 00 00 00	 call	 ??7?$CComPtrBase@UISampleGrabber@@@ATL@@QBE_NXZ ; ATL::CComPtrBase<ISampleGrabber>::operator!
  00155	0f b6 c8	 movzx	 ecx, al
  00158	85 c9		 test	 ecx, ecx
  0015a	74 17		 je	 SHORT $LN5@Init

; 108  : 		AfxMessageBox(_T("Fail to create SampleGrabber, maybe qedit.dll is not registered?"));

  0015c	6a 00		 push	 0
  0015e	6a 00		 push	 0
  00160	68 00 00 00 00	 push	 OFFSET $SG4294962988
  00165	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?AfxMessageBox@@YGHPBDII@Z

; 109  : 		return hr;

  0016b	8b 45 98	 mov	 eax, DWORD PTR _hr$[ebp]
  0016e	e9 5d 03 00 00	 jmp	 $LN10@Init
$LN5@Init:

; 110  : 	}
; 111  : 	CComQIPtr< IBaseFilter, &IID_IBaseFilter > pGrabBase( m_pGrabber );

  00173	6a 01		 push	 1
  00175	8d 4d ec	 lea	 ecx, DWORD PTR _pGrabBase$[ebp]
  00178	e8 00 00 00 00	 call	 ?__autoclassinit@?$CComQIPtr@UIBaseFilter@@$1?IID_IBaseFilter@@3U_GUID@@B@ATL@@QAEXI@Z
  0017d	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00180	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  00186	e8 00 00 00 00	 call	 ??B?$CComPtrBase@UISampleGrabber@@@ATL@@QBEPAUISampleGrabber@@XZ ; ATL::CComPtrBase<ISampleGrabber>::operator ISampleGrabber *
  0018b	50		 push	 eax
  0018c	8d 4d ec	 lea	 ecx, DWORD PTR _pGrabBase$[ebp]
  0018f	e8 00 00 00 00	 call	 ??0?$CComQIPtr@UIBaseFilter@@$1?IID_IBaseFilter@@3U_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z ; ATL::CComQIPtr<IBaseFilter,&IID_IBaseFilter>::CComQIPtr<IBaseFilter,&IID_IBaseFilter>
  00194	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 112  : 
; 113  : 	//CMediaType VideoType;
; 114  : 	//设置视频格式
; 115  : 	AM_MEDIA_TYPE mt; 
; 116  : 	ZeroMemory(&mt, sizeof(AM_MEDIA_TYPE));

  0019b	6a 48		 push	 72			; 00000048H
  0019d	6a 00		 push	 0
  0019f	8d 55 9c	 lea	 edx, DWORD PTR _mt$[ebp]
  001a2	52		 push	 edx
  001a3	e8 00 00 00 00	 call	 _memset
  001a8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 117  : 	mt.majortype = MEDIATYPE_Video;

  001ab	a1 00 00 00 00	 mov	 eax, DWORD PTR _MEDIATYPE_Video
  001b0	89 45 9c	 mov	 DWORD PTR _mt$[ebp], eax
  001b3	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _MEDIATYPE_Video+4
  001b9	89 4d a0	 mov	 DWORD PTR _mt$[ebp+4], ecx
  001bc	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _MEDIATYPE_Video+8
  001c2	89 55 a4	 mov	 DWORD PTR _mt$[ebp+8], edx
  001c5	a1 0c 00 00 00	 mov	 eax, DWORD PTR _MEDIATYPE_Video+12
  001ca	89 45 a8	 mov	 DWORD PTR _mt$[ebp+12], eax

; 118  : 	mt.subtype = MEDIASUBTYPE_RGB24;

  001cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _MEDIASUBTYPE_RGB24
  001d3	89 4d ac	 mov	 DWORD PTR _mt$[ebp+16], ecx
  001d6	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _MEDIASUBTYPE_RGB24+4
  001dc	89 55 b0	 mov	 DWORD PTR _mt$[ebp+20], edx
  001df	a1 08 00 00 00	 mov	 eax, DWORD PTR _MEDIASUBTYPE_RGB24+8
  001e4	89 45 b4	 mov	 DWORD PTR _mt$[ebp+24], eax
  001e7	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR _MEDIASUBTYPE_RGB24+12
  001ed	89 4d b8	 mov	 DWORD PTR _mt$[ebp+28], ecx

; 119  : 	hr = m_pGrabber->SetMediaType(&mt);

  001f0	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  001f3	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  001f9	e8 00 00 00 00	 call	 ??C?$CComPtrBase@UISampleGrabber@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UISampleGrabber@@@1@XZ ; ATL::CComPtrBase<ISampleGrabber>::operator->
  001fe	89 45 80	 mov	 DWORD PTR tv200[ebp], eax
  00201	8d 55 9c	 lea	 edx, DWORD PTR _mt$[ebp]
  00204	52		 push	 edx
  00205	8b 45 80	 mov	 eax, DWORD PTR tv200[ebp]
  00208	50		 push	 eax
  00209	8b 4d 80	 mov	 ecx, DWORD PTR tv200[ebp]
  0020c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0020e	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00211	ff d0		 call	 eax
  00213	89 45 98	 mov	 DWORD PTR _hr$[ebp], eax

; 120  : 
; 121  : 	if( FAILED( hr ) ){

  00216	83 7d 98 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0021a	7d 32		 jge	 SHORT $LN4@Init

; 122  : 		AfxMessageBox(_T("Fail to set media type!"));

  0021c	6a 00		 push	 0
  0021e	6a 00		 push	 0
  00220	68 00 00 00 00	 push	 OFFSET $SG4294962987
  00225	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?AfxMessageBox@@YGHPBDII@Z

; 123  : 		return hr;

  0022b	8b 4d 98	 mov	 ecx, DWORD PTR _hr$[ebp]
  0022e	89 8d 78 ff ff
	ff		 mov	 DWORD PTR $T6[ebp], ecx
  00234	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0023b	8d 4d ec	 lea	 ecx, DWORD PTR _pGrabBase$[ebp]
  0023e	e8 00 00 00 00	 call	 ??1?$CComQIPtr@UIBaseFilter@@$1?IID_IBaseFilter@@3U_GUID@@B@ATL@@QAE@XZ
  00243	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR $T6[ebp]
  00249	e9 82 02 00 00	 jmp	 $LN10@Init
$LN4@Init:

; 124  : 	}
; 125  : 	hr = m_pGraph->AddFilter( pGrabBase, L"Grabber" );

  0024e	68 00 00 00 00	 push	 OFFSET $SG4294962986
  00253	8d 4d ec	 lea	 ecx, DWORD PTR _pGrabBase$[ebp]
  00256	e8 00 00 00 00	 call	 ??B?$CComPtrBase@UIBaseFilter@@@ATL@@QBEPAUIBaseFilter@@XZ ; ATL::CComPtrBase<IBaseFilter>::operator IBaseFilter *
  0025b	50		 push	 eax
  0025c	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  0025f	8b 82 cc 00 00
	00		 mov	 eax, DWORD PTR [edx+204]
  00265	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00268	8b 91 cc 00 00
	00		 mov	 edx, DWORD PTR [ecx+204]
  0026e	8b 00		 mov	 eax, DWORD PTR [eax]
  00270	52		 push	 edx
  00271	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00274	ff d1		 call	 ecx
  00276	89 45 98	 mov	 DWORD PTR _hr$[ebp], eax

; 126  : 	if( FAILED( hr ) ){

  00279	83 7d 98 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0027d	7d 32		 jge	 SHORT $LN3@Init

; 127  : 		AfxMessageBox(_T("Fail to put sample grabber in graph"));

  0027f	6a 00		 push	 0
  00281	6a 00		 push	 0
  00283	68 00 00 00 00	 push	 OFFSET $SG4294962985
  00288	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?AfxMessageBox@@YGHPBDII@Z

; 128  : 		return hr;

  0028e	8b 55 98	 mov	 edx, DWORD PTR _hr$[ebp]
  00291	89 95 68 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], edx
  00297	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0029e	8d 4d ec	 lea	 ecx, DWORD PTR _pGrabBase$[ebp]
  002a1	e8 00 00 00 00	 call	 ??1?$CComQIPtr@UIBaseFilter@@$1?IID_IBaseFilter@@3U_GUID@@B@ATL@@QAE@XZ
  002a6	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  002ac	e9 1f 02 00 00	 jmp	 $LN10@Init
$LN3@Init:

; 129  : 	}
; 130  : 
; 131  : 	// Render the preview pin on the video capture filter
; 132  : 	// Use this instead of m_pGraph->RenderFile
; 133  : 	IBaseFilter* pNull = NULL;

  002b1	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _pNull$[ebp], 0

; 134  : 	hr = CoCreateInstance(CLSID_NullRenderer, NULL, CLSCTX_INPROC_SERVER, IID_IBaseFilter, (void**)& pNull);

  002b8	8d 45 e4	 lea	 eax, DWORD PTR _pNull$[ebp]
  002bb	50		 push	 eax
  002bc	68 00 00 00 00	 push	 OFFSET _IID_IBaseFilter
  002c1	6a 01		 push	 1
  002c3	6a 00		 push	 0
  002c5	68 00 00 00 00	 push	 OFFSET _CLSID_NullRenderer
  002ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoCreateInstance@20
  002d0	89 45 98	 mov	 DWORD PTR _hr$[ebp], eax

; 135  : 	hr = m_pGraph->AddFilter(pNull, L"NullRender");

  002d3	68 00 00 00 00	 push	 OFFSET $SG4294962984
  002d8	8b 4d e4	 mov	 ecx, DWORD PTR _pNull$[ebp]
  002db	51		 push	 ecx
  002dc	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  002df	8b 82 cc 00 00
	00		 mov	 eax, DWORD PTR [edx+204]
  002e5	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  002e8	8b 91 cc 00 00
	00		 mov	 edx, DWORD PTR [ecx+204]
  002ee	8b 00		 mov	 eax, DWORD PTR [eax]
  002f0	52		 push	 edx
  002f1	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  002f4	ff d1		 call	 ecx
  002f6	89 45 98	 mov	 DWORD PTR _hr$[ebp], eax

; 136  : 	hr = m_pCapture->RenderStream( &PIN_CATEGORY_CAPTURE, &MEDIATYPE_Video,
; 137  :                                    pSrcFilter, pGrabBase, pNull);	

  002f9	8b 55 e4	 mov	 edx, DWORD PTR _pNull$[ebp]
  002fc	52		 push	 edx
  002fd	8d 4d ec	 lea	 ecx, DWORD PTR _pGrabBase$[ebp]
  00300	e8 00 00 00 00	 call	 ??B?$CComPtrBase@UIBaseFilter@@@ATL@@QBEPAUIBaseFilter@@XZ ; ATL::CComPtrBase<IBaseFilter>::operator IBaseFilter *
  00305	50		 push	 eax
  00306	8b 45 e8	 mov	 eax, DWORD PTR _pSrcFilter$[ebp]
  00309	50		 push	 eax
  0030a	68 00 00 00 00	 push	 OFFSET _MEDIATYPE_Video
  0030f	68 00 00 00 00	 push	 OFFSET _PIN_CATEGORY_CAPTURE
  00314	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00317	8b 91 d0 00 00
	00		 mov	 edx, DWORD PTR [ecx+208]
  0031d	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  00320	8b 88 d0 00 00
	00		 mov	 ecx, DWORD PTR [eax+208]
  00326	8b 12		 mov	 edx, DWORD PTR [edx]
  00328	51		 push	 ecx
  00329	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0032c	ff d0		 call	 eax
  0032e	89 45 98	 mov	 DWORD PTR _hr$[ebp], eax

; 138  : 	
; 139  : 	hr = m_pGrabber->GetConnectedMediaType( &mt );

  00331	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00334	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  0033a	e8 00 00 00 00	 call	 ??C?$CComPtrBase@UISampleGrabber@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UISampleGrabber@@@1@XZ ; ATL::CComPtrBase<ISampleGrabber>::operator->
  0033f	89 45 88	 mov	 DWORD PTR tv288[ebp], eax
  00342	8d 4d 9c	 lea	 ecx, DWORD PTR _mt$[ebp]
  00345	51		 push	 ecx
  00346	8b 55 88	 mov	 edx, DWORD PTR tv288[ebp]
  00349	52		 push	 edx
  0034a	8b 45 88	 mov	 eax, DWORD PTR tv288[ebp]
  0034d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0034f	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00352	ff d2		 call	 edx
  00354	89 45 98	 mov	 DWORD PTR _hr$[ebp], eax

; 140  : 	if ( FAILED( hr) ){

  00357	83 7d 98 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0035b	7d 32		 jge	 SHORT $LN2@Init

; 141  : 		AfxMessageBox(_T("Failt to read the connected media type"));

  0035d	6a 00		 push	 0
  0035f	6a 00		 push	 0
  00361	68 00 00 00 00	 push	 OFFSET $SG4294962983
  00366	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?AfxMessageBox@@YGHPBDII@Z

; 142  : 		return hr;

  0036c	8b 45 98	 mov	 eax, DWORD PTR _hr$[ebp]
  0036f	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  00375	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0037c	8d 4d ec	 lea	 ecx, DWORD PTR _pGrabBase$[ebp]
  0037f	e8 00 00 00 00	 call	 ??1?$CComQIPtr@UIBaseFilter@@$1?IID_IBaseFilter@@3U_GUID@@B@ATL@@QAE@XZ
  00384	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  0038a	e9 41 01 00 00	 jmp	 $LN10@Init
$LN2@Init:

; 143  : 	}
; 144  : 
; 145  : 	VIDEOINFOHEADER * vih = (VIDEOINFOHEADER*) mt.pbFormat;

  0038f	8b 4d e0	 mov	 ecx, DWORD PTR _mt$[ebp+68]
  00392	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _vih$[ebp], ecx

; 146  : 	g_CB.lWidth = vih->bmiHeader.biWidth;		// 设置图像宽度

  00398	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  0039b	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _vih$[ebp]
  003a1	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  003a4	89 8a a8 00 00
	00		 mov	 DWORD PTR [edx+168], ecx

; 147  : 	g_CB.lHeight = vih->bmiHeader.biHeight;		// 设置图像高度

  003aa	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  003ad	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _vih$[ebp]
  003b3	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  003b6	89 8a ac 00 00
	00		 mov	 DWORD PTR [edx+172], ecx

; 148  : 
; 149  : 	//g_CB.SetIplImage();	// 创建Ipl对象
; 150  : 	FreeMediaType(mt);

  003bc	8d 55 9c	 lea	 edx, DWORD PTR _mt$[ebp]
  003bf	52		 push	 edx
  003c0	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  003c3	e8 00 00 00 00	 call	 ?FreeMediaType@CEDSCapture@@IAEXAAU_AMMediaType@@@Z ; CEDSCapture::FreeMediaType

; 151  : 	hr = m_pGrabber->SetBufferSamples(TRUE);	// 初始化Sample指针

  003c8	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  003cb	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  003d1	e8 00 00 00 00	 call	 ??C?$CComPtrBase@UISampleGrabber@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UISampleGrabber@@@1@XZ ; ATL::CComPtrBase<ISampleGrabber>::operator->
  003d6	89 45 90	 mov	 DWORD PTR tv319[ebp], eax
  003d9	6a 01		 push	 1
  003db	8b 45 90	 mov	 eax, DWORD PTR tv319[ebp]
  003de	50		 push	 eax
  003df	8b 4d 90	 mov	 ecx, DWORD PTR tv319[ebp]
  003e2	8b 11		 mov	 edx, DWORD PTR [ecx]
  003e4	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  003e7	ff d0		 call	 eax
  003e9	89 45 98	 mov	 DWORD PTR _hr$[ebp], eax

; 152  : 	hr = m_pGrabber->SetOneShot( FALSE );		// fliter接收一帧sample以后不停

  003ec	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  003ef	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  003f5	e8 00 00 00 00	 call	 ??C?$CComPtrBase@UISampleGrabber@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UISampleGrabber@@@1@XZ ; ATL::CComPtrBase<ISampleGrabber>::operator->
  003fa	89 45 8c	 mov	 DWORD PTR tv336[ebp], eax
  003fd	6a 00		 push	 0
  003ff	8b 4d 8c	 mov	 ecx, DWORD PTR tv336[ebp]
  00402	51		 push	 ecx
  00403	8b 55 8c	 mov	 edx, DWORD PTR tv336[ebp]
  00406	8b 02		 mov	 eax, DWORD PTR [edx]
  00408	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0040b	ff d1		 call	 ecx
  0040d	89 45 98	 mov	 DWORD PTR _hr$[ebp], eax

; 153  : 
; 154  : 	hr = m_pGrabber->SetCallback( &g_CB, 1 );	// 设置启动回调

  00410	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00413	81 c1 d4 00 00
	00		 add	 ecx, 212		; 000000d4H
  00419	e8 00 00 00 00	 call	 ??C?$CComPtrBase@UISampleGrabber@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UISampleGrabber@@@1@XZ ; ATL::CComPtrBase<ISampleGrabber>::operator->
  0041e	89 45 84	 mov	 DWORD PTR tv353[ebp], eax
  00421	6a 01		 push	 1
  00423	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  00426	81 c2 a4 00 00
	00		 add	 edx, 164		; 000000a4H
  0042c	52		 push	 edx
  0042d	8b 45 84	 mov	 eax, DWORD PTR tv353[ebp]
  00430	50		 push	 eax
  00431	8b 4d 84	 mov	 ecx, DWORD PTR tv353[ebp]
  00434	8b 11		 mov	 edx, DWORD PTR [ecx]
  00436	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00439	ff d0		 call	 eax
  0043b	89 45 98	 mov	 DWORD PTR _hr$[ebp], eax

; 155  : 
; 156  :     // Now that the filter has been added to the graph and we have
; 157  :     // rendered its stream, we can release this reference to the filter.
; 158  :     pSrcFilter->Release();

  0043e	8b 4d e8	 mov	 ecx, DWORD PTR _pSrcFilter$[ebp]
  00441	8b 11		 mov	 edx, DWORD PTR [ecx]
  00443	8b 45 e8	 mov	 eax, DWORD PTR _pSrcFilter$[ebp]
  00446	50		 push	 eax
  00447	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0044a	ff d1		 call	 ecx

; 159  : 
; 160  : 	// Set video window style and position
; 161  : 	// 设定窗口风格、位置大小
; 162  :     //hr = SetupVideoWindow();//设置了预览窗口
; 163  :    /* if (FAILED(hr))
; 164  :     {
; 165  :         Msg(TEXT("Couldn't initialize video window!  hr=0x%x"), hr);
; 166  : 		return hr;
; 167  : 	}*/
; 168  : 
; 169  : #ifdef REGISTER_FILTERGRAPH
; 170  :     // Add our graph to the running object table, which will allow
; 171  :     // the GraphEdit application to "spy" on our graph
; 172  :     hr = AddGraphToRot(m_pGraph, &m_dwGraphRegister);
; 173  :     if (FAILED(hr))
; 174  :     {
; 175  :         Msg(TEXT("Failed to register filter graph with ROT!  hr=0x%x"), hr);
; 176  :         m_dwGraphRegister = 0;
; 177  :     }
; 178  : #endif
; 179  : 
; 180  :     // 开始启动视频预览 Start previewing video data
; 181  :     hr = m_pMC->Run();

  0044c	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  0044f	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  00455	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00458	8b 91 c4 00 00
	00		 mov	 edx, DWORD PTR [ecx+196]
  0045e	8b 00		 mov	 eax, DWORD PTR [eax]
  00460	52		 push	 edx
  00461	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00464	ff d1		 call	 ecx
  00466	89 45 98	 mov	 DWORD PTR _hr$[ebp], eax

; 182  :     if (FAILED(hr)) {

  00469	83 7d 98 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0046d	7d 35		 jge	 SHORT $LN1@Init

; 183  :         Msg(TEXT("Couldn't run the graph!  hr=0x%x"), hr);

  0046f	8b 55 98	 mov	 edx, DWORD PTR _hr$[ebp]
  00472	52		 push	 edx
  00473	68 00 00 00 00	 push	 OFFSET $SG4294962982
  00478	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  0047b	50		 push	 eax
  0047c	e8 00 00 00 00	 call	 ?Msg@CEDSCapture@@IAAXPADZZ ; CEDSCapture::Msg
  00481	83 c4 0c	 add	 esp, 12			; 0000000cH

; 184  :         return hr;

  00484	8b 4d 98	 mov	 ecx, DWORD PTR _hr$[ebp]
  00487	89 8d 74 ff ff
	ff		 mov	 DWORD PTR $T5[ebp], ecx
  0048d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00494	8d 4d ec	 lea	 ecx, DWORD PTR _pGrabBase$[ebp]
  00497	e8 00 00 00 00	 call	 ??1?$CComQIPtr@UIBaseFilter@@$1?IID_IBaseFilter@@3U_GUID@@B@ATL@@QAE@XZ
  0049c	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR $T5[ebp]
  004a2	eb 2c		 jmp	 SHORT $LN10@Init
$LN1@Init:

; 185  :     }	
; 186  : 
; 187  :     // 记下当前状态
; 188  :     m_psCurrent = Running;

  004a4	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  004a7	c7 82 94 00 00
	00 02 00 00 00	 mov	 DWORD PTR [edx+148], 2

; 189  :     return S_OK;

  004b1	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  004bb	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  004c2	8d 4d ec	 lea	 ecx, DWORD PTR _pGrabBase$[ebp]
  004c5	e8 00 00 00 00	 call	 ??1?$CComQIPtr@UIBaseFilter@@$1?IID_IBaseFilter@@3U_GUID@@B@ATL@@QAE@XZ
  004ca	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR $T4[ebp]
$LN10@Init:

; 190  : }

  004d0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  004d3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  004da	59		 pop	 ecx
  004db	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004de	33 cd		 xor	 ecx, ebp
  004e0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004e5	8b e5		 mov	 esp, ebp
  004e7	5d		 pop	 ebp
  004e8	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Init@CEDSCapture@@QAEJHPAUHWND__@@@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR _pGrabBase$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CComQIPtr@UIBaseFilter@@$1?IID_IBaseFilter@@3U_GUID@@B@ATL@@QAE@XZ
__ehhandler$?Init@CEDSCapture@@QAEJHPAUHWND__@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 70 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-144]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Init@CEDSCapture@@QAEJHPAUHWND__@@@Z
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Init@CEDSCapture@@QAEJHPAUHWND__@@@Z ENDP		; CEDSCapture::Init
; Function compile flags: /Odtp
;	COMDAT ??1?$CComQIPtr@UIBaseFilter@@$1?IID_IBaseFilter@@3U_GUID@@B@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CComQIPtr@UIBaseFilter@@$1?IID_IBaseFilter@@3U_GUID@@B@ATL@@QAE@XZ PROC ; ATL::CComQIPtr<IBaseFilter,&IID_IBaseFilter>::~CComQIPtr<IBaseFilter,&IID_IBaseFilter>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CComPtr@UIBaseFilter@@@ATL@@QAE@XZ
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$CComQIPtr@UIBaseFilter@@$1?IID_IBaseFilter@@3U_GUID@@B@ATL@@QAE@XZ ENDP ; ATL::CComQIPtr<IBaseFilter,&IID_IBaseFilter>::~CComQIPtr<IBaseFilter,&IID_IBaseFilter>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit@?$CComQIPtr@UIBaseFilter@@$1?IID_IBaseFilter@@3U_GUID@@B@ATL@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_$initVBases$ = 8					; size = 4
?__autoclassinit@?$CComQIPtr@UIBaseFilter@@$1?IID_IBaseFilter@@3U_GUID@@B@ATL@@QAEXI@Z PROC ; ATL::CComQIPtr<IBaseFilter,&IID_IBaseFilter>::__autoclassinit, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?__autoclassinit@?$CComPtr@UIBaseFilter@@@ATL@@QAEXI@Z
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?__autoclassinit@?$CComQIPtr@UIBaseFilter@@$1?IID_IBaseFilter@@3U_GUID@@B@ATL@@QAEXI@Z ENDP ; ATL::CComQIPtr<IBaseFilter,&IID_IBaseFilter>::__autoclassinit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$CComPtr@UIBaseFilter@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CComPtr@UIBaseFilter@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<IBaseFilter>::~CComPtr<IBaseFilter>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CComPtrBase@UIBaseFilter@@@ATL@@QAE@XZ ; ATL::CComPtrBase<IBaseFilter>::~CComPtrBase<IBaseFilter>
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$CComPtr@UIBaseFilter@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<IBaseFilter>::~CComPtr<IBaseFilter>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit@?$CComPtr@UIBaseFilter@@@ATL@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_$initVBases$ = 8					; size = 4
?__autoclassinit@?$CComPtr@UIBaseFilter@@@ATL@@QAEXI@Z PROC ; ATL::CComPtr<IBaseFilter>::__autoclassinit, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?__autoclassinit@?$CComPtrBase@UIBaseFilter@@@ATL@@QAEXI@Z
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?__autoclassinit@?$CComPtr@UIBaseFilter@@@ATL@@QAEXI@Z ENDP ; ATL::CComPtr<IBaseFilter>::__autoclassinit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit@?$CComPtrBase@UIBaseFilter@@@ATL@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_$initVBases$ = 8					; size = 4
?__autoclassinit@?$CComPtrBase@UIBaseFilter@@@ATL@@QAEXI@Z PROC ; ATL::CComPtrBase<IBaseFilter>::__autoclassinit, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?__autoclassinit@?$CComPtrBase@UIBaseFilter@@@ATL@@QAEXI@Z ENDP ; ATL::CComPtrBase<IBaseFilter>::__autoclassinit
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\edscapture.cpp
;	COMDAT ?Pause@CEDSCapture@@QAEXXZ
_TEXT	SEGMENT
tv78 = -20						; size = 4
_this$ = -16						; size = 4
_hr$1 = -12						; size = 4
_t_State$2 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?Pause@CEDSCapture@@QAEXXZ PROC				; CEDSCapture::Pause, COMDAT
; _this$ = ecx

; 194  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 195  : 	if( m_pMC ) {

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 b8 c4 00 00
	00 00		 cmp	 DWORD PTR [eax+196], 0
  0001d	0f 84 82 00 00
	00		 je	 $LN10@Pause

; 196  : 		OAFilterState t_State;
; 197  : 		HRESULT hr = m_pMC->GetState(10, &t_State);

  00023	8d 4d f8	 lea	 ecx, DWORD PTR _t_State$2[ebp]
  00026	51		 push	 ecx
  00027	6a 0a		 push	 10			; 0000000aH
  00029	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	8b 91 c4 00 00
	00		 mov	 edx, DWORD PTR [ecx+196]
  0003b	8b 00		 mov	 eax, DWORD PTR [eax]
  0003d	52		 push	 edx
  0003e	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00041	ff d1		 call	 ecx
  00043	89 45 f4	 mov	 DWORD PTR _hr$1[ebp], eax

; 198  : 		if (hr == S_OK || hr == VFW_S_CANT_CUE) {

  00046	83 7d f4 00	 cmp	 DWORD PTR _hr$1[ebp], 0
  0004a	74 09		 je	 SHORT $LN7@Pause
  0004c	81 7d f4 68 02
	04 00		 cmp	 DWORD PTR _hr$1[ebp], 262760 ; 00040268H
  00053	75 50		 jne	 SHORT $LN10@Pause
$LN7@Pause:

; 199  : 			hr = E_FAIL;

  00055	c7 45 f4 05 40
	00 80		 mov	 DWORD PTR _hr$1[ebp], -2147467259 ; 80004005H

; 200  : 			switch (t_State)

  0005c	8b 55 f8	 mov	 edx, DWORD PTR _t_State$2[ebp]
  0005f	89 55 ec	 mov	 DWORD PTR tv78[ebp], edx
  00062	83 7d ec 00	 cmp	 DWORD PTR tv78[ebp], 0
  00066	74 36		 je	 SHORT $LN2@Pause
  00068	83 7d ec 01	 cmp	 DWORD PTR tv78[ebp], 1
  0006c	74 27		 je	 SHORT $LN3@Pause
  0006e	83 7d ec 02	 cmp	 DWORD PTR tv78[ebp], 2
  00072	74 02		 je	 SHORT $LN4@Pause
  00074	eb 2f		 jmp	 SHORT $LN10@Pause
$LN4@Pause:

; 201  : 			{
; 202  : 			case State_Running:
; 203  : 				hr = m_pMC->Pause();

  00076	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00079	8b 88 c4 00 00
	00		 mov	 ecx, DWORD PTR [eax+196]
  0007f	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00082	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  00088	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0008a	50		 push	 eax
  0008b	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0008e	ff d2		 call	 edx
  00090	89 45 f4	 mov	 DWORD PTR _hr$1[ebp], eax

; 204  : 				break;

  00093	eb 10		 jmp	 SHORT $LN10@Pause
$LN3@Pause:

; 205  : 			case State_Paused:
; 206  : 				hr = S_FALSE;

  00095	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _hr$1[ebp], 1

; 207  : 				break;

  0009c	eb 07		 jmp	 SHORT $LN10@Pause
$LN2@Pause:

; 208  : 			case State_Stopped:
; 209  : 				hr = S_FALSE;

  0009e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _hr$1[ebp], 1
$LN10@Pause:

; 210  : 			default:
; 211  : 				break;
; 212  : 			}
; 213  : 		}
; 214  : 	}
; 215  : }

  000a5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a8	33 cd		 xor	 ecx, ebp
  000aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
?Pause@CEDSCapture@@QAEXXZ ENDP				; CEDSCapture::Pause
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\edscapture.cpp
;	COMDAT ?Run@CEDSCapture@@QAEXXZ
_TEXT	SEGMENT
tv78 = -20						; size = 4
_hr$1 = -16						; size = 4
_this$ = -12						; size = 4
_t_State$2 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?Run@CEDSCapture@@QAEXXZ PROC				; CEDSCapture::Run, COMDAT
; _this$ = ecx

; 219  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 220  : 	if( m_pMC ) {

  00013	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 b8 c4 00 00
	00 00		 cmp	 DWORD PTR [eax+196], 0
  0001d	0f 84 8b 00 00
	00		 je	 $LN10@Run

; 221  : 		OAFilterState t_State;
; 222  : 		HRESULT hr = m_pMC->GetState(10, &t_State);

  00023	8d 4d f8	 lea	 ecx, DWORD PTR _t_State$2[ebp]
  00026	51		 push	 ecx
  00027	6a 0a		 push	 10			; 0000000aH
  00029	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  00032	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	8b 91 c4 00 00
	00		 mov	 edx, DWORD PTR [ecx+196]
  0003b	8b 00		 mov	 eax, DWORD PTR [eax]
  0003d	52		 push	 edx
  0003e	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00041	ff d1		 call	 ecx
  00043	89 45 f0	 mov	 DWORD PTR _hr$1[ebp], eax

; 223  : 		if (hr == S_OK || hr == VFW_S_CANT_CUE) {

  00046	83 7d f0 00	 cmp	 DWORD PTR _hr$1[ebp], 0
  0004a	74 09		 je	 SHORT $LN7@Run
  0004c	81 7d f0 68 02
	04 00		 cmp	 DWORD PTR _hr$1[ebp], 262760 ; 00040268H
  00053	75 59		 jne	 SHORT $LN10@Run
$LN7@Run:

; 224  : 			hr = E_FAIL;

  00055	c7 45 f0 05 40
	00 80		 mov	 DWORD PTR _hr$1[ebp], -2147467259 ; 80004005H

; 225  : 			switch (t_State)

  0005c	8b 55 f8	 mov	 edx, DWORD PTR _t_State$2[ebp]
  0005f	89 55 ec	 mov	 DWORD PTR tv78[ebp], edx
  00062	83 7d ec 00	 cmp	 DWORD PTR tv78[ebp], 0
  00066	74 29		 je	 SHORT $LN2@Run
  00068	83 7d ec 01	 cmp	 DWORD PTR tv78[ebp], 1
  0006c	74 04		 je	 SHORT $LN3@Run
  0006e	eb 3e		 jmp	 SHORT $LN10@Run

; 226  : 			{
; 227  : 			case State_Running:
; 228  : 				break;

  00070	eb 3c		 jmp	 SHORT $LN10@Run
$LN3@Run:

; 229  : 			case State_Paused:
; 230  : 				hr = m_pMC->Run();

  00072	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00075	8b 88 c4 00 00
	00		 mov	 ecx, DWORD PTR [eax+196]
  0007b	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0007e	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  00084	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00086	50		 push	 eax
  00087	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0008a	ff d2		 call	 edx
  0008c	89 45 f0	 mov	 DWORD PTR _hr$1[ebp], eax

; 231  : 				break;

  0008f	eb 1d		 jmp	 SHORT $LN10@Run
$LN2@Run:

; 232  : 			case State_Stopped:
; 233  : 				hr = m_pMC->Run();

  00091	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00094	8b 88 c4 00 00
	00		 mov	 ecx, DWORD PTR [eax+196]
  0009a	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0009d	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  000a3	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000a5	50		 push	 eax
  000a6	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000a9	ff d2		 call	 edx
  000ab	89 45 f0	 mov	 DWORD PTR _hr$1[ebp], eax
$LN10@Run:

; 234  : 				break;
; 235  : 			default:
; 236  : 				break;
; 237  : 			}
; 238  : 		}
; 239  : 	}
; 240  : }

  000ae	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b1	33 cd		 xor	 ecx, ebp
  000b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c3		 ret	 0
?Run@CEDSCapture@@QAEXXZ ENDP				; CEDSCapture::Run
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\edscapture.cpp
;	COMDAT ?Stop@CEDSCapture@@QAEXXZ
_TEXT	SEGMENT
tv78 = -20						; size = 4
_hr$1 = -16						; size = 4
_this$ = -12						; size = 4
_t_State$2 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?Stop@CEDSCapture@@QAEXXZ PROC				; CEDSCapture::Stop, COMDAT
; _this$ = ecx

; 242  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 243  : 	if (m_pMC) {

  00013	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 b8 c4 00 00
	00 00		 cmp	 DWORD PTR [eax+196], 0
  0001d	0f 84 89 00 00
	00		 je	 $LN10@Stop

; 244  : 		OAFilterState t_State;
; 245  : 		HRESULT hr = m_pMC->GetState(10, &t_State);

  00023	8d 4d f8	 lea	 ecx, DWORD PTR _t_State$2[ebp]
  00026	51		 push	 ecx
  00027	6a 0a		 push	 10			; 0000000aH
  00029	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  00032	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	8b 91 c4 00 00
	00		 mov	 edx, DWORD PTR [ecx+196]
  0003b	8b 00		 mov	 eax, DWORD PTR [eax]
  0003d	52		 push	 edx
  0003e	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00041	ff d1		 call	 ecx
  00043	89 45 f0	 mov	 DWORD PTR _hr$1[ebp], eax

; 246  : 		if (hr == S_OK || hr == VFW_S_CANT_CUE) {

  00046	83 7d f0 00	 cmp	 DWORD PTR _hr$1[ebp], 0
  0004a	74 09		 je	 SHORT $LN7@Stop
  0004c	81 7d f0 68 02
	04 00		 cmp	 DWORD PTR _hr$1[ebp], 262760 ; 00040268H
  00053	75 57		 jne	 SHORT $LN10@Stop
$LN7@Stop:

; 247  : 			hr = E_FAIL;

  00055	c7 45 f0 05 40
	00 80		 mov	 DWORD PTR _hr$1[ebp], -2147467259 ; 80004005H

; 248  : 			switch (t_State)

  0005c	8b 55 f8	 mov	 edx, DWORD PTR _t_State$2[ebp]
  0005f	89 55 ec	 mov	 DWORD PTR tv78[ebp], edx
  00062	83 7d ec 01	 cmp	 DWORD PTR tv78[ebp], 1
  00066	74 27		 je	 SHORT $LN3@Stop
  00068	83 7d ec 02	 cmp	 DWORD PTR tv78[ebp], 2
  0006c	74 02		 je	 SHORT $LN4@Stop
  0006e	eb 3c		 jmp	 SHORT $LN10@Stop
$LN4@Stop:

; 249  : 			{
; 250  : 			case State_Running:
; 251  : 				hr = m_pMC->Stop();

  00070	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 88 c4 00 00
	00		 mov	 ecx, DWORD PTR [eax+196]
  00079	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  00082	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00084	50		 push	 eax
  00085	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00088	ff d2		 call	 edx
  0008a	89 45 f0	 mov	 DWORD PTR _hr$1[ebp], eax

; 252  : 				break;

  0008d	eb 1d		 jmp	 SHORT $LN10@Stop
$LN3@Stop:

; 253  : 			case State_Paused:
; 254  : 				hr = m_pMC->Stop();

  0008f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00092	8b 88 c4 00 00
	00		 mov	 ecx, DWORD PTR [eax+196]
  00098	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0009b	8b 82 c4 00 00
	00		 mov	 eax, DWORD PTR [edx+196]
  000a1	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000a3	50		 push	 eax
  000a4	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000a7	ff d2		 call	 edx
  000a9	89 45 f0	 mov	 DWORD PTR _hr$1[ebp], eax
$LN10@Stop:

; 255  : 				break;
; 256  : 			case State_Stopped:
; 257  : 				break;
; 258  : 			default:
; 259  : 				break;
; 260  : 			}
; 261  : 		}
; 262  : 	}
; 263  : }

  000ac	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000af	33 cd		 xor	 ecx, ebp
  000b1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
?Stop@CEDSCapture@@QAEXXZ ENDP				; CEDSCapture::Stop
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\edscapture.cpp
;	COMDAT ?Msg@CEDSCapture@@IAAXPADZZ
_TEXT	SEGMENT
_LASTCHAR$ = -1044					; size = 4
_NUMCHARS$ = -1040					; size = 4
_pArgs$ = -1036						; size = 4
$T1 = -1032						; size = 4
_szBuffer$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
_szFormat$ = 12						; size = 4
?Msg@CEDSCapture@@IAAXPADZZ PROC			; CEDSCapture::Msg, COMDAT

; 302  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 04 00
	00		 sub	 esp, 1044		; 00000414H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 303  :     TCHAR szBuffer[1024];  // Large buffer for long filenames or URLs
; 304  :     const size_t NUMCHARS = sizeof(szBuffer) / sizeof(szBuffer[0]);

  00013	c7 85 f0 fb ff
	ff 00 04 00 00	 mov	 DWORD PTR _NUMCHARS$[ebp], 1024 ; 00000400H

; 305  :     const int LASTCHAR = NUMCHARS - 1;

  0001d	c7 85 ec fb ff
	ff ff 03 00 00	 mov	 DWORD PTR _LASTCHAR$[ebp], 1023 ; 000003ffH

; 306  : 
; 307  :     // Format the input string
; 308  :     va_list pArgs;
; 309  :     va_start(pArgs, szFormat);

  00027	8d 45 10	 lea	 eax, DWORD PTR _szFormat$[ebp+4]
  0002a	89 85 f4 fb ff
	ff		 mov	 DWORD PTR _pArgs$[ebp], eax

; 310  : 
; 311  :     // Use a bounded buffer size to prevent buffer overruns.  Limit count to
; 312  :     // character size minus one to allow for a NULL terminating character.
; 313  :     _vsntprintf_s(szBuffer, NUMCHARS - 1, szFormat, pArgs);

  00030	8b 8d f4 fb ff
	ff		 mov	 ecx, DWORD PTR _pArgs$[ebp]
  00036	51		 push	 ecx
  00037	8b 55 0c	 mov	 edx, DWORD PTR _szFormat$[ebp]
  0003a	52		 push	 edx
  0003b	68 ff 03 00 00	 push	 1023			; 000003ffH
  00040	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$_vsnprintf_s@$0EAA@@@YAHAAY0EAA@DIPBDPAD@Z ; _vsnprintf_s<1024>
  0004c	83 c4 10	 add	 esp, 16			; 00000010H

; 314  :     va_end(pArgs);

  0004f	c7 85 f4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _pArgs$[ebp], 0

; 315  : 
; 316  :     // Ensure that the formatted string is NULL-terminated
; 317  :     szBuffer[LASTCHAR] = TEXT('\0');

  00059	b9 01 00 00 00	 mov	 ecx, 1
  0005e	69 c9 ff 03 00
	00		 imul	 ecx, 1023		; 000003ffH
  00064	89 8d f8 fb ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  0006a	81 bd f8 fb ff
	ff 00 04 00 00	 cmp	 DWORD PTR $T1[ebp], 1024 ; 00000400H
  00074	73 02		 jae	 SHORT $LN3@Msg
  00076	eb 05		 jmp	 SHORT $LN4@Msg
$LN3@Msg:
  00078	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN4@Msg:
  0007d	8b 95 f8 fb ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  00083	c6 84 15 fc fb
	ff ff 00	 mov	 BYTE PTR _szBuffer$[ebp+edx], 0

; 318  : 
; 319  :     MessageBox( szBuffer, TEXT("PlayCap Message"), MB_OK | MB_ICONERROR);

  0008b	6a 10		 push	 16			; 00000010H
  0008d	68 00 00 00 00	 push	 OFFSET $SG4294962981
  00092	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  00098	50		 push	 eax
  00099	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?MessageBoxA@CWnd@@QAEHPBD0I@Z
$LN2@Msg:

; 320  : }

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a5	33 cd		 xor	 ecx, ebp
  000a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
?Msg@CEDSCapture@@IAAXPADZZ ENDP			; CEDSCapture::Msg
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\edscapture.cpp
;	COMDAT ?FindCaptureDevice@CEDSCapture@@IAEJPAPAUIBaseFilter@@@Z
_TEXT	SEGMENT
$T2 = -112						; size = 4
$T3 = -108						; size = 4
$T4 = -104						; size = 4
$T5 = -100						; size = 4
$T6 = -96						; size = 4
$T7 = -92						; size = 4
$T8 = -88						; size = 4
$T9 = -84						; size = 4
tv142 = -80						; size = 4
tv212 = -76						; size = 4
tv187 = -72						; size = 4
tv232 = -68						; size = 4
_this$ = -64						; size = 4
_hr$ = -60						; size = 4
_pSrc$ = -56						; size = 4
_t_pPropBag$10 = -52					; size = 4
_t_strName$11 = -48					; size = 16
_cFetched$ = -32					; size = 4
_pDevEnum$ = -28					; size = 4
_pClassEnum$ = -24					; size = 4
_pMoniker$ = -20					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_ppSrcFilter$ = 8					; size = 4
?FindCaptureDevice@CEDSCapture@@IAEJPAPAUIBaseFilter@@@Z PROC ; CEDSCapture::FindCaptureDevice, COMDAT
; _this$ = ecx

; 370  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?FindCaptureDevice@CEDSCapture@@IAEJPAPAUIBaseFilter@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 64	 sub	 esp, 100		; 00000064H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d c0	 mov	 DWORD PTR _this$[ebp], ecx

; 371  :     HRESULT hr;
; 372  :     IBaseFilter * pSrc = NULL;

  0002b	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _pSrc$[ebp], 0

; 373  :     CComPtr <IMoniker> pMoniker =NULL;

  00032	6a 01		 push	 1
  00034	8d 4d ec	 lea	 ecx, DWORD PTR _pMoniker$[ebp]
  00037	e8 00 00 00 00	 call	 ?__autoclassinit@?$CComPtr@UIMoniker@@@ATL@@QAEXI@Z
  0003c	6a 00		 push	 0
  0003e	8d 4d ec	 lea	 ecx, DWORD PTR _pMoniker$[ebp]
  00041	e8 00 00 00 00	 call	 ??0?$CComPtr@UIMoniker@@@ATL@@QAE@PAUIMoniker@@@Z ; ATL::CComPtr<IMoniker>::CComPtr<IMoniker>
  00046	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 374  :     ULONG cFetched;
; 375  : 
; 376  :     if (!ppSrcFilter)

  0004d	83 7d 08 00	 cmp	 DWORD PTR _ppSrcFilter$[ebp], 0
  00051	75 1e		 jne	 SHORT $LN8@FindCaptur

; 377  :         return E_POINTER;

  00053	c7 45 90 03 40
	00 80		 mov	 DWORD PTR $T2[ebp], -2147467261 ; 80004003H
  0005a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00061	8d 4d ec	 lea	 ecx, DWORD PTR _pMoniker$[ebp]
  00064	e8 00 00 00 00	 call	 ??1?$CComPtr@UIMoniker@@@ATL@@QAE@XZ
  00069	8b 45 90	 mov	 eax, DWORD PTR $T2[ebp]
  0006c	e9 16 03 00 00	 jmp	 $LN9@FindCaptur
$LN8@FindCaptur:

; 378  :    
; 379  :     // Create the system device enumerator
; 380  :     CComPtr <ICreateDevEnum> pDevEnum =NULL;

  00071	6a 01		 push	 1
  00073	8d 4d e4	 lea	 ecx, DWORD PTR _pDevEnum$[ebp]
  00076	e8 00 00 00 00	 call	 ?__autoclassinit@?$CComPtr@UICreateDevEnum@@@ATL@@QAEXI@Z
  0007b	6a 00		 push	 0
  0007d	8d 4d e4	 lea	 ecx, DWORD PTR _pDevEnum$[ebp]
  00080	e8 00 00 00 00	 call	 ??0?$CComPtr@UICreateDevEnum@@@ATL@@QAE@PAUICreateDevEnum@@@Z ; ATL::CComPtr<ICreateDevEnum>::CComPtr<ICreateDevEnum>
  00085	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 381  : 
; 382  :     hr = CoCreateInstance (CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC,
; 383  :                            IID_ICreateDevEnum, (void **) &pDevEnum);

  00089	8d 4d e4	 lea	 ecx, DWORD PTR _pDevEnum$[ebp]
  0008c	e8 00 00 00 00	 call	 ??I?$CComPtrBase@UICreateDevEnum@@@ATL@@QAEPAPAUICreateDevEnum@@XZ ; ATL::CComPtrBase<ICreateDevEnum>::operator&
  00091	50		 push	 eax
  00092	68 00 00 00 00	 push	 OFFSET _IID_ICreateDevEnum
  00097	6a 03		 push	 3
  00099	6a 00		 push	 0
  0009b	68 00 00 00 00	 push	 OFFSET _CLSID_SystemDeviceEnum
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoCreateInstance@20
  000a6	89 45 c4	 mov	 DWORD PTR _hr$[ebp], eax

; 384  :     if (FAILED(hr))

  000a9	83 7d c4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000ad	7d 3e		 jge	 SHORT $LN7@FindCaptur

; 385  :     {
; 386  :         Msg(TEXT("Couldn't create system enumerator!  hr=0x%x"), hr);

  000af	8b 45 c4	 mov	 eax, DWORD PTR _hr$[ebp]
  000b2	50		 push	 eax
  000b3	68 00 00 00 00	 push	 OFFSET $SG4294962980
  000b8	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	51		 push	 ecx
  000bc	e8 00 00 00 00	 call	 ?Msg@CEDSCapture@@IAAXPADZZ ; CEDSCapture::Msg
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 387  :         return hr;

  000c4	8b 55 c4	 mov	 edx, DWORD PTR _hr$[ebp]
  000c7	89 55 98	 mov	 DWORD PTR $T4[ebp], edx
  000ca	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000ce	8d 4d e4	 lea	 ecx, DWORD PTR _pDevEnum$[ebp]
  000d1	e8 00 00 00 00	 call	 ??1?$CComPtr@UICreateDevEnum@@@ATL@@QAE@XZ
  000d6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000dd	8d 4d ec	 lea	 ecx, DWORD PTR _pMoniker$[ebp]
  000e0	e8 00 00 00 00	 call	 ??1?$CComPtr@UIMoniker@@@ATL@@QAE@XZ
  000e5	8b 45 98	 mov	 eax, DWORD PTR $T4[ebp]
  000e8	e9 9a 02 00 00	 jmp	 $LN9@FindCaptur
$LN7@FindCaptur:

; 388  :     }
; 389  : 
; 390  :     // Create an enumerator for the video capture devices
; 391  :     CComPtr <IEnumMoniker> pClassEnum = NULL;

  000ed	6a 01		 push	 1
  000ef	8d 4d e8	 lea	 ecx, DWORD PTR _pClassEnum$[ebp]
  000f2	e8 00 00 00 00	 call	 ?__autoclassinit@?$CComPtr@UIEnumMoniker@@@ATL@@QAEXI@Z
  000f7	6a 00		 push	 0
  000f9	8d 4d e8	 lea	 ecx, DWORD PTR _pClassEnum$[ebp]
  000fc	e8 00 00 00 00	 call	 ??0?$CComPtr@UIEnumMoniker@@@ATL@@QAE@PAUIEnumMoniker@@@Z ; ATL::CComPtr<IEnumMoniker>::CComPtr<IEnumMoniker>
  00101	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 392  : 
; 393  :     hr = pDevEnum->CreateClassEnumerator (CLSID_VideoInputDeviceCategory, &pClassEnum, 0);

  00105	8d 4d e4	 lea	 ecx, DWORD PTR _pDevEnum$[ebp]
  00108	e8 00 00 00 00	 call	 ??C?$CComPtrBase@UICreateDevEnum@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UICreateDevEnum@@@1@XZ ; ATL::CComPtrBase<ICreateDevEnum>::operator->
  0010d	89 45 b0	 mov	 DWORD PTR tv142[ebp], eax
  00110	6a 00		 push	 0
  00112	8d 4d e8	 lea	 ecx, DWORD PTR _pClassEnum$[ebp]
  00115	e8 00 00 00 00	 call	 ??I?$CComPtrBase@UIEnumMoniker@@@ATL@@QAEPAPAUIEnumMoniker@@XZ ; ATL::CComPtrBase<IEnumMoniker>::operator&
  0011a	50		 push	 eax
  0011b	68 00 00 00 00	 push	 OFFSET _CLSID_VideoInputDeviceCategory
  00120	8b 45 b0	 mov	 eax, DWORD PTR tv142[ebp]
  00123	50		 push	 eax
  00124	8b 4d b0	 mov	 ecx, DWORD PTR tv142[ebp]
  00127	8b 11		 mov	 edx, DWORD PTR [ecx]
  00129	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0012c	ff d0		 call	 eax
  0012e	89 45 c4	 mov	 DWORD PTR _hr$[ebp], eax

; 394  :     if (FAILED(hr))

  00131	83 7d c4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00135	7d 4a		 jge	 SHORT $LN6@FindCaptur

; 395  :     {
; 396  :         Msg(TEXT("Couldn't create class enumerator!  hr=0x%x"), hr);

  00137	8b 4d c4	 mov	 ecx, DWORD PTR _hr$[ebp]
  0013a	51		 push	 ecx
  0013b	68 00 00 00 00	 push	 OFFSET $SG4294962979
  00140	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  00143	52		 push	 edx
  00144	e8 00 00 00 00	 call	 ?Msg@CEDSCapture@@IAAXPADZZ ; CEDSCapture::Msg
  00149	83 c4 0c	 add	 esp, 12			; 0000000cH

; 397  :         return hr;

  0014c	8b 45 c4	 mov	 eax, DWORD PTR _hr$[ebp]
  0014f	89 45 ac	 mov	 DWORD PTR $T9[ebp], eax
  00152	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00156	8d 4d e8	 lea	 ecx, DWORD PTR _pClassEnum$[ebp]
  00159	e8 00 00 00 00	 call	 ??1?$CComPtr@UIEnumMoniker@@@ATL@@QAE@XZ
  0015e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00162	8d 4d e4	 lea	 ecx, DWORD PTR _pDevEnum$[ebp]
  00165	e8 00 00 00 00	 call	 ??1?$CComPtr@UICreateDevEnum@@@ATL@@QAE@XZ
  0016a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00171	8d 4d ec	 lea	 ecx, DWORD PTR _pMoniker$[ebp]
  00174	e8 00 00 00 00	 call	 ??1?$CComPtr@UIMoniker@@@ATL@@QAE@XZ
  00179	8b 45 ac	 mov	 eax, DWORD PTR $T9[ebp]
  0017c	e9 06 02 00 00	 jmp	 $LN9@FindCaptur
$LN6@FindCaptur:

; 398  :     }
; 399  : 
; 400  :     // If there are no enumerators for the requested type, then 
; 401  :     // CreateClassEnumerator will succeed, but pClassEnum will be NULL.
; 402  :     if (pClassEnum == NULL)

  00181	6a 00		 push	 0
  00183	8d 4d e8	 lea	 ecx, DWORD PTR _pClassEnum$[ebp]
  00186	e8 00 00 00 00	 call	 ??8?$CComPtrBase@UIEnumMoniker@@@ATL@@QBE_NPAUIEnumMoniker@@@Z ; ATL::CComPtrBase<IEnumMoniker>::operator==
  0018b	0f b6 c8	 movzx	 ecx, al
  0018e	85 c9		 test	 ecx, ecx
  00190	74 4b		 je	 SHORT $LN5@FindCaptur

; 403  :     {
; 404  :         MessageBox( TEXT("No video capture device was detected.\r\n\r\n")
; 405  :                    TEXT("This sample requires a video capture device, such as a USB WebCam,\r\n")
; 406  :                    TEXT("to be installed and working properly.  The sample will now close."),
; 407  :                    TEXT("No Video Capture Hardware"), MB_OK | MB_ICONINFORMATION);

  00192	6a 40		 push	 64			; 00000040H
  00194	68 00 00 00 00	 push	 OFFSET $SG4294962978
  00199	68 00 00 00 00	 push	 OFFSET $SG4294962977
  0019e	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  001a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?MessageBoxA@CWnd@@QAEHPBD0I@Z

; 408  :         return E_FAIL;

  001a7	c7 45 a4 05 40
	00 80		 mov	 DWORD PTR $T7[ebp], -2147467259 ; 80004005H
  001ae	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  001b2	8d 4d e8	 lea	 ecx, DWORD PTR _pClassEnum$[ebp]
  001b5	e8 00 00 00 00	 call	 ??1?$CComPtr@UIEnumMoniker@@@ATL@@QAE@XZ
  001ba	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  001be	8d 4d e4	 lea	 ecx, DWORD PTR _pDevEnum$[ebp]
  001c1	e8 00 00 00 00	 call	 ??1?$CComPtr@UICreateDevEnum@@@ATL@@QAE@XZ
  001c6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001cd	8d 4d ec	 lea	 ecx, DWORD PTR _pMoniker$[ebp]
  001d0	e8 00 00 00 00	 call	 ??1?$CComPtr@UIMoniker@@@ATL@@QAE@XZ
  001d5	8b 45 a4	 mov	 eax, DWORD PTR $T7[ebp]
  001d8	e9 aa 01 00 00	 jmp	 $LN9@FindCaptur
$LN5@FindCaptur:

; 409  :     }
; 410  : 
; 411  :     // Use the first video capture device on the device list.
; 412  :     // Note that if the Next() call succeeds but there are no monikers,
; 413  :     // it will return S_FALSE (which is not a failure).  Therefore, we
; 414  :     // check that the return code is S_OK instead of using SUCCEEDED() macro.
; 415  :     if (S_OK == (pClassEnum->Next (1, &pMoniker, &cFetched)))

  001dd	8d 4d e8	 lea	 ecx, DWORD PTR _pClassEnum$[ebp]
  001e0	e8 00 00 00 00	 call	 ??C?$CComPtrBase@UIEnumMoniker@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIEnumMoniker@@@1@XZ ; ATL::CComPtrBase<IEnumMoniker>::operator->
  001e5	89 45 b8	 mov	 DWORD PTR tv187[ebp], eax
  001e8	8d 55 e0	 lea	 edx, DWORD PTR _cFetched$[ebp]
  001eb	52		 push	 edx
  001ec	8d 4d ec	 lea	 ecx, DWORD PTR _pMoniker$[ebp]
  001ef	e8 00 00 00 00	 call	 ??I?$CComPtrBase@UIMoniker@@@ATL@@QAEPAPAUIMoniker@@XZ ; ATL::CComPtrBase<IMoniker>::operator&
  001f4	50		 push	 eax
  001f5	6a 01		 push	 1
  001f7	8b 45 b8	 mov	 eax, DWORD PTR tv187[ebp]
  001fa	50		 push	 eax
  001fb	8b 4d b8	 mov	 ecx, DWORD PTR tv187[ebp]
  001fe	8b 11		 mov	 edx, DWORD PTR [ecx]
  00200	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00203	ff d0		 call	 eax
  00205	85 c0		 test	 eax, eax
  00207	0f 85 42 01 00
	00		 jne	 $LN4@FindCaptur

; 416  :     {
; 417  : 		IPropertyBag* t_pPropBag = NULL;

  0020d	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _t_pPropBag$10[ebp], 0

; 418  : 		hr = pMoniker->BindToStorage(0, 0, IID_IPropertyBag, (void**)& t_pPropBag);

  00214	8d 4d ec	 lea	 ecx, DWORD PTR _pMoniker$[ebp]
  00217	e8 00 00 00 00	 call	 ??C?$CComPtrBase@UIMoniker@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIMoniker@@@1@XZ ; ATL::CComPtrBase<IMoniker>::operator->
  0021c	89 45 b4	 mov	 DWORD PTR tv212[ebp], eax
  0021f	8d 4d cc	 lea	 ecx, DWORD PTR _t_pPropBag$10[ebp]
  00222	51		 push	 ecx
  00223	68 00 00 00 00	 push	 OFFSET _IID_IPropertyBag
  00228	6a 00		 push	 0
  0022a	6a 00		 push	 0
  0022c	8b 55 b4	 mov	 edx, DWORD PTR tv212[ebp]
  0022f	52		 push	 edx
  00230	8b 45 b4	 mov	 eax, DWORD PTR tv212[ebp]
  00233	8b 08		 mov	 ecx, DWORD PTR [eax]
  00235	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00238	ff d2		 call	 edx
  0023a	89 45 c4	 mov	 DWORD PTR _hr$[ebp], eax

; 419  : 		if (FAILED(hr)) {

  0023d	83 7d c4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00241	7d 35		 jge	 SHORT $LN3@FindCaptur

; 420  : 			return hr;

  00243	8b 45 c4	 mov	 eax, DWORD PTR _hr$[ebp]
  00246	89 45 94	 mov	 DWORD PTR $T3[ebp], eax
  00249	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0024d	8d 4d e8	 lea	 ecx, DWORD PTR _pClassEnum$[ebp]
  00250	e8 00 00 00 00	 call	 ??1?$CComPtr@UIEnumMoniker@@@ATL@@QAE@XZ
  00255	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00259	8d 4d e4	 lea	 ecx, DWORD PTR _pDevEnum$[ebp]
  0025c	e8 00 00 00 00	 call	 ??1?$CComPtr@UICreateDevEnum@@@ATL@@QAE@XZ
  00261	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00268	8d 4d ec	 lea	 ecx, DWORD PTR _pMoniker$[ebp]
  0026b	e8 00 00 00 00	 call	 ??1?$CComPtr@UIMoniker@@@ATL@@QAE@XZ
  00270	8b 45 94	 mov	 eax, DWORD PTR $T3[ebp]
  00273	e9 0f 01 00 00	 jmp	 $LN9@FindCaptur
$LN3@FindCaptur:

; 421  : 			
; 422  : 		}
; 423  :         // Bind Moniker to a filter object
; 424  :         hr = pMoniker->BindToObject(0,0,IID_IBaseFilter, (void**)&pSrc);

  00278	8d 4d ec	 lea	 ecx, DWORD PTR _pMoniker$[ebp]
  0027b	e8 00 00 00 00	 call	 ??C?$CComPtrBase@UIMoniker@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIMoniker@@@1@XZ ; ATL::CComPtrBase<IMoniker>::operator->
  00280	89 45 bc	 mov	 DWORD PTR tv232[ebp], eax
  00283	8d 4d c8	 lea	 ecx, DWORD PTR _pSrc$[ebp]
  00286	51		 push	 ecx
  00287	68 00 00 00 00	 push	 OFFSET _IID_IBaseFilter
  0028c	6a 00		 push	 0
  0028e	6a 00		 push	 0
  00290	8b 55 bc	 mov	 edx, DWORD PTR tv232[ebp]
  00293	52		 push	 edx
  00294	8b 45 bc	 mov	 eax, DWORD PTR tv232[ebp]
  00297	8b 08		 mov	 ecx, DWORD PTR [eax]
  00299	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0029c	ff d2		 call	 edx
  0029e	89 45 c4	 mov	 DWORD PTR _hr$[ebp], eax

; 425  :         if (FAILED(hr))

  002a1	83 7d c4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  002a5	7d 4a		 jge	 SHORT $LN2@FindCaptur

; 426  :         {
; 427  :             Msg(TEXT("Couldn't bind moniker to filter object!  hr=0x%x"), hr);

  002a7	8b 45 c4	 mov	 eax, DWORD PTR _hr$[ebp]
  002aa	50		 push	 eax
  002ab	68 00 00 00 00	 push	 OFFSET $SG4294962976
  002b0	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  002b3	51		 push	 ecx
  002b4	e8 00 00 00 00	 call	 ?Msg@CEDSCapture@@IAAXPADZZ ; CEDSCapture::Msg
  002b9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 428  :             return hr;

  002bc	8b 55 c4	 mov	 edx, DWORD PTR _hr$[ebp]
  002bf	89 55 9c	 mov	 DWORD PTR $T5[ebp], edx
  002c2	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  002c6	8d 4d e8	 lea	 ecx, DWORD PTR _pClassEnum$[ebp]
  002c9	e8 00 00 00 00	 call	 ??1?$CComPtr@UIEnumMoniker@@@ATL@@QAE@XZ
  002ce	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  002d2	8d 4d e4	 lea	 ecx, DWORD PTR _pDevEnum$[ebp]
  002d5	e8 00 00 00 00	 call	 ??1?$CComPtr@UICreateDevEnum@@@ATL@@QAE@XZ
  002da	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  002e1	8d 4d ec	 lea	 ecx, DWORD PTR _pMoniker$[ebp]
  002e4	e8 00 00 00 00	 call	 ??1?$CComPtr@UIMoniker@@@ATL@@QAE@XZ
  002e9	8b 45 9c	 mov	 eax, DWORD PTR $T5[ebp]
  002ec	e9 96 00 00 00	 jmp	 $LN9@FindCaptur
$LN2@FindCaptur:

; 429  :         }
; 430  : 
; 431  : 		VARIANT t_strName;
; 432  : 		VariantInit(&t_strName);

  002f1	8d 45 d0	 lea	 eax, DWORD PTR _t_strName$11[ebp]
  002f4	50		 push	 eax
  002f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantInit@4

; 433  : 		hr = t_pPropBag->Read(L"FriendlyName", &t_strName, NULL);

  002fb	6a 00		 push	 0
  002fd	8d 4d d0	 lea	 ecx, DWORD PTR _t_strName$11[ebp]
  00300	51		 push	 ecx
  00301	68 00 00 00 00	 push	 OFFSET $SG4294962975
  00306	8b 55 cc	 mov	 edx, DWORD PTR _t_pPropBag$10[ebp]
  00309	8b 02		 mov	 eax, DWORD PTR [edx]
  0030b	8b 4d cc	 mov	 ecx, DWORD PTR _t_pPropBag$10[ebp]
  0030e	51		 push	 ecx
  0030f	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00312	ff d2		 call	 edx
  00314	89 45 c4	 mov	 DWORD PTR _hr$[ebp], eax

; 434  : 		if (FAILED(hr)) {

  00317	83 7d c4 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0031b	7d 32		 jge	 SHORT $LN4@FindCaptur

; 435  : 			return hr;

  0031d	8b 45 c4	 mov	 eax, DWORD PTR _hr$[ebp]
  00320	89 45 a8	 mov	 DWORD PTR $T8[ebp], eax
  00323	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00327	8d 4d e8	 lea	 ecx, DWORD PTR _pClassEnum$[ebp]
  0032a	e8 00 00 00 00	 call	 ??1?$CComPtr@UIEnumMoniker@@@ATL@@QAE@XZ
  0032f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00333	8d 4d e4	 lea	 ecx, DWORD PTR _pDevEnum$[ebp]
  00336	e8 00 00 00 00	 call	 ??1?$CComPtr@UICreateDevEnum@@@ATL@@QAE@XZ
  0033b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00342	8d 4d ec	 lea	 ecx, DWORD PTR _pMoniker$[ebp]
  00345	e8 00 00 00 00	 call	 ??1?$CComPtr@UIMoniker@@@ATL@@QAE@XZ
  0034a	8b 45 a8	 mov	 eax, DWORD PTR $T8[ebp]
  0034d	eb 38		 jmp	 SHORT $LN9@FindCaptur
$LN4@FindCaptur:

; 436  : 		}
; 437  :     }
; 438  :     //else
; 439  :     //{
; 440  :    //     Msg(TEXT("Unable to access video capture device!"));   
; 441  :     //    return E_FAIL;
; 442  :     //}
; 443  : 
; 444  :     // Copy the found filter pointer to the output parameter.
; 445  :     // Do NOT Release() the reference, since it will still be used
; 446  :     // by the calling function.
; 447  :     *ppSrcFilter = pSrc;

  0034f	8b 4d 08	 mov	 ecx, DWORD PTR _ppSrcFilter$[ebp]
  00352	8b 55 c8	 mov	 edx, DWORD PTR _pSrc$[ebp]
  00355	89 11		 mov	 DWORD PTR [ecx], edx

; 448  : 
; 449  :     return hr;

  00357	8b 45 c4	 mov	 eax, DWORD PTR _hr$[ebp]
  0035a	89 45 a0	 mov	 DWORD PTR $T6[ebp], eax
  0035d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00361	8d 4d e8	 lea	 ecx, DWORD PTR _pClassEnum$[ebp]
  00364	e8 00 00 00 00	 call	 ??1?$CComPtr@UIEnumMoniker@@@ATL@@QAE@XZ
  00369	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0036d	8d 4d e4	 lea	 ecx, DWORD PTR _pDevEnum$[ebp]
  00370	e8 00 00 00 00	 call	 ??1?$CComPtr@UICreateDevEnum@@@ATL@@QAE@XZ
  00375	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0037c	8d 4d ec	 lea	 ecx, DWORD PTR _pMoniker$[ebp]
  0037f	e8 00 00 00 00	 call	 ??1?$CComPtr@UIMoniker@@@ATL@@QAE@XZ
  00384	8b 45 a0	 mov	 eax, DWORD PTR $T6[ebp]
$LN9@FindCaptur:

; 450  : }

  00387	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0038a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00391	59		 pop	 ecx
  00392	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00395	33 cd		 xor	 ecx, ebp
  00397	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0039c	8b e5		 mov	 esp, ebp
  0039e	5d		 pop	 ebp
  0039f	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindCaptureDevice@CEDSCapture@@IAEJPAPAUIBaseFilter@@@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR _pMoniker$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CComPtr@UIMoniker@@@ATL@@QAE@XZ
__unwindfunclet$?FindCaptureDevice@CEDSCapture@@IAEJPAPAUIBaseFilter@@@Z$1:
  00008	8d 4d e4	 lea	 ecx, DWORD PTR _pDevEnum$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$CComPtr@UICreateDevEnum@@@ATL@@QAE@XZ
__unwindfunclet$?FindCaptureDevice@CEDSCapture@@IAEJPAPAUIBaseFilter@@@Z$2:
  00010	8d 4d e8	 lea	 ecx, DWORD PTR _pClassEnum$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$CComPtr@UIEnumMoniker@@@ATL@@QAE@XZ
__ehhandler$?FindCaptureDevice@CEDSCapture@@IAEJPAPAUIBaseFilter@@@Z:
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 4a 98	 mov	 ecx, DWORD PTR [edx-104]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?FindCaptureDevice@CEDSCapture@@IAEJPAPAUIBaseFilter@@@Z
  00038	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?FindCaptureDevice@CEDSCapture@@IAEJPAPAUIBaseFilter@@@Z ENDP ; CEDSCapture::FindCaptureDevice
; Function compile flags: /Odtp
;	COMDAT ??1?$CComPtr@UIMoniker@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CComPtr@UIMoniker@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<IMoniker>::~CComPtr<IMoniker>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CComPtrBase@UIMoniker@@@ATL@@QAE@XZ ; ATL::CComPtrBase<IMoniker>::~CComPtrBase<IMoniker>
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$CComPtr@UIMoniker@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<IMoniker>::~CComPtr<IMoniker>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit@?$CComPtr@UIMoniker@@@ATL@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_$initVBases$ = 8					; size = 4
?__autoclassinit@?$CComPtr@UIMoniker@@@ATL@@QAEXI@Z PROC ; ATL::CComPtr<IMoniker>::__autoclassinit, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?__autoclassinit@?$CComPtrBase@UIMoniker@@@ATL@@QAEXI@Z
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?__autoclassinit@?$CComPtr@UIMoniker@@@ATL@@QAEXI@Z ENDP ; ATL::CComPtr<IMoniker>::__autoclassinit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$CComPtr@UICreateDevEnum@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CComPtr@UICreateDevEnum@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<ICreateDevEnum>::~CComPtr<ICreateDevEnum>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CComPtrBase@UICreateDevEnum@@@ATL@@QAE@XZ ; ATL::CComPtrBase<ICreateDevEnum>::~CComPtrBase<ICreateDevEnum>
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$CComPtr@UICreateDevEnum@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<ICreateDevEnum>::~CComPtr<ICreateDevEnum>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit@?$CComPtr@UICreateDevEnum@@@ATL@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_$initVBases$ = 8					; size = 4
?__autoclassinit@?$CComPtr@UICreateDevEnum@@@ATL@@QAEXI@Z PROC ; ATL::CComPtr<ICreateDevEnum>::__autoclassinit, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?__autoclassinit@?$CComPtrBase@UICreateDevEnum@@@ATL@@QAEXI@Z
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?__autoclassinit@?$CComPtr@UICreateDevEnum@@@ATL@@QAEXI@Z ENDP ; ATL::CComPtr<ICreateDevEnum>::__autoclassinit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$CComPtr@UIEnumMoniker@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CComPtr@UIEnumMoniker@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<IEnumMoniker>::~CComPtr<IEnumMoniker>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CComPtrBase@UIEnumMoniker@@@ATL@@QAE@XZ ; ATL::CComPtrBase<IEnumMoniker>::~CComPtrBase<IEnumMoniker>
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$CComPtr@UIEnumMoniker@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<IEnumMoniker>::~CComPtr<IEnumMoniker>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit@?$CComPtr@UIEnumMoniker@@@ATL@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_$initVBases$ = 8					; size = 4
?__autoclassinit@?$CComPtr@UIEnumMoniker@@@ATL@@QAEXI@Z PROC ; ATL::CComPtr<IEnumMoniker>::__autoclassinit, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?__autoclassinit@?$CComPtrBase@UIEnumMoniker@@@ATL@@QAEXI@Z
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?__autoclassinit@?$CComPtr@UIEnumMoniker@@@ATL@@QAEXI@Z ENDP ; ATL::CComPtr<IEnumMoniker>::__autoclassinit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit@?$CComPtrBase@UIMoniker@@@ATL@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_$initVBases$ = 8					; size = 4
?__autoclassinit@?$CComPtrBase@UIMoniker@@@ATL@@QAEXI@Z PROC ; ATL::CComPtrBase<IMoniker>::__autoclassinit, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?__autoclassinit@?$CComPtrBase@UIMoniker@@@ATL@@QAEXI@Z ENDP ; ATL::CComPtrBase<IMoniker>::__autoclassinit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit@?$CComPtrBase@UICreateDevEnum@@@ATL@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_$initVBases$ = 8					; size = 4
?__autoclassinit@?$CComPtrBase@UICreateDevEnum@@@ATL@@QAEXI@Z PROC ; ATL::CComPtrBase<ICreateDevEnum>::__autoclassinit, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?__autoclassinit@?$CComPtrBase@UICreateDevEnum@@@ATL@@QAEXI@Z ENDP ; ATL::CComPtrBase<ICreateDevEnum>::__autoclassinit
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ?__autoclassinit@?$CComPtrBase@UIEnumMoniker@@@ATL@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_$initVBases$ = 8					; size = 4
?__autoclassinit@?$CComPtrBase@UIEnumMoniker@@@ATL@@QAEXI@Z PROC ; ATL::CComPtrBase<IEnumMoniker>::__autoclassinit, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?__autoclassinit@?$CComPtrBase@UIEnumMoniker@@@ATL@@QAEXI@Z ENDP ; ATL::CComPtrBase<IEnumMoniker>::__autoclassinit
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\edscapture.cpp
;	COMDAT ?GetInterfaces@CEDSCapture@@IAEJXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_hr$ = -4						; size = 4
?GetInterfaces@CEDSCapture@@IAEJXZ PROC			; CEDSCapture::GetInterfaces, COMDAT
; _this$ = ecx

; 454  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 455  :     HRESULT hr;
; 456  : 
; 457  :     // Create the filter graph
; 458  :     hr = CoCreateInstance (CLSID_FilterGraph, NULL, CLSCTX_INPROC,
; 459  :                            IID_IGraphBuilder, (void **) &m_pGraph);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	05 cc 00 00 00	 add	 eax, 204		; 000000ccH
  00011	50		 push	 eax
  00012	68 00 00 00 00	 push	 OFFSET _IID_IGraphBuilder
  00017	6a 03		 push	 3
  00019	6a 00		 push	 0
  0001b	68 00 00 00 00	 push	 OFFSET _CLSID_FilterGraph
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoCreateInstance@20
  00026	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 460  :     if (FAILED(hr))

  00029	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0002d	7d 08		 jge	 SHORT $LN5@GetInterfa

; 461  :         return hr;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  00032	e9 04 01 00 00	 jmp	 $LN6@GetInterfa
$LN5@GetInterfa:

; 462  : 
; 463  :     // Create the capture graph builder
; 464  :     hr = CoCreateInstance (CLSID_CaptureGraphBuilder2 , NULL, CLSCTX_INPROC,
; 465  :                            IID_ICaptureGraphBuilder2, (void **) &m_pCapture);

  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	81 c1 d0 00 00
	00		 add	 ecx, 208		; 000000d0H
  00040	51		 push	 ecx
  00041	68 00 00 00 00	 push	 OFFSET _IID_ICaptureGraphBuilder2
  00046	6a 03		 push	 3
  00048	6a 00		 push	 0
  0004a	68 00 00 00 00	 push	 OFFSET _CLSID_CaptureGraphBuilder2
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoCreateInstance@20
  00055	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 466  :     if (FAILED(hr))

  00058	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0005c	7d 08		 jge	 SHORT $LN4@GetInterfa

; 467  :         return hr;

  0005e	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  00061	e9 d5 00 00 00	 jmp	 $LN6@GetInterfa
$LN4@GetInterfa:

; 468  :     
; 469  :     // Obtain interfaces for media control and Video Window
; 470  :     hr = m_pGraph->QueryInterface( IID_IMediaControl,(LPVOID *)&m_pMC );

  00066	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00069	81 c2 c4 00 00
	00		 add	 edx, 196		; 000000c4H
  0006f	52		 push	 edx
  00070	68 00 00 00 00	 push	 OFFSET _IID_IMediaControl
  00075	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00078	8b 88 cc 00 00
	00		 mov	 ecx, DWORD PTR [eax+204]
  0007e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00081	8b 82 cc 00 00
	00		 mov	 eax, DWORD PTR [edx+204]
  00087	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00089	50		 push	 eax
  0008a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008c	ff d2		 call	 edx
  0008e	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 471  :     if (FAILED(hr))

  00091	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00095	7d 08		 jge	 SHORT $LN3@GetInterfa

; 472  :         return hr;

  00097	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  0009a	e9 9c 00 00 00	 jmp	 $LN6@GetInterfa
$LN3@GetInterfa:

; 473  : 
; 474  :     hr = m_pGraph->QueryInterface( IID_IVideoWindow, (LPVOID *)&m_pVW );

  0009f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a2	05 c0 00 00 00	 add	 eax, 192		; 000000c0H
  000a7	50		 push	 eax
  000a8	68 00 00 00 00	 push	 OFFSET _IID_IVideoWindow
  000ad	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	8b 91 cc 00 00
	00		 mov	 edx, DWORD PTR [ecx+204]
  000b6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	8b 88 cc 00 00
	00		 mov	 ecx, DWORD PTR [eax+204]
  000bf	8b 12		 mov	 edx, DWORD PTR [edx]
  000c1	51		 push	 ecx
  000c2	8b 02		 mov	 eax, DWORD PTR [edx]
  000c4	ff d0		 call	 eax
  000c6	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 475  :     if (FAILED(hr))

  000c9	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000cd	7d 05		 jge	 SHORT $LN2@GetInterfa

; 476  :         return hr;

  000cf	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  000d2	eb 67		 jmp	 SHORT $LN6@GetInterfa
$LN2@GetInterfa:

; 477  : 
; 478  :     hr = m_pGraph->QueryInterface( IID_IMediaEvent, (LPVOID *)&m_pME );

  000d4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	81 c1 c8 00 00
	00		 add	 ecx, 200		; 000000c8H
  000dd	51		 push	 ecx
  000de	68 00 00 00 00	 push	 OFFSET _IID_IMediaEvent
  000e3	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000e6	8b 82 cc 00 00
	00		 mov	 eax, DWORD PTR [edx+204]
  000ec	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ef	8b 91 cc 00 00
	00		 mov	 edx, DWORD PTR [ecx+204]
  000f5	8b 00		 mov	 eax, DWORD PTR [eax]
  000f7	52		 push	 edx
  000f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fa	ff d1		 call	 ecx
  000fc	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 479  :     if (FAILED(hr))

  000ff	83 7d fc 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00103	7d 05		 jge	 SHORT $LN1@GetInterfa

; 480  :         return hr;

  00105	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
  00108	eb 31		 jmp	 SHORT $LN6@GetInterfa
$LN1@GetInterfa:

; 481  : 
; 482  :     // Set the window handle used to process graph events
; 483  :     hr = m_pME->SetNotifyWindow((OAHWND)m_hApp, WM_GRAPHNOTIFY, 0);

  0010a	6a 00		 push	 0
  0010c	68 64 80 00 00	 push	 32868			; 00008064H
  00111	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00114	8b 82 98 00 00
	00		 mov	 eax, DWORD PTR [edx+152]
  0011a	50		 push	 eax
  0011b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0011e	8b 91 c8 00 00
	00		 mov	 edx, DWORD PTR [ecx+200]
  00124	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00127	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]
  0012d	8b 12		 mov	 edx, DWORD PTR [edx]
  0012f	51		 push	 ecx
  00130	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00133	ff d0		 call	 eax
  00135	89 45 fc	 mov	 DWORD PTR _hr$[ebp], eax

; 484  : 
; 485  :     return hr;

  00138	8b 45 fc	 mov	 eax, DWORD PTR _hr$[ebp]
$LN6@GetInterfa:

; 486  : }

  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c3		 ret	 0
?GetInterfaces@CEDSCapture@@IAEJXZ ENDP			; CEDSCapture::GetInterfaces
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\edscapture.cpp
;	COMDAT ?FreeMediaType@CEDSCapture@@IAEXAAU_AMMediaType@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_mt$ = 8						; size = 4
?FreeMediaType@CEDSCapture@@IAEXAAU_AMMediaType@@@Z PROC ; CEDSCapture::FreeMediaType, COMDAT
; _this$ = ecx

; 527  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 528  : 	if (mt.cbFormat != 0) {

  00007	8b 45 08	 mov	 eax, DWORD PTR _mt$[ebp]
  0000a	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  0000e	74 21		 je	 SHORT $LN2@FreeMediaT

; 529  : 		CoTaskMemFree((PVOID)mt.pbFormat);

  00010	8b 4d 08	 mov	 ecx, DWORD PTR _mt$[ebp]
  00013	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00016	52		 push	 edx
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemFree@4

; 530  : 		// Strictly unnecessary but tidier
; 531  : 		mt.cbFormat = 0;

  0001d	8b 45 08	 mov	 eax, DWORD PTR _mt$[ebp]
  00020	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], 0

; 532  : 		mt.pbFormat = NULL;

  00027	8b 4d 08	 mov	 ecx, DWORD PTR _mt$[ebp]
  0002a	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0
$LN2@FreeMediaT:

; 533  : 	}
; 534  : 	if (mt.pUnk != NULL) {

  00031	8b 55 08	 mov	 edx, DWORD PTR _mt$[ebp]
  00034	83 7a 3c 00	 cmp	 DWORD PTR [edx+60], 0
  00038	74 1e		 je	 SHORT $LN3@FreeMediaT

; 535  : 		mt.pUnk->Release();

  0003a	8b 45 08	 mov	 eax, DWORD PTR _mt$[ebp]
  0003d	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00040	8b 55 08	 mov	 edx, DWORD PTR _mt$[ebp]
  00043	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00046	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00048	50		 push	 eax
  00049	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0004c	ff d2		 call	 edx

; 536  : 		mt.pUnk = NULL;

  0004e	8b 45 08	 mov	 eax, DWORD PTR _mt$[ebp]
  00051	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0
$LN3@FreeMediaT:

; 537  : 	}
; 538  : }

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
?FreeMediaType@CEDSCapture@@IAEXAAU_AMMediaType@@@Z ENDP ; CEDSCapture::FreeMediaType
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$vector@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$vector@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@QAE@XZ PROC ; std::vector<IBaseFilter *,std::allocator<IBaseFilter *> >::vector<IBaseFilter *,std::allocator<IBaseFilter *> >, COMDAT
; _this$ = ecx

; 685  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  0000c	e8 00 00 00 00	 call	 ??0?$allocator@PAUIBaseFilter@@@std@@QAE@XZ ; std::allocator<IBaseFilter *>::allocator<IBaseFilter *>
  00011	50		 push	 eax
  00012	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUIBaseFilter@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<IBaseFilter *,std::allocator<IBaseFilter *> > >::_Vector_alloc<0,std::_Vec_base_types<IBaseFilter *,std::allocator<IBaseFilter *> > >

; 686  : 		}

  0001a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0?$vector@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@QAE@XZ ENDP ; std::vector<IBaseFilter *,std::allocator<IBaseFilter *> >::vector<IBaseFilter *,std::allocator<IBaseFilter *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??1?$vector@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@QAE@XZ PROC ; std::vector<IBaseFilter *,std::allocator<IBaseFilter *> >::~vector<IBaseFilter *,std::allocator<IBaseFilter *> >, COMDAT
; _this$ = ecx

; 899  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 900  : 		_Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@IAEXXZ ; std::vector<IBaseFilter *,std::allocator<IBaseFilter *> >::_Tidy

; 901  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$vector@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@QAE@XZ ENDP ; std::vector<IBaseFilter *,std::allocator<IBaseFilter *> >::~vector<IBaseFilter *,std::allocator<IBaseFilter *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UISampleGrabber@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CComPtr@UISampleGrabber@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<ISampleGrabber>::CComPtr<ISampleGrabber>, COMDAT
; _this$ = ecx

; 319  :     CComPtr() throw()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$CComPtrBase@UISampleGrabber@@@ATL@@IAE@XZ ; ATL::CComPtrBase<ISampleGrabber>::CComPtrBase<ISampleGrabber>

; 320  :     {
; 321  :     }

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$CComPtr@UISampleGrabber@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<ISampleGrabber>::CComPtr<ISampleGrabber>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??4?$CComPtr@UISampleGrabber@@@ATL@@QAEPAUISampleGrabber@@PAU2@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
_lp$ = 8						; size = 4
??4?$CComPtr@UISampleGrabber@@@ATL@@QAEPAUISampleGrabber@@PAU2@@Z PROC ; ATL::CComPtr<ISampleGrabber>::operator=, COMDAT
; _this$ = ecx

; 331  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 332  :         if(*this!=lp)

  00009	8b 45 08	 mov	 eax, DWORD PTR _lp$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ??9?$CComPtrBase@UISampleGrabber@@@ATL@@QBE_NPAUISampleGrabber@@@Z ; ATL::CComPtrBase<ISampleGrabber>::operator!=
  00015	0f b6 c8	 movzx	 ecx, al
  00018	85 c9		 test	 ecx, ecx
  0001a	74 1f		 je	 SHORT $LN1@operator

; 333  :         {
; 334  :             CComPtr(lp).Swap(*this);

  0001c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	52		 push	 edx
  00020	8b 45 08	 mov	 eax, DWORD PTR _lp$[ebp]
  00023	50		 push	 eax
  00024	8d 4d f8	 lea	 ecx, DWORD PTR $T1[ebp]
  00027	e8 00 00 00 00	 call	 ??0?$CComPtr@UISampleGrabber@@@ATL@@QAE@PAUISampleGrabber@@@Z ; ATL::CComPtr<ISampleGrabber>::CComPtr<ISampleGrabber>
  0002c	8b c8		 mov	 ecx, eax
  0002e	e8 00 00 00 00	 call	 ?Swap@?$CComPtrBase@UISampleGrabber@@@ATL@@IAEXAAV12@@Z ; ATL::CComPtrBase<ISampleGrabber>::Swap
  00033	8d 4d f8	 lea	 ecx, DWORD PTR $T1[ebp]
  00036	e8 00 00 00 00	 call	 ??1?$CComPtr@UISampleGrabber@@@ATL@@QAE@XZ
$LN1@operator:

; 335  :         }
; 336  :         return *this;

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ??B?$CComPtrBase@UISampleGrabber@@@ATL@@QBEPAUISampleGrabber@@XZ ; ATL::CComPtrBase<ISampleGrabber>::operator ISampleGrabber *

; 337  :     }

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
??4?$CComPtr@UISampleGrabber@@@ATL@@QAEPAUISampleGrabber@@PAU2@@Z ENDP ; ATL::CComPtr<ISampleGrabber>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UISampleGrabber@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CComPtrBase@UISampleGrabber@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<ISampleGrabber>::~CComPtrBase<ISampleGrabber>, COMDAT
; _this$ = ecx

; 175  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 176  :         if (p)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000d	74 12		 je	 SHORT $LN2@CComPtrBas

; 177  :             p->Release();

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 11		 mov	 edx, DWORD PTR [ecx]
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	8b 12		 mov	 edx, DWORD PTR [edx]
  0001b	51		 push	 ecx
  0001c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001f	ff d0		 call	 eax
$LN2@CComPtrBas:

; 178  :     }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??1?$CComPtrBase@UISampleGrabber@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<ISampleGrabber>::~CComPtrBase<ISampleGrabber>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??B?$CComPtrBase@UISampleGrabber@@@ATL@@QBEPAUISampleGrabber@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CComPtrBase@UISampleGrabber@@@ATL@@QBEPAUISampleGrabber@@XZ PROC ; ATL::CComPtrBase<ISampleGrabber>::operator ISampleGrabber *, COMDAT
; _this$ = ecx

; 180  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 181  :         return p;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 182  :     }

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??B?$CComPtrBase@UISampleGrabber@@@ATL@@QBEPAUISampleGrabber@@XZ ENDP ; ATL::CComPtrBase<ISampleGrabber>::operator ISampleGrabber *
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??C?$CComPtrBase@UISampleGrabber@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UISampleGrabber@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$CComPtrBase@UISampleGrabber@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UISampleGrabber@@@1@XZ PROC ; ATL::CComPtrBase<ISampleGrabber>::operator->, COMDAT
; _this$ = ecx

; 196  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  :         ATLASSERT(p!=NULL);
; 198  :         return (_NoAddRefReleaseOnCComPtr<T>*)p;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 199  :     }

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??C?$CComPtrBase@UISampleGrabber@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UISampleGrabber@@@1@XZ ENDP ; ATL::CComPtrBase<ISampleGrabber>::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??7?$CComPtrBase@UISampleGrabber@@@ATL@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??7?$CComPtrBase@UISampleGrabber@@@ATL@@QBE_NXZ PROC	; ATL::CComPtrBase<ISampleGrabber>::operator!, COMDAT
; _this$ = ecx

; 201  :     {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 202  :         return (p == NULL);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	75 09		 jne	 SHORT $LN3@operator
  00011	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  00018	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0001a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN4@operator:
  00021	8a 45 fc	 mov	 al, BYTE PTR tv66[ebp]

; 203  :     }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??7?$CComPtrBase@UISampleGrabber@@@ATL@@QBE_NXZ ENDP	; ATL::CComPtrBase<ISampleGrabber>::operator!
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ?CoCreateInstance@?$CComPtrBase@UISampleGrabber@@@ATL@@QAEJABU_GUID@@PAUIUnknown@@K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rclsid$ = 8						; size = 4
_pUnkOuter$ = 12					; size = 4
_dwClsContext$ = 16					; size = 4
?CoCreateInstance@?$CComPtrBase@UISampleGrabber@@@ATL@@QAEJABU_GUID@@PAUIUnknown@@K@Z PROC ; ATL::CComPtrBase<ISampleGrabber>::CoCreateInstance, COMDAT
; _this$ = ecx

; 287  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 288  :         ATLASSERT(p == NULL);
; 289  :         return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	68 00 00 00 00	 push	 OFFSET __GUID_6b652fff_11fe_4fce_92ad_0266b5d7c78f
  00010	8b 4d 10	 mov	 ecx, DWORD PTR _dwClsContext$[ebp]
  00013	51		 push	 ecx
  00014	8b 55 0c	 mov	 edx, DWORD PTR _pUnkOuter$[ebp]
  00017	52		 push	 edx
  00018	8b 45 08	 mov	 eax, DWORD PTR _rclsid$[ebp]
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoCreateInstance@20

; 290  :     }

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 0c 00	 ret	 12			; 0000000cH
?CoCreateInstance@?$CComPtrBase@UISampleGrabber@@@ATL@@QAEJABU_GUID@@PAUIUnknown@@K@Z ENDP ; ATL::CComPtrBase<ISampleGrabber>::CoCreateInstance
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComQIPtr@UIBaseFilter@@$1?IID_IBaseFilter@@3U_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lp$ = 8						; size = 4
??0?$CComQIPtr@UIBaseFilter@@$1?IID_IBaseFilter@@3U_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z PROC ; ATL::CComQIPtr<IBaseFilter,&IID_IBaseFilter>::CComQIPtr<IBaseFilter,&IID_IBaseFilter>, COMDAT
; _this$ = ecx

; 617  :     CComQIPtr(_Inout_opt_ IUnknown* lp) throw()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$CComPtr@UIBaseFilter@@@ATL@@QAE@XZ ; ATL::CComPtr<IBaseFilter>::CComPtr<IBaseFilter>

; 618  :     {
; 619  :         if (lp != NULL)

  0000f	83 7d 08 00	 cmp	 DWORD PTR _lp$[ebp], 0
  00013	74 23		 je	 SHORT $LN3@CComQIPtr

; 620  :         {
; 621  :             if (FAILED(lp->QueryInterface(*piid, (void **)&p)))

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	50		 push	 eax
  00019	68 00 00 00 00	 push	 OFFSET _IID_IBaseFilter
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _lp$[ebp]
  00021	8b 11		 mov	 edx, DWORD PTR [ecx]
  00023	8b 45 08	 mov	 eax, DWORD PTR _lp$[ebp]
  00026	50		 push	 eax
  00027	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00029	ff d1		 call	 ecx
  0002b	85 c0		 test	 eax, eax
  0002d	7d 09		 jge	 SHORT $LN3@CComQIPtr

; 622  :                 p = NULL;

  0002f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00032	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$LN3@CComQIPtr:

; 623  :         }
; 624  :     }

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
??0?$CComQIPtr@UIBaseFilter@@$1?IID_IBaseFilter@@3U_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z ENDP ; ATL::CComQIPtr<IBaseFilter,&IID_IBaseFilter>::CComQIPtr<IBaseFilter,&IID_IBaseFilter>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UIBaseFilter@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CComPtrBase@UIBaseFilter@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<IBaseFilter>::~CComPtrBase<IBaseFilter>, COMDAT
; _this$ = ecx

; 175  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 176  :         if (p)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000d	74 12		 je	 SHORT $LN2@CComPtrBas

; 177  :             p->Release();

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 11		 mov	 edx, DWORD PTR [ecx]
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	8b 12		 mov	 edx, DWORD PTR [edx]
  0001b	51		 push	 ecx
  0001c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001f	ff d0		 call	 eax
$LN2@CComPtrBas:

; 178  :     }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??1?$CComPtrBase@UIBaseFilter@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<IBaseFilter>::~CComPtrBase<IBaseFilter>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??B?$CComPtrBase@UIBaseFilter@@@ATL@@QBEPAUIBaseFilter@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CComPtrBase@UIBaseFilter@@@ATL@@QBEPAUIBaseFilter@@XZ PROC ; ATL::CComPtrBase<IBaseFilter>::operator IBaseFilter *, COMDAT
; _this$ = ecx

; 180  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 181  :         return p;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 182  :     }

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??B?$CComPtrBase@UIBaseFilter@@@ATL@@QBEPAUIBaseFilter@@XZ ENDP ; ATL::CComPtrBase<IBaseFilter>::operator IBaseFilter *
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UIMoniker@@@ATL@@QAE@PAUIMoniker@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lp$ = 8						; size = 4
??0?$CComPtr@UIMoniker@@@ATL@@QAE@PAUIMoniker@@@Z PROC	; ATL::CComPtr<IMoniker>::CComPtr<IMoniker>, COMDAT
; _this$ = ecx

; 324  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _lp$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$CComPtrBase@UIMoniker@@@ATL@@IAE@PAUIMoniker@@@Z ; ATL::CComPtrBase<IMoniker>::CComPtrBase<IMoniker>

; 325  :     }

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$CComPtr@UIMoniker@@@ATL@@QAE@PAUIMoniker@@@Z ENDP	; ATL::CComPtr<IMoniker>::CComPtr<IMoniker>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UIMoniker@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CComPtrBase@UIMoniker@@@ATL@@QAE@XZ PROC		; ATL::CComPtrBase<IMoniker>::~CComPtrBase<IMoniker>, COMDAT
; _this$ = ecx

; 175  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 176  :         if (p)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000d	74 12		 je	 SHORT $LN2@CComPtrBas

; 177  :             p->Release();

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 11		 mov	 edx, DWORD PTR [ecx]
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	8b 12		 mov	 edx, DWORD PTR [edx]
  0001b	51		 push	 ecx
  0001c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001f	ff d0		 call	 eax
$LN2@CComPtrBas:

; 178  :     }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??1?$CComPtrBase@UIMoniker@@@ATL@@QAE@XZ ENDP		; ATL::CComPtrBase<IMoniker>::~CComPtrBase<IMoniker>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UIMoniker@@@ATL@@QAEPAPAUIMoniker@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??I?$CComPtrBase@UIMoniker@@@ATL@@QAEPAPAUIMoniker@@XZ PROC ; ATL::CComPtrBase<IMoniker>::operator&, COMDAT
; _this$ = ecx

; 191  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 194  :     }

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??I?$CComPtrBase@UIMoniker@@@ATL@@QAEPAPAUIMoniker@@XZ ENDP ; ATL::CComPtrBase<IMoniker>::operator&
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??C?$CComPtrBase@UIMoniker@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIMoniker@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$CComPtrBase@UIMoniker@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIMoniker@@@1@XZ PROC ; ATL::CComPtrBase<IMoniker>::operator->, COMDAT
; _this$ = ecx

; 196  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  :         ATLASSERT(p!=NULL);
; 198  :         return (_NoAddRefReleaseOnCComPtr<T>*)p;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 199  :     }

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??C?$CComPtrBase@UIMoniker@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIMoniker@@@1@XZ ENDP ; ATL::CComPtrBase<IMoniker>::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UICreateDevEnum@@@ATL@@QAE@PAUICreateDevEnum@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lp$ = 8						; size = 4
??0?$CComPtr@UICreateDevEnum@@@ATL@@QAE@PAUICreateDevEnum@@@Z PROC ; ATL::CComPtr<ICreateDevEnum>::CComPtr<ICreateDevEnum>, COMDAT
; _this$ = ecx

; 324  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _lp$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$CComPtrBase@UICreateDevEnum@@@ATL@@IAE@PAUICreateDevEnum@@@Z ; ATL::CComPtrBase<ICreateDevEnum>::CComPtrBase<ICreateDevEnum>

; 325  :     }

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$CComPtr@UICreateDevEnum@@@ATL@@QAE@PAUICreateDevEnum@@@Z ENDP ; ATL::CComPtr<ICreateDevEnum>::CComPtr<ICreateDevEnum>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UICreateDevEnum@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CComPtrBase@UICreateDevEnum@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<ICreateDevEnum>::~CComPtrBase<ICreateDevEnum>, COMDAT
; _this$ = ecx

; 175  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 176  :         if (p)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000d	74 12		 je	 SHORT $LN2@CComPtrBas

; 177  :             p->Release();

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 11		 mov	 edx, DWORD PTR [ecx]
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	8b 12		 mov	 edx, DWORD PTR [edx]
  0001b	51		 push	 ecx
  0001c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001f	ff d0		 call	 eax
$LN2@CComPtrBas:

; 178  :     }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??1?$CComPtrBase@UICreateDevEnum@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<ICreateDevEnum>::~CComPtrBase<ICreateDevEnum>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UICreateDevEnum@@@ATL@@QAEPAPAUICreateDevEnum@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??I?$CComPtrBase@UICreateDevEnum@@@ATL@@QAEPAPAUICreateDevEnum@@XZ PROC ; ATL::CComPtrBase<ICreateDevEnum>::operator&, COMDAT
; _this$ = ecx

; 191  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 194  :     }

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??I?$CComPtrBase@UICreateDevEnum@@@ATL@@QAEPAPAUICreateDevEnum@@XZ ENDP ; ATL::CComPtrBase<ICreateDevEnum>::operator&
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??C?$CComPtrBase@UICreateDevEnum@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UICreateDevEnum@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$CComPtrBase@UICreateDevEnum@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UICreateDevEnum@@@1@XZ PROC ; ATL::CComPtrBase<ICreateDevEnum>::operator->, COMDAT
; _this$ = ecx

; 196  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  :         ATLASSERT(p!=NULL);
; 198  :         return (_NoAddRefReleaseOnCComPtr<T>*)p;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 199  :     }

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??C?$CComPtrBase@UICreateDevEnum@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UICreateDevEnum@@@1@XZ ENDP ; ATL::CComPtrBase<ICreateDevEnum>::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UIEnumMoniker@@@ATL@@QAE@PAUIEnumMoniker@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lp$ = 8						; size = 4
??0?$CComPtr@UIEnumMoniker@@@ATL@@QAE@PAUIEnumMoniker@@@Z PROC ; ATL::CComPtr<IEnumMoniker>::CComPtr<IEnumMoniker>, COMDAT
; _this$ = ecx

; 324  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _lp$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$CComPtrBase@UIEnumMoniker@@@ATL@@IAE@PAUIEnumMoniker@@@Z ; ATL::CComPtrBase<IEnumMoniker>::CComPtrBase<IEnumMoniker>

; 325  :     }

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$CComPtr@UIEnumMoniker@@@ATL@@QAE@PAUIEnumMoniker@@@Z ENDP ; ATL::CComPtr<IEnumMoniker>::CComPtr<IEnumMoniker>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UIEnumMoniker@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CComPtrBase@UIEnumMoniker@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<IEnumMoniker>::~CComPtrBase<IEnumMoniker>, COMDAT
; _this$ = ecx

; 175  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 176  :         if (p)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000d	74 12		 je	 SHORT $LN2@CComPtrBas

; 177  :             p->Release();

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 11		 mov	 edx, DWORD PTR [ecx]
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	8b 12		 mov	 edx, DWORD PTR [edx]
  0001b	51		 push	 ecx
  0001c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001f	ff d0		 call	 eax
$LN2@CComPtrBas:

; 178  :     }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??1?$CComPtrBase@UIEnumMoniker@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<IEnumMoniker>::~CComPtrBase<IEnumMoniker>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UIEnumMoniker@@@ATL@@QAEPAPAUIEnumMoniker@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??I?$CComPtrBase@UIEnumMoniker@@@ATL@@QAEPAPAUIEnumMoniker@@XZ PROC ; ATL::CComPtrBase<IEnumMoniker>::operator&, COMDAT
; _this$ = ecx

; 191  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 194  :     }

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??I?$CComPtrBase@UIEnumMoniker@@@ATL@@QAEPAPAUIEnumMoniker@@XZ ENDP ; ATL::CComPtrBase<IEnumMoniker>::operator&
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??C?$CComPtrBase@UIEnumMoniker@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIEnumMoniker@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$CComPtrBase@UIEnumMoniker@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIEnumMoniker@@@1@XZ PROC ; ATL::CComPtrBase<IEnumMoniker>::operator->, COMDAT
; _this$ = ecx

; 196  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  :         ATLASSERT(p!=NULL);
; 198  :         return (_NoAddRefReleaseOnCComPtr<T>*)p;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 199  :     }

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??C?$CComPtrBase@UIEnumMoniker@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIEnumMoniker@@@1@XZ ENDP ; ATL::CComPtrBase<IEnumMoniker>::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??8?$CComPtrBase@UIEnumMoniker@@@ATL@@QBE_NPAUIEnumMoniker@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
_pT$ = 8						; size = 4
??8?$CComPtrBase@UIEnumMoniker@@@ATL@@QBE_NPAUIEnumMoniker@@@Z PROC ; ATL::CComPtrBase<IEnumMoniker>::operator==, COMDAT
; _this$ = ecx

; 213  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 214  :         return p == pT;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	3b 4d 08	 cmp	 ecx, DWORD PTR _pT$[ebp]
  00011	75 09		 jne	 SHORT $LN3@operator
  00013	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  0001a	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN4@operator:
  00023	8a 45 fc	 mov	 al, BYTE PTR tv66[ebp]

; 215  :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??8?$CComPtrBase@UIEnumMoniker@@@ATL@@QBE_NPAUIEnumMoniker@@@Z ENDP ; ATL::CComPtrBase<IEnumMoniker>::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Tidy@?$vector@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@IAEXXZ PROC ; std::vector<IBaseFilter *,std::allocator<IBaseFilter *> >::_Tidy, COMDAT
; _this$ = ecx

; 1535 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1536 : 		if (this->_Myfirst != pointer())

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 63		 je	 SHORT $LN2@Tidy

; 1537 : 			{	// something to free, destroy and deallocate it
; 1538 : 			this->_Orphan_all();

  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Orphan_all@_Container_base0@std@@QAEXXZ

; 1539 : 			_Destroy(this->_Myfirst, this->_Mylast);

  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00020	52		 push	 edx
  00021	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	51		 push	 ecx
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@IAEXPAPAUIBaseFilter@@0@Z ; std::vector<IBaseFilter *,std::allocator<IBaseFilter *> >::_Destroy

; 1540 : 			this->_Getal().deallocate(this->_Myfirst,
; 1541 : 				this->_Myend - this->_Myfirst);

  0002f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00038	2b 08		 sub	 ecx, DWORD PTR [eax]
  0003a	c1 f9 02	 sar	 ecx, 2
  0003d	51		 push	 ecx
  0003e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00041	8b 02		 mov	 eax, DWORD PTR [edx]
  00043	50		 push	 eax
  00044	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00047	51		 push	 ecx
  00048	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<IBaseFilter *,std::allocator<IBaseFilter *> > >::_Getal
  00050	8b c8		 mov	 ecx, eax
  00052	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@std@@QAEXPAPAUIBaseFilter@@I@Z ; std::_Wrap_alloc<std::allocator<IBaseFilter *> >::deallocate

; 1542 : 			this->_Myfirst = pointer();

  00057	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1543 : 			this->_Mylast = pointer();

  00060	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00063	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1544 : 			this->_Myend = pointer();

  0006a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
$LN2@Tidy:

; 1545 : 			}
; 1546 : 		}

  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
?_Tidy@?$vector@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@IAEXXZ ENDP ; std::vector<IBaseFilter *,std::allocator<IBaseFilter *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAUIBaseFilter@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAUIBaseFilter@@@std@@QAE@XZ PROC	; std::allocator<IBaseFilter *>::allocator<IBaseFilter *>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@PAUIBaseFilter@@@std@@QAE@XZ ENDP	; std::allocator<IBaseFilter *>::allocator<IBaseFilter *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUIBaseFilter@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUIBaseFilter@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<IBaseFilter *,std::allocator<IBaseFilter *> > >::_Vector_alloc<0,std::_Vec_base_types<IBaseFilter *,std::allocator<IBaseFilter *> > >, COMDAT
; _this$ = ecx

; 593  : 	_Vector_alloc(const _Alloc& = _Alloc())

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@PAUIBaseFilter@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<IBaseFilter *> >::_Vector_val<std::_Simple_types<IBaseFilter *> >

; 594  : 		{	// construct allocator from _Al
; 595  : 		}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUIBaseFilter@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<IBaseFilter *,std::allocator<IBaseFilter *> > >::_Vector_alloc<0,std::_Vec_base_types<IBaseFilter *,std::allocator<IBaseFilter *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UISampleGrabber@@@ATL@@QAE@PAUISampleGrabber@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lp$ = 8						; size = 4
??0?$CComPtr@UISampleGrabber@@@ATL@@QAE@PAUISampleGrabber@@@Z PROC ; ATL::CComPtr<ISampleGrabber>::CComPtr<ISampleGrabber>, COMDAT
; _this$ = ecx

; 324  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _lp$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$CComPtrBase@UISampleGrabber@@@ATL@@IAE@PAUISampleGrabber@@@Z ; ATL::CComPtrBase<ISampleGrabber>::CComPtrBase<ISampleGrabber>

; 325  :     }

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$CComPtr@UISampleGrabber@@@ATL@@QAE@PAUISampleGrabber@@@Z ENDP ; ATL::CComPtr<ISampleGrabber>::CComPtr<ISampleGrabber>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UISampleGrabber@@@ATL@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CComPtrBase@UISampleGrabber@@@ATL@@IAE@XZ PROC	; ATL::CComPtrBase<ISampleGrabber>::CComPtrBase<ISampleGrabber>, COMDAT
; _this$ = ecx

; 156  :     CComPtrBase() throw()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 157  :     {
; 158  :         p = NULL;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 159  :     }

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0?$CComPtrBase@UISampleGrabber@@@ATL@@IAE@XZ ENDP	; ATL::CComPtrBase<ISampleGrabber>::CComPtrBase<ISampleGrabber>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ?Swap@?$CComPtrBase@UISampleGrabber@@@ATL@@IAEXAAV12@@Z
_TEXT	SEGMENT
_pTemp$ = -8						; size = 4
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?Swap@?$CComPtrBase@UISampleGrabber@@@ATL@@IAEXAAV12@@Z PROC ; ATL::CComPtrBase<ISampleGrabber>::Swap, COMDAT
; _this$ = ecx

; 167  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 168  :         T* pTemp = p;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d f8	 mov	 DWORD PTR _pTemp$[ebp], ecx

; 169  :         p = other.p;

  00011	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00014	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	89 0a		 mov	 DWORD PTR [edx], ecx

; 170  :         other.p = pTemp;

  0001b	8b 55 08	 mov	 edx, DWORD PTR _other$[ebp]
  0001e	8b 45 f8	 mov	 eax, DWORD PTR _pTemp$[ebp]
  00021	89 02		 mov	 DWORD PTR [edx], eax

; 171  :     }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?Swap@?$CComPtrBase@UISampleGrabber@@@ATL@@IAEXAAV12@@Z ENDP ; ATL::CComPtrBase<ISampleGrabber>::Swap
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??9?$CComPtrBase@UISampleGrabber@@@ATL@@QBE_NPAUISampleGrabber@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv69 = -4						; size = 4
_pT$ = 8						; size = 4
??9?$CComPtrBase@UISampleGrabber@@@ATL@@QBE_NPAUISampleGrabber@@@Z PROC ; ATL::CComPtrBase<ISampleGrabber>::operator!=, COMDAT
; _this$ = ecx

; 209  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 210  :         return !operator==(pT);

  00009	8b 45 08	 mov	 eax, DWORD PTR _pT$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ??8?$CComPtrBase@UISampleGrabber@@@ATL@@QBE_NPAUISampleGrabber@@@Z ; ATL::CComPtrBase<ISampleGrabber>::operator==
  00015	0f b6 c8	 movzx	 ecx, al
  00018	85 c9		 test	 ecx, ecx
  0001a	75 09		 jne	 SHORT $LN3@operator
  0001c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00023	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  0002c	8a 45 fc	 mov	 al, BYTE PTR tv69[ebp]

; 211  :     }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
??9?$CComPtrBase@UISampleGrabber@@@ATL@@QBE_NPAUISampleGrabber@@@Z ENDP ; ATL::CComPtrBase<ISampleGrabber>::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UIBaseFilter@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CComPtr@UIBaseFilter@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<IBaseFilter>::CComPtr<IBaseFilter>, COMDAT
; _this$ = ecx

; 319  :     CComPtr() throw()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$CComPtrBase@UIBaseFilter@@@ATL@@IAE@XZ ; ATL::CComPtrBase<IBaseFilter>::CComPtrBase<IBaseFilter>

; 320  :     {
; 321  :     }

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$CComPtr@UIBaseFilter@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<IBaseFilter>::CComPtr<IBaseFilter>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UIMoniker@@@ATL@@IAE@PAUIMoniker@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lp$ = 8						; size = 4
??0?$CComPtrBase@UIMoniker@@@ATL@@IAE@PAUIMoniker@@@Z PROC ; ATL::CComPtrBase<IMoniker>::CComPtrBase<IMoniker>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 161  :     {
; 162  :         p = lp;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _lp$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 163  :         if (p != NULL)

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00015	74 12		 je	 SHORT $LN2@CComPtrBas

; 164  :             p->AddRef();

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	8b 02		 mov	 eax, DWORD PTR [edx]
  00021	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00023	50		 push	 eax
  00024	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00027	ff d2		 call	 edx
$LN2@CComPtrBas:

; 165  :     }

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
??0?$CComPtrBase@UIMoniker@@@ATL@@IAE@PAUIMoniker@@@Z ENDP ; ATL::CComPtrBase<IMoniker>::CComPtrBase<IMoniker>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UICreateDevEnum@@@ATL@@IAE@PAUICreateDevEnum@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lp$ = 8						; size = 4
??0?$CComPtrBase@UICreateDevEnum@@@ATL@@IAE@PAUICreateDevEnum@@@Z PROC ; ATL::CComPtrBase<ICreateDevEnum>::CComPtrBase<ICreateDevEnum>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 161  :     {
; 162  :         p = lp;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _lp$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 163  :         if (p != NULL)

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00015	74 12		 je	 SHORT $LN2@CComPtrBas

; 164  :             p->AddRef();

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	8b 02		 mov	 eax, DWORD PTR [edx]
  00021	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00023	50		 push	 eax
  00024	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00027	ff d2		 call	 edx
$LN2@CComPtrBas:

; 165  :     }

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
??0?$CComPtrBase@UICreateDevEnum@@@ATL@@IAE@PAUICreateDevEnum@@@Z ENDP ; ATL::CComPtrBase<ICreateDevEnum>::CComPtrBase<ICreateDevEnum>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UIEnumMoniker@@@ATL@@IAE@PAUIEnumMoniker@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lp$ = 8						; size = 4
??0?$CComPtrBase@UIEnumMoniker@@@ATL@@IAE@PAUIEnumMoniker@@@Z PROC ; ATL::CComPtrBase<IEnumMoniker>::CComPtrBase<IEnumMoniker>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 161  :     {
; 162  :         p = lp;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _lp$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 163  :         if (p != NULL)

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00015	74 12		 je	 SHORT $LN2@CComPtrBas

; 164  :             p->AddRef();

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	8b 02		 mov	 eax, DWORD PTR [edx]
  00021	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00023	50		 push	 eax
  00024	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00027	ff d2		 call	 edx
$LN2@CComPtrBas:

; 165  :     }

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
??0?$CComPtrBase@UIEnumMoniker@@@ATL@@IAE@PAUIEnumMoniker@@@Z ENDP ; ATL::CComPtrBase<IEnumMoniker>::CComPtrBase<IEnumMoniker>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@IAEXPAPAUIBaseFilter@@0@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Alval$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@IAEXPAPAUIBaseFilter@@0@Z PROC ; std::vector<IBaseFilter *,std::allocator<IBaseFilter *> >::_Destroy, COMDAT
; _this$ = ecx

; 1478 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1479 : 		_Alty _Alval(this->_Getal());

  00013	8d 45 fb	 lea	 eax, DWORD PTR __Alval$[ebp]
  00016	50		 push	 eax
  00017	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<IBaseFilter *,std::allocator<IBaseFilter *> > >::_Getal

; 1480 : 		_Destroy_range(_First, _Last, _Alval);

  0001f	8d 4d fb	 lea	 ecx, DWORD PTR __Alval$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@std@@@std@@YAXPAPAUIBaseFilter@@0AAU?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<IBaseFilter *> > >
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1481 : 		}

  00033	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00036	33 cd		 xor	 ecx, ebp
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
?_Destroy@?$vector@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@IAEXPAPAUIBaseFilter@@0@Z ENDP ; std::vector<IBaseFilter *,std::allocator<IBaseFilter *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<IBaseFilter *,std::allocator<IBaseFilter *> > >::_Getal, COMDAT
; _this$ = ecx

; 646  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 647  : 		return (_Alty());

  00007	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<IBaseFilter *> >::_Wrap_alloc<std::allocator<IBaseFilter *> >
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 648  : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUIBaseFilter@@V?$allocator@PAUIBaseFilter@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<IBaseFilter *,std::allocator<IBaseFilter *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@std@@QAEXPAPAUIBaseFilter@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@std@@QAEXPAPAUIBaseFilter@@I@Z PROC ; std::_Wrap_alloc<std::allocator<IBaseFilter *> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAUIBaseFilter@@@std@@QAEXPAPAUIBaseFilter@@I@Z ; std::allocator<IBaseFilter *>::deallocate

; 888  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@std@@QAEXPAPAUIBaseFilter@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<IBaseFilter *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAUIBaseFilter@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@PAUIBaseFilter@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<IBaseFilter *> >::_Vector_val<std::_Simple_types<IBaseFilter *> >, COMDAT
; _this$ = ecx

; 484  : 	_Vector_val()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 485  : 		{	// initialize values
; 486  : 		_Myfirst = pointer();

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 487  : 		_Mylast = pointer();

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 488  : 		_Myend = pointer();

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 489  : 		}

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAUIBaseFilter@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<IBaseFilter *> >::_Vector_val<std::_Simple_types<IBaseFilter *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UISampleGrabber@@@ATL@@IAE@PAUISampleGrabber@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lp$ = 8						; size = 4
??0?$CComPtrBase@UISampleGrabber@@@ATL@@IAE@PAUISampleGrabber@@@Z PROC ; ATL::CComPtrBase<ISampleGrabber>::CComPtrBase<ISampleGrabber>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 161  :     {
; 162  :         p = lp;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _lp$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 163  :         if (p != NULL)

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00015	74 12		 je	 SHORT $LN2@CComPtrBas

; 164  :             p->AddRef();

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	8b 02		 mov	 eax, DWORD PTR [edx]
  00021	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00023	50		 push	 eax
  00024	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00027	ff d2		 call	 edx
$LN2@CComPtrBas:

; 165  :     }

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
??0?$CComPtrBase@UISampleGrabber@@@ATL@@IAE@PAUISampleGrabber@@@Z ENDP ; ATL::CComPtrBase<ISampleGrabber>::CComPtrBase<ISampleGrabber>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??8?$CComPtrBase@UISampleGrabber@@@ATL@@QBE_NPAUISampleGrabber@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
_pT$ = 8						; size = 4
??8?$CComPtrBase@UISampleGrabber@@@ATL@@QBE_NPAUISampleGrabber@@@Z PROC ; ATL::CComPtrBase<ISampleGrabber>::operator==, COMDAT
; _this$ = ecx

; 213  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 214  :         return p == pT;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	3b 4d 08	 cmp	 ecx, DWORD PTR _pT$[ebp]
  00011	75 09		 jne	 SHORT $LN3@operator
  00013	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  0001a	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN4@operator:
  00023	8a 45 fc	 mov	 al, BYTE PTR tv66[ebp]

; 215  :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??8?$CComPtrBase@UISampleGrabber@@@ATL@@QBE_NPAUISampleGrabber@@@Z ENDP ; ATL::CComPtrBase<ISampleGrabber>::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UIBaseFilter@@@ATL@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CComPtrBase@UIBaseFilter@@@ATL@@IAE@XZ PROC	; ATL::CComPtrBase<IBaseFilter>::CComPtrBase<IBaseFilter>, COMDAT
; _this$ = ecx

; 156  :     CComPtrBase() throw()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 157  :     {
; 158  :         p = NULL;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 159  :     }

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0?$CComPtrBase@UIBaseFilter@@@ATL@@IAE@XZ ENDP	; ATL::CComPtrBase<IBaseFilter>::CComPtrBase<IBaseFilter>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAUIBaseFilter@@@std@@QAEXPAPAUIBaseFilter@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAUIBaseFilter@@@std@@QAEXPAPAUIBaseFilter@@I@Z PROC ; std::allocator<IBaseFilter *>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??3@YAXPAX@Z
  00011	83 c4 04	 add	 esp, 4

; 587  : 		}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
?deallocate@?$allocator@PAUIBaseFilter@@@std@@QAEXPAPAUIBaseFilter@@I@Z ENDP ; std::allocator<IBaseFilter *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<IBaseFilter *> >::_Wrap_alloc<std::allocator<IBaseFilter *> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$allocator@PAUIBaseFilter@@@std@@QAE@XZ ; std::allocator<IBaseFilter *>::allocator<IBaseFilter *>

; 831  : 		}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<IBaseFilter *> >::_Wrap_alloc<std::allocator<IBaseFilter *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\stdio.h
;	COMDAT ??$_vsnprintf_s@$0EAA@@@YAHAAY0EAA@DIPBDPAD@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__MaxCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Args$ = 20						; size = 4
??$_vsnprintf_s@$0EAA@@@YAHAAY0EAA@DIPBDPAD@Z PROC	; _vsnprintf_s<1024>, COMDAT

; 346  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(int, _vsnprintf_s, _Post_z_ char, _Dest, _In_ size_t, _MaxCount, _In_z_ _Printf_format_string_ const char *, _Format, va_list, _Args)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 14	 mov	 eax, DWORD PTR __Args$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 10	 mov	 ecx, DWORD PTR __Format$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 0c	 mov	 edx, DWORD PTR __MaxCount$[ebp]
  0000e	52		 push	 edx
  0000f	68 00 04 00 00	 push	 1024			; 00000400H
  00014	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00017	50		 push	 eax
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___vsnprintf_s
  0001e	83 c4 14	 add	 esp, 20			; 00000014H
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??$_vsnprintf_s@$0EAA@@@YAHAAY0EAA@DIPBDPAD@Z ENDP	; _vsnprintf_s<1024>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@std@@@std@@YAXPAPAUIBaseFilter@@0AAU?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@std@@@std@@YAXPAPAUIBaseFilter@@0AAU?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<IBaseFilter *> > >, COMDAT

; 79   : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 80   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Ptr_cat@PAUIBaseFilter@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUIBaseFilter@@0@Z ; std::_Ptr_cat<IBaseFilter *,IBaseFilter *>
  00011	83 c4 08	 add	 esp, 8
  00014	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
  00017	0f b6 55 ff	 movzx	 edx, BYTE PTR $T1[ebp]
  0001b	52		 push	 edx
  0001c	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00023	51		 push	 ecx
  00024	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00027	52		 push	 edx
  00028	e8 00 00 00 00	 call	 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@std@@@std@@YAXPAPAUIBaseFilter@@0AAU?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<IBaseFilter *> > >
  0002d	83 c4 10	 add	 esp, 16			; 00000010H

; 81   : 	}

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@std@@@std@@YAXPAPAUIBaseFilter@@0AAU?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<IBaseFilter *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAUIBaseFilter@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUIBaseFilter@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUIBaseFilter@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUIBaseFilter@@0@Z PROC ; std::_Ptr_cat<IBaseFilter *,IBaseFilter *>, COMDAT

; 437  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 438  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 439  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 440  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAUIBaseFilter@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUIBaseFilter@@0@Z ENDP ; std::_Ptr_cat<IBaseFilter *,IBaseFilter *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@std@@@std@@YAXPAPAUIBaseFilter@@0AAU?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@std@@@std@@YAXPAPAUIBaseFilter@@0AAU?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<IBaseFilter *> > >, COMDAT

; 96   : 	{	// destroy [_First, _Last), scalar type (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 97   : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@std@@@std@@YAXPAPAUIBaseFilter@@0AAU?$_Wrap_alloc@V?$allocator@PAUIBaseFilter@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<IBaseFilter *> > >
_TEXT	ENDS
END
