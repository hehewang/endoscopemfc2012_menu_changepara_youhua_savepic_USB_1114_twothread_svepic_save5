; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

	TITLE	E:\work_wm\HXIJY_code\endoscopemfc2012_menu_changepara_youhua_savepic_USB_1114_twothread_svepic_save5\src\EndoScopeMFC\ProcessCard.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R0PAVCFileException@@@8			; CFileException * `RTTI Type Descriptor'
PUBLIC	??_R0PAVCMemoryException@@@8			; CMemoryException * `RTTI Type Descriptor'
EXTRN	__imp__ClearCommError@12:PROC
;	COMDAT ??_R0PAVCMemoryException@@@8
_DATA	SEGMENT
??_R0PAVCMemoryException@@@8 DD FLAT:??_7type_info@@6B@	; CMemoryException * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAVCMemoryException@@', 00H
_DATA	ENDS
;	COMDAT ??_R0PAVCFileException@@@8
_DATA	SEGMENT
??_R0PAVCFileException@@@8 DD FLAT:??_7type_info@@6B@	; CFileException * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAVCFileException@@', 00H
	ORG $+3
$SG4294928601 DB 'Error', 00H
PUBLIC	?OnRecv@CProcessCard@@QAEIPAX@Z			; CProcessCard::OnRecv
PUBLIC	?GetBytesInCOM@CProcessCard@@AAEIXZ		; CProcessCard::GetBytesInCOM
PUBLIC	?RecvHandler@CProcessCard@@SAIPAX@Z		; CProcessCard::RecvHandler
PUBLIC	?Release@CProcessCard@@QAEXXZ			; CProcessCard::Release
PUBLIC	??0CProcessCard@@QAE@XZ				; CProcessCard::CProcessCard
PUBLIC	??1CProcessCard@@QAE@XZ				; CProcessCard::~CProcessCard
PUBLIC	?Initialize@CProcessCard@@QAE_NV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ; CProcessCard::Initialize
PUBLIC	?SendData@CProcessCard@@QAEHPAEH@Z		; CProcessCard::SendData
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?SendData@CProcessCard@@QAEHPAEH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SendData@CProcessCard@@QAEHPAEH@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SendData@CProcessCard@@QAEHPAEH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SendData@CProcessCard@@QAEHPAEH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?SendData@CProcessCard@@QAEHPAEH@Z DD 00H
	DD	00H
	DD	01H
	DD	03H
	DD	FLAT:__catchsym$?SendData@CProcessCard@@QAEHPAEH@Z$4
__catchsym$?SendData@CProcessCard@@QAEHPAEH@Z$4 DD 00H
	DD	FLAT:??_R0PAVCMemoryException@@@8
	DD	0ffffffdcH
	DD	FLAT:__catch$?SendData@CProcessCard@@QAEHPAEH@Z$0
	DD	00H
	DD	FLAT:??_R0PAVCFileException@@@8
	DD	0ffffffd8H
	DD	FLAT:__catch$?SendData@CProcessCard@@QAEHPAEH@Z$1
	DD	00H
	DD	FLAT:??_R0PAVCException@@@8
	DD	0ffffffd4H
	DD	FLAT:__catch$?SendData@CProcessCard@@QAEHPAEH@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Initialize@CProcessCard@@QAE_NV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Initialize@CProcessCard@@QAE_NV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Initialize@CProcessCard@@QAE_NV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Initialize@CProcessCard@@QAE_NV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z$0
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\processcard.cpp
;	COMDAT ?SendData@CProcessCard@@QAEHPAEH@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
_RTN$ = -28						; size = 4
_dwWrite$ = -24						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_buf$ = 8						; size = 4
_size$ = 12						; size = 4
?SendData@CProcessCard@@QAEHPAEH@Z PROC			; CProcessCard::SendData, COMDAT
; _this$ = ecx

; 133  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SendData@CProcessCard@@QAEHPAEH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001f	53		 push	 ebx
  00020	56		 push	 esi
  00021	57		 push	 edi
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002f	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 134  : 	/*int nWriteLog = GetPrivateProfileInt("CFG","WriteLog",0,"testBitmap.ini");
; 135  : 	if ( 1 == nWriteLog )
; 136  : 	{
; 137  : 	CString sLog;
; 138  : 	sLog.Format("-----------------------------------------------------CurB:%03d,F:%03d,E:%02d,V:%02d,N:%d",g_nAvg,g_nPeek,g_nExposure,buf[5],999);
; 139  : 	WriteLog(sLog);
; 140  : 	}*/
; 141  : 	;
; 142  : 	if (m_bExitFlag)

  00032	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00035	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00038	85 c9		 test	 ecx, ecx
  0003a	74 04		 je	 SHORT $LN2@SendData

; 143  : 	{
; 144  : 		return FALSE;

  0003c	33 c0		 xor	 eax, eax
  0003e	eb 70		 jmp	 SHORT $LN3@SendData
$LN2@SendData:

; 145  : 	}
; 146  : 	DWORD dwWrite = 0;

  00040	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _dwWrite$[ebp], 0

; 147  : 
; 148  : 	BOOL RTN = FALSE;

  00047	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _RTN$[ebp], 0

; 149  : 	try
; 150  : 	{

  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 151  : 		RTN = WriteFile(m_hCom, (LPCVOID)buf, size, &dwWrite, NULL);

  00055	6a 00		 push	 0
  00057	8d 55 e8	 lea	 edx, DWORD PTR _dwWrite$[ebp]
  0005a	52		 push	 edx
  0005b	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  0005e	50		 push	 eax
  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00062	51		 push	 ecx
  00063	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  00066	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00069	50		 push	 eax
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  00070	89 45 e4	 mov	 DWORD PTR _RTN$[ebp], eax

; 152  : 	}

  00073	eb 12		 jmp	 SHORT $LN5@SendData
__catch$?SendData@CProcessCard@@QAEHPAEH@Z$0:

; 153  : 
; 154  : 	catch (CMemoryException* e)
; 155  : 	{
; 156  : 		
; 157  : 	}

  00075	b8 00 00 00 00	 mov	 eax, $LN10@SendData
  0007a	c3		 ret	 0
__catch$?SendData@CProcessCard@@QAEHPAEH@Z$1:

; 158  : 	catch (CFileException* e)
; 159  : 	{
; 160  : 	}

  0007b	b8 00 00 00 00	 mov	 eax, $LN12@SendData
  00080	c3		 ret	 0
__catch$?SendData@CProcessCard@@QAEHPAEH@Z$2:

; 161  : 	catch (CException* e)
; 162  : 	{
; 163  : 	}

  00081	b8 00 00 00 00	 mov	 eax, $LN14@SendData
  00086	c3		 ret	 0
$LN5@SendData:
  00087	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0008e	eb 09		 jmp	 SHORT $LN13@SendData
$LN14@SendData:
  00090	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00097	eb 14		 jmp	 SHORT __tryend$?SendData@CProcessCard@@QAEHPAEH@Z$3
$LN13@SendData:
  00099	eb 09		 jmp	 SHORT $LN11@SendData
$LN12@SendData:
  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 158  : 	catch (CFileException* e)
; 159  : 	{
; 160  : 	}

  000a2	eb 09		 jmp	 SHORT __tryend$?SendData@CProcessCard@@QAEHPAEH@Z$3
$LN11@SendData:
  000a4	eb 07		 jmp	 SHORT __tryend$?SendData@CProcessCard@@QAEHPAEH@Z$3
$LN10@SendData:
  000a6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?SendData@CProcessCard@@QAEHPAEH@Z$3:

; 164  : 
; 165  : 	//打出log代码，实际发布时屏蔽
; 166  : 	/*
; 167  : 	CString cstemp;
; 168  : 	CString csbuf;
; 169  : 	for(int j = 0; j<(pBuf-sndBuf); j++)
; 170  : 	{
; 171  : 		cstemp.Format(_T("%02X "),(unsigned char)sndBuf[j]);
; 172  : 		csbuf = csbuf + cstemp;
; 173  : 	}
; 174  : 	
; 175  : 	TRACE(csbuf);	
; 176  : 	CString filePath;
; 177  : 	filePath = ReturnPath();
; 178  : 	filePath += "\\Voice\\SendCOMLOG.txt";
; 179  : 	WriteComLog(csbuf,filePath);*/
; 180  : 	
; 181  : 	return RTN;

  000ad	8b 45 e4	 mov	 eax, DWORD PTR _RTN$[ebp]
$LN3@SendData:

; 182  : }

  000b0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ba	59		 pop	 ecx
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	5b		 pop	 ebx
  000be	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c1	33 cd		 xor	 ecx, ebp
  000c3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?SendData@CProcessCard@@QAEHPAEH@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00014	33 c8		 xor	 ecx, eax
  00016	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SendData@CProcessCard@@QAEHPAEH@Z
  00020	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SendData@CProcessCard@@QAEHPAEH@Z ENDP			; CProcessCard::SendData
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\processcard.cpp
;	COMDAT ?Initialize@CProcessCard@@QAE_NV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
_TEXT	SEGMENT
$T2 = -77						; size = 1
$T3 = -76						; size = 1
$T4 = -75						; size = 1
$T5 = -74						; size = 1
$T6 = -73						; size = 1
_this$ = -72						; size = 4
_lpMsgBuf$7 = -68					; size = 4
_dcb$ = -64						; size = 28
_timeouts$ = -36					; size = 20
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_comName$ = 8						; size = 4
_nBaudRate$ = 12					; size = 4
?Initialize@CProcessCard@@QAE_NV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z PROC ; CProcessCard::Initialize, COMDAT
; _this$ = ecx

; 36   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Initialize@CProcessCard@@QAE_NV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d b8	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 37   : 
; 38   : 	// 初始化变量
; 39   : 	m_rSize = 0;

  00032	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 40   : 	memset(m_rBuf, 0, sizeof(m_rBuf));

  0003c	68 00 01 00 00	 push	 256			; 00000100H
  00041	6a 00		 push	 0
  00043	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	83 c1 14	 add	 ecx, 20			; 00000014H
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 _memset
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 41   : 
; 42   : 	// 打开串口
; 43   : 	m_hCom = CreateFile(comName,
; 44   : 						GENERIC_READ | GENERIC_WRITE,
; 45   : 						0,    // Exclusive access 
; 46   : 						NULL, // No security attributes 
; 47   : 						OPEN_EXISTING,
; 48   : 						0,    // FILE_FLAG_OVERLAPPED
; 49   : 						NULL);

  00052	6a 00		 push	 0
  00054	6a 00		 push	 0
  00056	6a 03		 push	 3
  00058	6a 00		 push	 0
  0005a	6a 00		 push	 0
  0005c	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  00061	8d 4d 08	 lea	 ecx, DWORD PTR _comName$[ebp]
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  0006a	50		 push	 eax
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00071	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  00074	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 50   : 	if (m_hCom == INVALID_HANDLE_VALUE) {

  00077	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	83 78 04 ff	 cmp	 DWORD PTR [eax+4], -1
  0007e	75 1c		 jne	 SHORT $LN5@Initialize

; 51   : 		// 打开失败
; 52   : //		AfxMessageBox(_T("打开COM失败"));
; 53   : 		return false;

  00080	c6 45 b3 00	 mov	 BYTE PTR $T2[ebp], 0
  00084	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0008b	8d 4d 08	 lea	 ecx, DWORD PTR _comName$[ebp]
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00094	8a 45 b3	 mov	 al, BYTE PTR $T2[ebp]
  00097	e9 7b 01 00 00	 jmp	 $LN6@Initialize
$LN5@Initialize:

; 54   : 	}
; 55   : 	if(nBaudRate>0) {

  0009c	83 7d 0c 00	 cmp	 DWORD PTR _nBaudRate$[ebp], 0
  000a0	7e 09		 jle	 SHORT $LN4@Initialize

; 56   : 		// 设置比特率
; 57   : 		m_nBaudRate = nBaudRate;

  000a2	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	8b 55 0c	 mov	 edx, DWORD PTR _nBaudRate$[ebp]
  000a8	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$LN4@Initialize:

; 58   : 	}
; 59   : 
; 60   : 	// 取得指定串口的当前状态
; 61   : 	DCB dcb;
; 62   : 	if(!GetCommState(m_hCom,(LPDCB)&dcb)) {

  000ab	8d 45 c0	 lea	 eax, DWORD PTR _dcb$[ebp]
  000ae	50		 push	 eax
  000af	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b2	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000b5	52		 push	 edx
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCommState@8
  000bc	85 c0		 test	 eax, eax
  000be	75 1c		 jne	 SHORT $LN3@Initialize

; 63   : 		return false;

  000c0	c6 45 b4 00	 mov	 BYTE PTR $T3[ebp], 0
  000c4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000cb	8d 4d 08	 lea	 ecx, DWORD PTR _comName$[ebp]
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000d4	8a 45 b4	 mov	 al, BYTE PTR $T3[ebp]
  000d7	e9 3b 01 00 00	 jmp	 $LN6@Initialize
$LN3@Initialize:

; 64   : 	}
; 65   : 
; 66   : 	dcb.BaudRate = (DWORD)m_nBaudRate;

  000dc	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  000df	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000e2	89 4d c4	 mov	 DWORD PTR _dcb$[ebp+4], ecx

; 67   : 	dcb.ByteSize = 8;

  000e5	c6 45 d2 08	 mov	 BYTE PTR _dcb$[ebp+18], 8

; 68   : 	dcb.Parity = NOPARITY;

  000e9	c6 45 d3 00	 mov	 BYTE PTR _dcb$[ebp+19], 0

; 69   : 	dcb.StopBits = ONESTOPBIT;

  000ed	c6 45 d4 00	 mov	 BYTE PTR _dcb$[ebp+20], 0

; 70   : 	dcb.fBinary = 1;

  000f1	8b 55 c8	 mov	 edx, DWORD PTR _dcb$[ebp+8]
  000f4	83 ca 01	 or	 edx, 1
  000f7	89 55 c8	 mov	 DWORD PTR _dcb$[ebp+8], edx

; 71   : 
; 72   : 	// 设置指定串口状态
; 73   : 	if(!SetCommState(m_hCom, &dcb)) {

  000fa	8d 45 c0	 lea	 eax, DWORD PTR _dcb$[ebp]
  000fd	50		 push	 eax
  000fe	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  00101	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00104	52		 push	 edx
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCommState@8
  0010b	85 c0		 test	 eax, eax
  0010d	75 57		 jne	 SHORT $LN2@Initialize

; 74   : 		LPVOID lpMsgBuf;
; 75   : 		FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
; 76   : 					  FORMAT_MESSAGE_FROM_SYSTEM | 
; 77   : 					  FORMAT_MESSAGE_IGNORE_INSERTS,
; 78   : 					  NULL,
; 79   : 					  GetLastError(),
; 80   : 					  0, 
; 81   : 					  (LPTSTR)&lpMsgBuf,
; 82   : 					  0,
; 83   : 					  NULL);

  0010f	6a 00		 push	 0
  00111	6a 00		 push	 0
  00113	8d 45 bc	 lea	 eax, DWORD PTR _lpMsgBuf$7[ebp]
  00116	50		 push	 eax
  00117	6a 00		 push	 0
  00119	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0011f	50		 push	 eax
  00120	6a 00		 push	 0
  00122	68 00 13 00 00	 push	 4864			; 00001300H
  00127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FormatMessageA@28

; 84   : 		MessageBox(NULL, (LPCTSTR)lpMsgBuf, _T("Error"), MB_OK | MB_ICONINFORMATION);

  0012d	6a 40		 push	 64			; 00000040H
  0012f	68 00 00 00 00	 push	 OFFSET $SG4294928601
  00134	8b 4d bc	 mov	 ecx, DWORD PTR _lpMsgBuf$7[ebp]
  00137	51		 push	 ecx
  00138	6a 00		 push	 0
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 85   : 		LocalFree(lpMsgBuf);

  00140	8b 55 bc	 mov	 edx, DWORD PTR _lpMsgBuf$7[ebp]
  00143	52		 push	 edx
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LocalFree@4

; 86   : 		return false;

  0014a	c6 45 b6 00	 mov	 BYTE PTR $T5[ebp], 0
  0014e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00155	8d 4d 08	 lea	 ecx, DWORD PTR _comName$[ebp]
  00158	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0015e	8a 45 b6	 mov	 al, BYTE PTR $T5[ebp]
  00161	e9 b1 00 00 00	 jmp	 $LN6@Initialize
$LN2@Initialize:

; 87   : 	}
; 88   : 	
; 89   : 	// 设置超时
; 90   : 	COMMTIMEOUTS timeouts;
; 91   : 	timeouts.ReadIntervalTimeout			= MAXDWORD; // 读间隔超时

  00166	c7 45 dc ff ff
	ff ff		 mov	 DWORD PTR _timeouts$[ebp], -1

; 92   : 	timeouts.ReadTotalTimeoutMultiplier		= 0; // 读时间系数

  0016d	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _timeouts$[ebp+4], 0

; 93   : 	timeouts.ReadTotalTimeoutConstant		= 0; // 读时间常量

  00174	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _timeouts$[ebp+8], 0

; 94   : 	timeouts.WriteTotalTimeoutMultiplier	= 0; // 写时间系数

  0017b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _timeouts$[ebp+12], 0

; 95   : 	timeouts.WriteTotalTimeoutConstant		= 1000; // 写时间常量(1秒后写超时)

  00182	c7 45 ec e8 03
	00 00		 mov	 DWORD PTR _timeouts$[ebp+16], 1000 ; 000003e8H

; 96   : 
; 97   : 	if (!SetCommTimeouts(m_hCom, &timeouts)) {

  00189	8d 45 dc	 lea	 eax, DWORD PTR _timeouts$[ebp]
  0018c	50		 push	 eax
  0018d	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  00190	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00193	52		 push	 edx
  00194	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetCommTimeouts@8
  0019a	85 c0		 test	 eax, eax
  0019c	75 19		 jne	 SHORT $LN1@Initialize

; 98   : 		// 设置超时失败
; 99   : 		return false;

  0019e	c6 45 b5 00	 mov	 BYTE PTR $T4[ebp], 0
  001a2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001a9	8d 4d 08	 lea	 ecx, DWORD PTR _comName$[ebp]
  001ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001b2	8a 45 b5	 mov	 al, BYTE PTR $T4[ebp]
  001b5	eb 60		 jmp	 SHORT $LN6@Initialize
$LN1@Initialize:

; 100  : 	}
; 101  : 
; 102  : 	// 设置串口读缓冲和写缓冲的大小
; 103  : 	SetupComm(m_hCom, 1024*4, 512*4);

  001b7	68 00 08 00 00	 push	 2048			; 00000800H
  001bc	68 00 10 00 00	 push	 4096			; 00001000H
  001c1	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  001c4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001c7	51		 push	 ecx
  001c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetupComm@12

; 104  : 
; 105  : 	// 清空串口读写缓冲区
; 106  : 	PurgeComm(m_hCom, PURGE_RXCLEAR | PURGE_TXCLEAR);

  001ce	6a 0c		 push	 12			; 0000000cH
  001d0	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  001d3	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001d6	50		 push	 eax
  001d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PurgeComm@8

; 107  : 
; 108  : 	// 启动线程
; 109  : 	/*tmpTheApp->*/m_comThread = AfxBeginThread(CProcessCard::RecvHandler, this, THREAD_PRIORITY_HIGHEST);

  001dd	6a 00		 push	 0
  001df	6a 00		 push	 0
  001e1	6a 00		 push	 0
  001e3	6a 02		 push	 2
  001e5	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  001e8	51		 push	 ecx
  001e9	68 00 00 00 00	 push	 OFFSET ?RecvHandler@CProcessCard@@SAIPAX@Z ; CProcessCard::RecvHandler
  001ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?AfxBeginThread@@YGPAVCWinThread@@P6AIPAX@Z0HIKPAU_SECURITY_ATTRIBUTES@@@Z
  001f4	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  001f7	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 110  : 	m_bExitFlag = FALSE;

  001fa	8b 45 b8	 mov	 eax, DWORD PTR _this$[ebp]
  001fd	c6 00 00	 mov	 BYTE PTR [eax], 0

; 111  : 
; 112  : 	return true;

  00200	c6 45 b7 01	 mov	 BYTE PTR $T6[ebp], 1
  00204	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0020b	8d 4d 08	 lea	 ecx, DWORD PTR _comName$[ebp]
  0020e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00214	8a 45 b7	 mov	 al, BYTE PTR $T6[ebp]
$LN6@Initialize:

; 113  : }

  00217	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0021a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00221	59		 pop	 ecx
  00222	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00225	33 cd		 xor	 ecx, ebp
  00227	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0022c	8b e5		 mov	 esp, ebp
  0022e	5d		 pop	 ebp
  0022f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Initialize@CProcessCard@@QAE_NV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _comName$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?Initialize@CProcessCard@@QAE_NV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Initialize@CProcessCard@@QAE_NV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Initialize@CProcessCard@@QAE_NV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z ENDP ; CProcessCard::Initialize
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\processcard.cpp
;	COMDAT ??1CProcessCard@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CProcessCard@@QAE@XZ PROC				; CProcessCard::~CProcessCard, COMDAT
; _this$ = ecx

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 29   : 	Release();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Release@CProcessCard@@QAEXXZ ; CProcessCard::Release

; 30   : }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1CProcessCard@@QAE@XZ ENDP				; CProcessCard::~CProcessCard
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\processcard.cpp
;	COMDAT ??0CProcessCard@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CProcessCard@@QAE@XZ PROC				; CProcessCard::CProcessCard, COMDAT
; _this$ = ecx

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 18   : 	// 初始化
; 19   : 	m_hCom = INVALID_HANDLE_VALUE;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1

; 20   : 	m_nBaudRate = CBR_9600; // 初始化波特率

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 0c 80 25
	00 00		 mov	 DWORD PTR [ecx+12], 9600 ; 00002580H

; 21   : 	m_bExitFlag = TRUE;

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c6 02 01	 mov	 BYTE PTR [edx], 1

; 22   : 	m_comThread = NULL;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 23   : 	m_pDataHandler = NULL;

  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	c7 81 14 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+276], 0

; 24   : }

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??0CProcessCard@@QAE@XZ ENDP				; CProcessCard::CProcessCard
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\processcard.cpp
;	COMDAT ?Release@CProcessCard@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Release@CProcessCard@@QAEXXZ PROC			; CProcessCard::Release, COMDAT
; _this$ = ecx

; 117  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 118  : 	if(!m_bExitFlag)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0000d	85 c9		 test	 ecx, ecx
  0000f	75 18		 jne	 SHORT $LN2@Release

; 119  : 	{
; 120  : 		m_bExitFlag = TRUE;

  00011	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00014	c6 02 01	 mov	 BYTE PTR [edx], 1

; 121  : 		::WaitForSingleObject(m_comThread->m_hThread,10);

  00017	6a 0a		 push	 10			; 0000000aH
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001f	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00022	52		 push	 edx
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
$LN2@Release:

; 122  : 	}
; 123  : 	if(m_hCom != INVALID_HANDLE_VALUE) 

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	83 78 04 ff	 cmp	 DWORD PTR [eax+4], -1
  00030	74 17		 je	 SHORT $LN3@Release

; 124  : 	{
; 125  : 		CloseHandle(m_hCom);

  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00038	52		 push	 edx
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 126  : 		m_hCom = INVALID_HANDLE_VALUE;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1
$LN3@Release:

; 127  : 	}
; 128  : 
; 129  : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?Release@CProcessCard@@QAEXXZ ENDP			; CProcessCard::Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\processcard.cpp
;	COMDAT ?RecvHandler@CProcessCard@@SAIPAX@Z
_TEXT	SEGMENT
_lpParam$ = 8						; size = 4
?RecvHandler@CProcessCard@@SAIPAX@Z PROC		; CProcessCard::RecvHandler, COMDAT

; 186  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 	return ((CProcessCard*)(lpParam))->OnRecv(lpParam);

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpParam$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _lpParam$[ebp]
  0000a	e8 00 00 00 00	 call	 ?OnRecv@CProcessCard@@QAEIPAX@Z ; CProcessCard::OnRecv

; 188  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?RecvHandler@CProcessCard@@SAIPAX@Z ENDP		; CProcessCard::RecvHandler
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\processcard.cpp
;	COMDAT ?GetBytesInCOM@CProcessCard@@AAEIXZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_BytesInQue$ = -24					; size = 4
_comstat$ = -20						; size = 12
_dwError$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?GetBytesInCOM@CProcessCard@@AAEIXZ PROC		; CProcessCard::GetBytesInCOM, COMDAT
; _this$ = ecx

; 190  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 191  : 	DWORD dwError = 0;  /** 错误码 */

  00013	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dwError$[ebp], 0

; 192  : 	COMSTAT  comstat;   /** COMSTAT结构体,记录通信设备的状态信息 */
; 193  : 	memset(&comstat, 0, sizeof(COMSTAT));

  0001a	33 c0		 xor	 eax, eax
  0001c	89 45 ec	 mov	 DWORD PTR _comstat$[ebp], eax
  0001f	89 45 f0	 mov	 DWORD PTR _comstat$[ebp+4], eax
  00022	89 45 f4	 mov	 DWORD PTR _comstat$[ebp+8], eax

; 194  : 
; 195  : 	UINT BytesInQue = 0;

  00025	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _BytesInQue$[ebp], 0

; 196  : 	/** 在调用ReadFile和WriteFile之前,通过本函数清除以前遗留的错误标志 */
; 197  : 	if (ClearCommError(m_hCom, &dwError, &comstat))

  0002c	8d 4d ec	 lea	 ecx, DWORD PTR _comstat$[ebp]
  0002f	51		 push	 ecx
  00030	8d 55 f8	 lea	 edx, DWORD PTR _dwError$[ebp]
  00033	52		 push	 edx
  00034	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003a	51		 push	 ecx
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ClearCommError@12
  00041	85 c0		 test	 eax, eax
  00043	74 06		 je	 SHORT $LN1@GetBytesIn

; 198  : 	{
; 199  : 		BytesInQue = comstat.cbInQue; /** 获取在输入缓冲区中的字节数 */

  00045	8b 55 f0	 mov	 edx, DWORD PTR _comstat$[ebp+4]
  00048	89 55 e8	 mov	 DWORD PTR _BytesInQue$[ebp], edx
$LN1@GetBytesIn:

; 200  : 	}
; 201  : 
; 202  : 	return BytesInQue;

  0004b	8b 45 e8	 mov	 eax, DWORD PTR _BytesInQue$[ebp]

; 203  : }

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00051	33 cd		 xor	 ecx, ebp
  00053	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
?GetBytesInCOM@CProcessCard@@AAEIXZ ENDP		; CProcessCard::GetBytesInCOM
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\processcard.cpp
;	COMDAT ?OnRecv@CProcessCard@@QAEIPAX@Z
_TEXT	SEGMENT
_pCom$ = -28						; size = 4
_bRet$ = -24						; size = 4
_this$ = -20						; size = 4
_testdata$1 = -13					; size = 1
_BytesInQue$2 = -12					; size = 4
_dwSize$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpParam$ = 8						; size = 4
?OnRecv@CProcessCard@@QAEIPAX@Z PROC			; CProcessCard::OnRecv, COMDAT
; _this$ = ecx

; 207  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 	CProcessCard* pCom =(CProcessCard*)lpParam;

  00013	8b 45 08	 mov	 eax, DWORD PTR _lpParam$[ebp]
  00016	89 45 e4	 mov	 DWORD PTR _pCom$[ebp], eax

; 209  : 	DWORD dwSize=0;

  00019	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dwSize$[ebp], 0

; 210  : 	BOOL bRet = TRUE;

  00020	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _bRet$[ebp], 1
$LN7@OnRecv:

; 211  : 	//BYTE buf[32] = {0};
; 212  : 	//CString dbgbuf,dbgtemp;
; 213  : 	//char testdat[]="";
; 214  : 	while (1) 

  00027	b9 01 00 00 00	 mov	 ecx, 1
  0002c	85 c9		 test	 ecx, ecx
  0002e	74 4c		 je	 SHORT $LN6@OnRecv

; 215  : 	{	char testdata=0;

  00030	c6 45 f3 00	 mov	 BYTE PTR _testdata$1[ebp], 0

; 216  : 		dwSize = 0;

  00034	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dwSize$[ebp], 0

; 217  : 		UINT BytesInQue = pCom->GetBytesInCOM();

  0003b	8b 4d e4	 mov	 ecx, DWORD PTR _pCom$[ebp]
  0003e	e8 00 00 00 00	 call	 ?GetBytesInCOM@CProcessCard@@AAEIXZ ; CProcessCard::GetBytesInCOM
  00043	89 45 f4	 mov	 DWORD PTR _BytesInQue$2[ebp], eax
$LN5@OnRecv:

; 218  : 		do
; 219  : 		{
; 220  : 			bRet = ReadFile(m_hCom,			  // 串口句柄
; 221  : 						&m_rBuf, // 缓冲
; 222  : 						1,				  // 完成一次读串口操作需要读出的字节数总数
; 223  : 						&dwSize,	      // 完成一次读串口操作后实际读出的字节总数
; 224  : 						NULL );

  00046	6a 00		 push	 0
  00048	8d 55 f8	 lea	 edx, DWORD PTR _dwSize$[ebp]
  0004b	52		 push	 edx
  0004c	6a 01		 push	 1
  0004e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00051	83 c0 14	 add	 eax, 20			; 00000014H
  00054	50		 push	 eax
  00055	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0005b	52		 push	 edx
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  00062	89 45 e8	 mov	 DWORD PTR _bRet$[ebp], eax

; 225  : 					// 串口无效，关闭串口就退出了线程
; 226  : 			if(!bRet)

  00065	83 7d e8 00	 cmp	 DWORD PTR _bRet$[ebp], 0
  00069	75 04		 jne	 SHORT $LN4@OnRecv

; 227  : 				return 0;

  0006b	33 c0		 xor	 eax, eax
  0006d	eb 12		 jmp	 SHORT $LN8@OnRecv
$LN4@OnRecv:

; 228  : 			if(dwSize > 0)
; 229  : 			{
; 230  : 				//cout<<m_rBuf;
; 231  : 			}
; 232  : 
; 233  : 
; 234  : 		}while(--BytesInQue);

  0006f	8b 45 f4	 mov	 eax, DWORD PTR _BytesInQue$2[ebp]
  00072	83 e8 01	 sub	 eax, 1
  00075	89 45 f4	 mov	 DWORD PTR _BytesInQue$2[ebp], eax
  00078	75 cc		 jne	 SHORT $LN5@OnRecv

; 235  : 		// 如果读到数据
; 236  : 	}

  0007a	eb ab		 jmp	 SHORT $LN7@OnRecv
$LN6@OnRecv:

; 237  : 	return 1;

  0007c	b8 01 00 00 00	 mov	 eax, 1
$LN8@OnRecv:

; 238  : }

  00081	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00084	33 cd		 xor	 ecx, ebp
  00086	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 04 00	 ret	 4
?OnRecv@CProcessCard@@QAEIPAX@Z ENDP			; CProcessCard::OnRecv
_TEXT	ENDS
END
