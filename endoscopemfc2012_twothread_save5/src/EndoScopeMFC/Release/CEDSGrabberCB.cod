; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

	TITLE	E:\work_wm\HXIJY_code\endoscopemfc2012_menu_changepara_youhua_savepic_USB_1114_twothread_svepic_save5\src\EndoScopeMFC\CEDSGrabberCB.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R2CEDSGrabberCB@@8				; CEDSGrabberCB::`RTTI Base Class Array'
PUBLIC	??_R2ISampleGrabberCB@@8			; ISampleGrabberCB::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CEDSGrabberCB@@8			; CEDSGrabberCB::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ISampleGrabberCB@@8		; ISampleGrabberCB::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUIUnknown@@@8				; IUnknown `RTTI Type Descriptor'
PUBLIC	??_R2IUnknown@@8				; IUnknown::`RTTI Base Class Array'
PUBLIC	??_R3IUnknown@@8				; IUnknown::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@IUnknown@@8			; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3CEDSGrabberCB@@8				; CEDSGrabberCB::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCEDSGrabberCB@@@8			; CEDSGrabberCB `RTTI Type Descriptor'
PUBLIC	??_R3ISampleGrabberCB@@8			; ISampleGrabberCB::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AUISampleGrabberCB@@@8			; ISampleGrabberCB `RTTI Type Descriptor'
PUBLIC	??_R4CEDSGrabberCB@@6B@				; CEDSGrabberCB::`RTTI Complete Object Locator'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_7CEDSGrabberCB@@6B@				; CEDSGrabberCB::`vftable'
EXTRN	_atexit:PROC
EXTRN	__imp___purecall:PROC
EXTRN	__imp_?_Syserror_map@std@@YAPBDH@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	_IID_IUnknown:BYTE
EXTRN	_IID_ISampleGrabberCB:BYTE
EXTRN	__imp_??_V@YAXPAX@Z:PROC
EXTRN	__imp_??_U@YAPAXI@Z:PROC
EXTRN	__imp__memmove:PROC
EXTRN	__imp_??2@YAPAXI@Z:PROC
EXTRN	__imp_??3@YAXPAX@Z:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__purecall:PROC
;	COMDAT ??_7CEDSGrabberCB@@6B@
CONST	SEGMENT
??_7CEDSGrabberCB@@6B@ DD FLAT:??_R4CEDSGrabberCB@@6B@	; CEDSGrabberCB::`vftable'
	DD	FLAT:?QueryInterface@CEDSGrabberCB@@UAGJABU_GUID@@PAPAX@Z
	DD	FLAT:?AddRef@CEDSGrabberCB@@UAGKXZ
	DD	FLAT:?Release@CEDSGrabberCB@@UAGKXZ
	DD	FLAT:?SampleCB@CEDSGrabberCB@@UAGJNPAUIMediaSample@@@Z
	DD	FLAT:?BufferCB@CEDSGrabberCB@@UAGJNPAEJ@Z
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R4CEDSGrabberCB@@6B@
rdata$r	SEGMENT
??_R4CEDSGrabberCB@@6B@ DD 00H				; CEDSGrabberCB::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCEDSGrabberCB@@@8
	DD	FLAT:??_R3CEDSGrabberCB@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUISampleGrabberCB@@@8
_DATA	SEGMENT
??_R0?AUISampleGrabberCB@@@8 DD FLAT:??_7type_info@@6B@	; ISampleGrabberCB `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUISampleGrabberCB@@', 00H
_DATA	ENDS
;	COMDAT ??_R3ISampleGrabberCB@@8
rdata$r	SEGMENT
??_R3ISampleGrabberCB@@8 DD 00H				; ISampleGrabberCB::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ISampleGrabberCB@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCEDSGrabberCB@@@8
_DATA	SEGMENT
??_R0?AVCEDSGrabberCB@@@8 DD FLAT:??_7type_info@@6B@	; CEDSGrabberCB `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCEDSGrabberCB@@', 00H
_DATA	ENDS
;	COMDAT ??_R3CEDSGrabberCB@@8
rdata$r	SEGMENT
??_R3CEDSGrabberCB@@8 DD 00H				; CEDSGrabberCB::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CEDSGrabberCB@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IUnknown@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IUnknown@@8 DD FLAT:??_R0?AUIUnknown@@@8	; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R3IUnknown@@8
rdata$r	SEGMENT
??_R3IUnknown@@8 DD 00H					; IUnknown::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R2IUnknown@@8
rdata$r	SEGMENT
??_R2IUnknown@@8 DD FLAT:??_R1A@?0A@EA@IUnknown@@8	; IUnknown::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R0?AUIUnknown@@@8
_DATA	SEGMENT
??_R0?AUIUnknown@@@8 DD FLAT:??_7type_info@@6B@		; IUnknown `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIUnknown@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@ISampleGrabberCB@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ISampleGrabberCB@@8 DD FLAT:??_R0?AUISampleGrabberCB@@@8 ; ISampleGrabberCB::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ISampleGrabberCB@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CEDSGrabberCB@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CEDSGrabberCB@@8 DD FLAT:??_R0?AVCEDSGrabberCB@@@8 ; CEDSGrabberCB::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CEDSGrabberCB@@8
rdata$r	ENDS
;	COMDAT ??_R2ISampleGrabberCB@@8
rdata$r	SEGMENT
??_R2ISampleGrabberCB@@8 DD FLAT:??_R1A@?0A@EA@ISampleGrabberCB@@8 ; ISampleGrabberCB::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R2CEDSGrabberCB@@8
rdata$r	SEGMENT
??_R2CEDSGrabberCB@@8 DD FLAT:??_R1A@?0A@EA@CEDSGrabberCB@@8 ; CEDSGrabberCB::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ISampleGrabberCB@@8
	DD	FLAT:??_R1A@?0A@EA@IUnknown@@8
$SG4294967287 DB 00H
$SG4294967286 DB 00H, 00H
$SG4294967265 DB 'sec', 00H
PUBLIC	_IsEqualGUID
PUBLIC	??0IUnknown@@QAE@XZ				; IUnknown::IUnknown
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	_==
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	?Release@CEDSGrabberCB@@UAGKXZ			; CEDSGrabberCB::Release
PUBLIC	?AddRef@CEDSGrabberCB@@UAGKXZ			; CEDSGrabberCB::AddRef
PUBLIC	?BufferCB@CEDSGrabberCB@@UAGJNPAEJ@Z		; CEDSGrabberCB::BufferCB
PUBLIC	?CropImage@CEDSGrabberCB@@QAEXPAEPAPAE@Z	; CEDSGrabberCB::CropImage
PUBLIC	?SampleCB@CEDSGrabberCB@@UAGJNPAUIMediaSample@@@Z ; CEDSGrabberCB::SampleCB
PUBLIC	?QueryInterface@CEDSGrabberCB@@UAGJABU_GUID@@PAPAX@Z ; CEDSGrabberCB::QueryInterface
PUBLIC	??1CEDSGrabberCB@@QAE@XZ			; CEDSGrabberCB::~CEDSGrabberCB
PUBLIC	??0ISampleGrabberCB@@QAE@XZ			; ISampleGrabberCB::ISampleGrabberCB
PUBLIC	??0CEDSGrabberCB@@QAE@XZ			; CEDSGrabberCB::CEDSGrabberCB
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	__real@0000000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3ff3333333333333
PUBLIC	__real@3ff8000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@403e000000000000
PUBLIC	__real@406fe00000000000
PUBLIC	__real@4086800000000000
PUBLIC	__real@4094000000000000
PUBLIC	__real@412e848000000000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__ftol2:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@412e848000000000
CONST	SEGMENT
__real@412e848000000000 DQ 0412e848000000000r	; 1e+006
CONST	ENDS
;	COMDAT __real@4094000000000000
CONST	SEGMENT
__real@4094000000000000 DQ 04094000000000000r	; 1280
CONST	ENDS
;	COMDAT __real@4086800000000000
CONST	SEGMENT
__real@4086800000000000 DQ 04086800000000000r	; 720
CONST	ENDS
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@403e000000000000
CONST	SEGMENT
__real@403e000000000000 DQ 0403e000000000000r	; 30
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3ff8000000000000
CONST	SEGMENT
__real@3ff8000000000000 DQ 03ff8000000000000r	; 1.5
CONST	ENDS
;	COMDAT __real@3ff3333333333333
CONST	SEGMENT
__real@3ff3333333333333 DQ 03ff3333333333333r	; 1.2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
xdata$x	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\cedsgrabbercb.cpp
;	COMDAT ??0CEDSGrabberCB@@QAE@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
??0CEDSGrabberCB@@QAE@XZ PROC				; CEDSGrabberCB::CEDSGrabberCB, COMDAT
; _this$ = ecx

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0ISampleGrabberCB@@QAE@XZ
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CEDSGrabberCB@@6B@

; 18   : 	g_bStop = FALSE;

  0001a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_bStop@@3HA, 0 ; g_bStop

; 19   : 	//m_bwritevideo = false;
; 20   : 	//m_bwritepicture = false;
; 21   : 	//m_badjwhite = false;
; 22   : 	//m_bwhiteok = false;
; 23   : 	//m_dZoom=1.0;
; 24   : 	//roi_w = IMGWIDTH;
; 25   : 	//roi_h = IMGHEIGHT;
; 26   : 	//roi_c=(roi_w-IMGWIDTH)/2;
; 27   : 	//roi_r=(roi_h-IMGHEIGHT)/2;
; 28   : 	//m_src = Mat(Size(IMGWIDTH, IMGHEIGHT), CV_8UC3);
; 29   : 	//m_lamda = new double[IMGSIZE];
; 30   : 	//m_dst=Mat(Size(1536,864),CV_8UC3);
; 31   : 	//IniWhilteLamda();
; 32   : 	buf=new BYTE[IMGWIDTH*IMGHEIGHT*3+1];

  00024	68 01 30 2a 00	 push	 2764801			; 002a3001H
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??_U@YAPAXI@Z
  0002f	83 c4 04	 add	 esp, 4
  00032	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	8b 55 f8	 mov	 edx, DWORD PTR $T1[ebp]
  0003b	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 33   : 	//SetEvent(g_videoevent);
; 34   : 	//SetEvent(g_resizeevent);
; 35   : 	//SetEvent(g_capevent);
; 36   : 	//StartShowVideoThread();
; 37   : }

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??0CEDSGrabberCB@@QAE@XZ ENDP				; CEDSGrabberCB::CEDSGrabberCB
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0ISampleGrabberCB@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ISampleGrabberCB@@QAE@XZ PROC			; ISampleGrabberCB::ISampleGrabberCB, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0IUnknown@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0ISampleGrabberCB@@QAE@XZ ENDP			; ISampleGrabberCB::ISampleGrabberCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\cedsgrabbercb.cpp
;	COMDAT ??1CEDSGrabberCB@@QAE@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
??1CEDSGrabberCB@@QAE@XZ PROC				; CEDSGrabberCB::~CEDSGrabberCB, COMDAT
; _this$ = ecx

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CEDSGrabberCB@@6B@

; 41   : 	if(buf != NULL)

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  00019	74 20		 je	 SHORT $LN2@CEDSGrabbe

; 42   : 	{
; 43   : 		delete[] buf;

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00021	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00024	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00027	51		 push	 ecx
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??_V@YAXPAX@Z
  0002e	83 c4 04	 add	 esp, 4

; 44   : 		buf = NULL;

  00031	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00034	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0
$LN2@CEDSGrabbe:

; 45   : 	}
; 46   : 	//if (!m_pTaskList.empty())
; 47   : 	//{
; 48   : 	//	for (int i=0;i<m_pTaskList.size();++i)
; 49   : 	//	{
; 50   : 	//		BYTE* data = m_pTaskList.front();
; 51   : 	//		delete[]data;
; 52   : 	//		m_pTaskList.pop_front();
; 53   : 	//	}
; 54   : 	//	m_pTaskList.clear();
; 55   : 	//}
; 56   : 	//if (!m_pPicList.empty())
; 57   : 	//{
; 58   : 	//	for (int i=0;i<m_pPicList.size();++i)
; 59   : 	//	{
; 60   : 	//		BYTE* data = m_pPicList.front();
; 61   : 	//		delete[]data;
; 62   : 	//		m_pPicList.pop_front();
; 63   : 	//	}
; 64   : 	//	m_pPicList.clear();
; 65   : 	//}
; 66   : 	//if (!m_pShowList.empty())
; 67   : 	//{
; 68   : 	//	for (int i=0;i<m_pShowList.size();++i)
; 69   : 	//	{
; 70   : 	//		BYTE* data = m_pShowList.front();
; 71   : 	//		delete[]data;
; 72   : 	//		m_pShowList.pop_front();
; 73   : 	//	}
; 74   : 	//	m_pShowList.clear();
; 75   : 	//}
; 76   : 
; 77   : 	//if (m_lamda)
; 78   : 	//{
; 79   : 	//	delete[]m_lamda;
; 80   : 	//	m_lamda = NULL;
; 81   : 	//}
; 82   : 	//if (!m_src.empty())
; 83   : 	//{
; 84   : 	//	m_src.release();
; 85   : 	//	delete buf;
; 86   : 	//}
; 87   : 	//m_bshowvideo = false;
; 88   : }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1CEDSGrabberCB@@QAE@XZ ENDP				; CEDSGrabberCB::~CEDSGrabberCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\cedsgrabbercb.cpp
;	COMDAT ?QueryInterface@CEDSGrabberCB@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_riid$ = 12						; size = 4
_ppv$ = 16						; size = 4
?QueryInterface@CEDSGrabberCB@@UAGJABU_GUID@@PAPAX@Z PROC ; CEDSGrabberCB::QueryInterface, COMDAT

; 92   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	if (riid == IID_ISampleGrabberCB || riid == IID_IUnknown) {

  00003	68 00 00 00 00	 push	 OFFSET _IID_ISampleGrabberCB
  00008	8b 45 0c	 mov	 eax, DWORD PTR _riid$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _==
  00011	83 c4 08	 add	 esp, 8
  00014	0f b6 c8	 movzx	 ecx, al
  00017	85 c9		 test	 ecx, ecx
  00019	75 18		 jne	 SHORT $LN1@QueryInter
  0001b	68 00 00 00 00	 push	 OFFSET _IID_IUnknown
  00020	8b 55 0c	 mov	 edx, DWORD PTR _riid$[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 _==
  00029	83 c4 08	 add	 esp, 8
  0002c	0f b6 c0	 movzx	 eax, al
  0002f	85 c0		 test	 eax, eax
  00031	74 0c		 je	 SHORT $LN2@QueryInter
$LN1@QueryInter:

; 94   : 		*ppv = (void *) static_cast<ISampleGrabberCB*> (this);

  00033	8b 4d 10	 mov	 ecx, DWORD PTR _ppv$[ebp]
  00036	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00039	89 11		 mov	 DWORD PTR [ecx], edx

; 95   : 		return NOERROR;

  0003b	33 c0		 xor	 eax, eax
  0003d	eb 05		 jmp	 SHORT $LN3@QueryInter
$LN2@QueryInter:

; 96   : 	}
; 97   : 	return E_NOINTERFACE;

  0003f	b8 02 40 00 80	 mov	 eax, -2147467262	; 80004002H
$LN3@QueryInter:

; 98   : }

  00044	5d		 pop	 ebp
  00045	c2 0c 00	 ret	 12			; 0000000cH
?QueryInterface@CEDSGrabberCB@@UAGJABU_GUID@@PAPAX@Z ENDP ; CEDSGrabberCB::QueryInterface
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\cedsgrabbercb.cpp
;	COMDAT ?SampleCB@CEDSGrabberCB@@UAGJNPAUIMediaSample@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_SampleTime$ = 12					; size = 8
_pSample$ = 20						; size = 4
?SampleCB@CEDSGrabberCB@@UAGJNPAUIMediaSample@@@Z PROC	; CEDSGrabberCB::SampleCB, COMDAT

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 102  : 	return 0;

  00003	33 c0		 xor	 eax, eax

; 103  : }

  00005	5d		 pop	 ebp
  00006	c2 10 00	 ret	 16			; 00000010H
?SampleCB@CEDSGrabberCB@@UAGJNPAUIMediaSample@@@Z ENDP	; CEDSGrabberCB::SampleCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\cedsgrabbercb.cpp
;	COMDAT ?CropImage@CEDSGrabberCB@@QAEXPAEPAPAE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_t_dst$ = -4						; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?CropImage@CEDSGrabberCB@@QAEXPAEPAPAE@Z PROC		; CEDSGrabberCB::CropImage, COMDAT
; _this$ = ecx

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 106  : 	unsigned char *t_dst = *dst;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _dst$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR _t_dst$[ebp], ecx

; 107  : 	memcpy(t_dst,src+883200,IMGWIDTH*IMGHEIGHT*3);

  00011	68 00 30 2a 00	 push	 2764800			; 002a3000H
  00016	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  00019	81 c2 00 7a 0d
	00		 add	 edx, 883200		; 000d7a00H
  0001f	52		 push	 edx
  00020	8b 45 fc	 mov	 eax, DWORD PTR _t_dst$[ebp]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 _memcpy
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH

; 108  : #if 0
; 109  : 	int pos=0,oldpos=0;
; 110  : 
; 111  : 	for (int i = 0;i < IMGHEIGHT;++i)
; 112  : 	{
; 113  : 		for (int j = 0;j < IMGWIDTH;++j)
; 114  : 		{
; 115  : 			//printf("row:%d\n",i);
; 116  : 			//printf("col:%d\n",j);
; 117  : 			pos = i * IMGWIDTH * 3 + j * 3;
; 118  : 			oldpos=(i+230)*1280*3+(j)*3;//裁剪
; 119  : 
; 120  : 			t_dst[pos + 0] = src[oldpos + 0];//(int)(src[pos + 0] * m_lamda[pos + 0]);
; 121  : 
; 122  : 			t_dst[pos + 1] = src[oldpos + 1];
; 123  : 			t_dst[pos + 2] = src[oldpos + 2] ;//(int)(src[pos + 2] * m_lamda[pos + 2]);
; 124  : 
; 125  : 		}
; 126  : 	}
; 127  : #endif
; 128  : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 08 00	 ret	 8
?CropImage@CEDSGrabberCB@@QAEXPAEPAPAE@Z ENDP		; CEDSGrabberCB::CropImage
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\cedsgrabbercb.cpp
;	COMDAT ?BufferCB@CEDSGrabberCB@@UAGJNPAEJ@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_dblSampleTime$ = 12					; size = 8
_pBuffer$ = 20						; size = 4
_lBufferSize$ = 24					; size = 4
?BufferCB@CEDSGrabberCB@@UAGJNPAEJ@Z PROC		; CEDSGrabberCB::BufferCB, COMDAT

; 132  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 133  : 	if (!pBuffer)

  00003	83 7d 14 00	 cmp	 DWORD PTR _pBuffer$[ebp], 0
  00007	75 07		 jne	 SHORT $LN2@BufferCB

; 134  : 	{
; 135  : 		return E_POINTER;

  00009	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  0000e	eb 4c		 jmp	 SHORT $LN3@BufferCB
$LN2@BufferCB:

; 136  : 	}
; 137  : 	if (g_bStop)

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bStop@@3HA, 0 ; g_bStop
  00017	74 04		 je	 SHORT $LN1@BufferCB

; 138  : 	{
; 139  : 		return 0;

  00019	33 c0		 xor	 eax, eax
  0001b	eb 3f		 jmp	 SHORT $LN3@BufferCB
$LN1@BufferCB:

; 140  : 	}
; 141  : 	/*Mat src;
; 142  : 	src=imread("d://test2.png");
; 143  : 	BYTE* pbuftest=new BYTE[2880*2160*3];
; 144  : 	memcpy(pbuftest,src.data,2880*2160*3);*/
; 145  : 	//BYTE* buf=new BYTE[1280*720*3];
; 146  : 	memset(buf,0,IMGWIDTH*IMGHEIGHT*3);

  0001d	68 00 30 2a 00	 push	 2764800			; 002a3000H
  00022	6a 00		 push	 0
  00024	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 _memset
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 147  : 	CropImage(pBuffer,&buf);

  00033	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00036	83 c2 14	 add	 edx, 20			; 00000014H
  00039	52		 push	 edx
  0003a	8b 45 14	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?CropImage@CEDSGrabberCB@@QAEXPAEPAPAE@Z ; CEDSGrabberCB::CropImage

; 148  : 	//WaitForSingleObject(g_capevent, INFINITE);
; 149  : 	//m_pShowList.push_back(buf);//操作队列
; 150  : 	WritePackQueue(buf,IMGWIDTH*IMGHEIGHT*3);

  00046	68 00 30 2a 00	 push	 2764800			; 002a3000H
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00051	52		 push	 edx
  00052	e8 00 00 00 00	 call	 ?WritePackQueue@@YAXPAEH@Z ; WritePackQueue
  00057	83 c4 08	 add	 esp, 8

; 151  : 	//SetEvent(g_showevent);
; 152  : 	/*Mat tem=Mat(cvSize(2880,1530),CV_8UC3,buf);
; 153  : 	imshow("src",tem);
; 154  : 	waitKey(10);*/
; 155  : 	//计算白平衡参数
; 156  : #if 0
; 157  : 	if (m_badjwhite)
; 158  : 	{
; 159  : 		m_bwhiteok = false;
; 160  : 		CalWhilteLamda(buf);
; 161  : 		return 0;
; 162  : 	}
; 163  : 	//白平衡调整
; 164  : 	AdjWhiteBalance(buf, IMGWIDTH, IMGHEIGHT, &m_src.data);
; 165  : 
; 166  : 	//memcpy(m_src.data,pbuf,IMGSIZE);
; 167  : 	//grayWB->balanceWhite(m_src,m_src);
; 168  : 	if (m_src.empty())
; 169  : 	{
; 170  : 		return E_POINTER;
; 171  : 		//delete pbuftest;
; 172  : 		//delete buf;
; 173  : 	}
; 174  : 	//镜像处理
; 175  : 	flip(m_src, m_src, 0);
; 176  : 	//插值放大
; 177  : 	if (m_dZoom>1.0)
; 178  : 	{
; 179  : 		Mat t_img ;
; 180  : 		WaitForSingleObject(g_resizeevent, INFINITE);
; 181  : 		resize(m_src, t_img, cvSize(roi_w, roi_h), INTER_NEAREST);
; 182  : 		t_img(Rect(roi_c, roi_r, IMGWIDTH, IMGHEIGHT)).copyTo(m_src);
; 183  : 		SetEvent(g_resizeevent);
; 184  : 	}
; 185  : 	
; 186  : 	resize(m_src,m_dst,cvSize(1536,864),INTER_NEAREST);
; 187  : 	imshow("view", m_dst);
; 188  : 	//imwrite("test.jpg",m_dst);
; 189  : 	waitKey(1);
; 190  : 	g_FPS += 1;
; 191  : 	//录制视频
; 192  : 	if (m_bwritevideo)
; 193  : 	{
; 194  : 		unsigned char* pbuf = new unsigned char[IMGSIZE];
; 195  : 		memset(pbuf, 0, IMGSIZE);
; 196  : 		memcpy(pbuf, m_src.data, IMGSIZE);
; 197  : 		WaitForSingleObject(g_videoevent, INFINITE);
; 198  : 		m_pTaskList.push_back(pbuf);//操作队列
; 199  : 		SetEvent(g_videoevent);
; 200  : 	}
; 201  : 	if(m_bwritepicture)
; 202  : 	{
; 203  : 		unsigned char* pbuf = new unsigned char[IMGSIZE];
; 204  : 		memset(pbuf, 0, IMGSIZE);
; 205  : 		memcpy(pbuf, m_src.data, IMGSIZE);
; 206  : 	//	WaitForSingleObject(g_picevent, INFINITE);
; 207  : 		m_pPicList.push_back(pbuf);//操作队列
; 208  : 		SetEvent(g_picevent);
; 209  : 		m_bwritepicture = false;
; 210  : 	}
; 211  : 	//delete pbuftest;
; 212  : 			//delete buf;
; 213  : #endif
; 214  : 	return 0;

  0005a	33 c0		 xor	 eax, eax
$LN3@BufferCB:

; 215  : }

  0005c	5d		 pop	 ebp
  0005d	c2 14 00	 ret	 20			; 00000014H
?BufferCB@CEDSGrabberCB@@UAGJNPAEJ@Z ENDP		; CEDSGrabberCB::BufferCB
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\cedsgrabbercb.cpp
;	COMDAT ?AddRef@CEDSGrabberCB@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?AddRef@CEDSGrabberCB@@UAGKXZ PROC			; CEDSGrabberCB::AddRef, COMDAT

; 500  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 501  : 	return 2;

  00003	b8 02 00 00 00	 mov	 eax, 2

; 502  : }

  00008	5d		 pop	 ebp
  00009	c2 04 00	 ret	 4
?AddRef@CEDSGrabberCB@@UAGKXZ ENDP			; CEDSGrabberCB::AddRef
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\work_wm\hxijy_code\endoscopemfc2012_menu_changepara_youhua_savepic_usb_1114_twothread_svepic_save5\src\endoscopemfc\cedsgrabbercb.cpp
;	COMDAT ?Release@CEDSGrabberCB@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Release@CEDSGrabberCB@@UAGKXZ PROC			; CEDSGrabberCB::Release, COMDAT

; 505  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 506  : 	return 1;

  00003	b8 01 00 00 00	 mov	 eax, 1

; 507  : }

  00008	5d		 pop	 ebp
  00009	c2 04 00	 ret	 4
?Release@CEDSGrabberCB@@UAGKXZ ENDP			; CEDSGrabberCB::Release
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Generic_error_category@std@@UAE@XZ
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
  00008	e8 00 00 00 00	 call	 ??1_Iostream_error_category@std@@UAE@XZ
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\atlmfc\include\atlsimpstr.h
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 811  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
  00008	e8 00 00 00 00	 call	 ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	83 c4 04	 add	 esp, 4
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Generic_error_category@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0d		 je	 SHORT $LN1@scalar
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??3@YAXPAX@Z
  00021	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

  00007	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0error_category@std@@QAE@XZ ; std::error_category::error_category
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1error_category@std@@UAE@XZ ; std::error_category::~error_category
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0d		 je	 SHORT $LN1@scalar
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??3@YAXPAX@Z
  00021	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1error_category@std@@UAE@XZ ; std::error_category::~error_category
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Iostream_error_category@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0d		 je	 SHORT $LN1@scalar
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??3@YAXPAX@Z
  00021	83 c4 04	 add	 esp, 4
$LN1@scalar:
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

  00007	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -20						; size = 4
tv75 = -16						; size = 4
tv69 = -12						; size = 4
tv72 = -8						; size = 4
tv78 = -1						; size = 1
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0000c	85 c9		 test	 ecx, ecx
  0000e	75 09		 jne	 SHORT $LN3@length
  00010	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  00017	eb 30		 jmp	 SHORT $LN4@length
$LN3@length:
  00019	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001c	89 55 f8	 mov	 DWORD PTR tv72[ebp], edx
  0001f	8b 45 f8	 mov	 eax, DWORD PTR tv72[ebp]
  00022	83 c0 01	 add	 eax, 1
  00025	89 45 f0	 mov	 DWORD PTR tv75[ebp], eax
$LL5@length:
  00028	8b 4d f8	 mov	 ecx, DWORD PTR tv72[ebp]
  0002b	8a 11		 mov	 dl, BYTE PTR [ecx]
  0002d	88 55 ff	 mov	 BYTE PTR tv78[ebp], dl
  00030	83 45 f8 01	 add	 DWORD PTR tv72[ebp], 1
  00034	80 7d ff 00	 cmp	 BYTE PTR tv78[ebp], 0
  00038	75 ee		 jne	 SHORT $LL5@length
  0003a	8b 45 f8	 mov	 eax, DWORD PTR tv72[ebp]
  0003d	2b 45 f0	 sub	 eax, DWORD PTR tv75[ebp]
  00040	89 45 ec	 mov	 DWORD PTR tv68[ebp], eax
  00043	8b 4d ec	 mov	 ecx, DWORD PTR tv68[ebp]
  00046	89 4d f4	 mov	 DWORD PTR tv69[ebp], ecx
$LN4@length:
  00049	8b 45 f4	 mov	 eax, DWORD PTR tv69[ebp]

; 524  : 		}

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00017	51		 push	 ecx
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  0000c	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>
  00011	50		 push	 eax
  00012	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

  0001a	6a 00		 push	 0
  0001c	6a 00		 push	 0
  0001e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

  00026	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

  00010	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp]
  00013	50		 push	 eax
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Syserror_map@std@@YAPBDH@Z
  0001a	83 c4 04	 add	 esp, 4
  0001d	89 45 fc	 mov	 DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

  00020	83 7d fc 00	 cmp	 DWORD PTR __Name$[ebp], 0
  00024	74 08		 je	 SHORT $LN3@message
  00026	8b 4d fc	 mov	 ecx, DWORD PTR __Name$[ebp]
  00029	89 4d f8	 mov	 DWORD PTR tv69[ebp], ecx
  0002c	eb 07		 jmp	 SHORT $LN4@message
$LN3@message:
  0002e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
  00035	8b 55 f8	 mov	 edx, DWORD PTR tv69[ebp]
  00038	52		 push	 edx
  00039	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0003c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00041	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]
  00044	83 c8 01	 or	 eax, 1
  00047	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  0004a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 08 00	 ret	 8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

  00010	83 7d 0c 01	 cmp	 DWORD PTR __Errcode$[ebp], 1
  00014	75 1d		 jne	 SHORT $LN2@message

; 613  : 			return ("iostream stream error");

  00016	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00023	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  00026	83 c8 01	 or	 eax, 1
  00029	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0002c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002f	eb 1e		 jmp	 SHORT $LN3@message

; 614  : 		else

  00031	eb 1c		 jmp	 SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

  00033	8b 4d 0c	 mov	 ecx, DWORD PTR __Errcode$[ebp]
  00036	51		 push	 ecx
  00037	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0003a	52		 push	 edx
  0003b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
  00043	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  00046	83 c8 01	 or	 eax, 1
  00049	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0004c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 08 00	 ret	 8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 258  : 		}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 253  : 		}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

  00009	8b 4d 08	 mov	 ecx, DWORD PTR __Code$[ebp]
  0000c	e8 00 00 00 00	 call	 ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
  00011	50		 push	 eax
  00012	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==
  0001a	0f b6 c0	 movzx	 eax, al
  0001d	85 c0		 test	 eax, eax
  0001f	74 16		 je	 SHORT $LN3@equivalent
  00021	8b 4d 08	 mov	 ecx, DWORD PTR __Code$[ebp]
  00024	e8 00 00 00 00	 call	 ?value@error_code@std@@QBEHXZ ; std::error_code::value
  00029	3b 45 0c	 cmp	 eax, DWORD PTR __Errval$[ebp]
  0002c	75 09		 jne	 SHORT $LN3@equivalent
  0002e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
  00035	eb 07		 jmp	 SHORT $LN4@equivalent
$LN3@equivalent:
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@equivalent:
  0003e	8a 45 fc	 mov	 al, BYTE PTR tv74[ebp]

; 417  : 	}

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 08 00	 ret	 8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	3b 45 08	 cmp	 eax, DWORD PTR __Right$[ebp]
  0000f	75 09		 jne	 SHORT $LN3@operator
  00011	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
  00018	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0001a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv65[ebp], 0
$LN4@operator:
  00021	8a 45 fc	 mov	 al, BYTE PTR tv65[ebp]

; 186  : 		}

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 356  : 		}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 351  : 		}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	e8 00 00 00 00	 call	 ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
  00012	50		 push	 eax
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
  0001b	8b c8		 mov	 ecx, eax
  0001d	e8 00 00 00 00	 call	 ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==
  00022	0f b6 c0	 movzx	 eax, al
  00025	85 c0		 test	 eax, eax
  00027	74 1f		 je	 SHORT $LN3@operator
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?value@error_condition@std@@QBEHXZ ; std::error_condition::value
  00031	8b f0		 mov	 esi, eax
  00033	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00036	e8 00 00 00 00	 call	 ?value@error_condition@std@@QBEHXZ ; std::error_condition::value
  0003b	3b f0		 cmp	 esi, eax
  0003d	75 09		 jne	 SHORT $LN3@operator
  0003f	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
  00046	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00048	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$LN4@operator:
  0004f	8a 45 f8	 mov	 al, BYTE PTR tv78[ebp]

; 379  : 		}

  00052	5e		 pop	 esi
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Cat$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 317  : 		}

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Errval$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00012	e8 00 00 00 00	 call	 ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
  00017	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Cond$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Errval$[ebp]
  00010	51		 push	 ecx
  00011	8d 55 f4	 lea	 edx, DWORD PTR $T1[ebp]
  00014	52		 push	 edx
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b 10		 mov	 edx, DWORD PTR [eax]
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00020	ff d0		 call	 eax
  00022	8b c8		 mov	 ecx, eax
  00024	e8 00 00 00 00	 call	 ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==

; 410  : 	}

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

  00007	83 7d 08 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0000b	74 20		 je	 SHORT $LN2@Inside
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00015	39 45 08	 cmp	 DWORD PTR __Ptr$[ebp], eax
  00018	72 13		 jb	 SHORT $LN2@Inside
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	03 41 10	 add	 eax, DWORD PTR [ecx+16]
  00028	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0002b	77 06		 ja	 SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

  0002d	32 c0		 xor	 al, al
  0002f	eb 04		 jmp	 SHORT $LN4@Inside

; 2241 : 		else

  00031	eb 02		 jmp	 SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

  00033	b0 01		 mov	 al, 1
$LN4@Inside:

; 2243 : 		}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000d	3b 4d 08	 cmp	 ecx, DWORD PTR __Off$[ebp]
  00010	73 08		 jae	 SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

  0001a	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  0001d	52		 push	 edx
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN2@Xran:

; 2277 : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000f	3b 4d 08	 cmp	 ecx, DWORD PTR __Off$[ebp]
  00012	73 08		 jae	 SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

  0001c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00022	2b 45 08	 sub	 eax, DWORD PTR __Off$[ebp]
  00025	3b 45 0c	 cmp	 eax, DWORD PTR __Count$[ebp]
  00028	77 0e		 ja	 SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

  0002a	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  0002d	51		 push	 ecx
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
  00036	eb 46		 jmp	 SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

  00038	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0003c	76 40		 jbe	 SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00046	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  00049	89 45 f8	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

  0004c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00052	2b 45 0c	 sub	 eax, DWORD PTR __Count$[ebp]
  00055	89 45 f4	 mov	 DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

  00058	8b 4d f4	 mov	 ecx, DWORD PTR __Newsize$1[ebp]
  0005b	2b 4d 08	 sub	 ecx, DWORD PTR __Off$[ebp]
  0005e	51		 push	 ecx
  0005f	8b 55 f8	 mov	 edx, DWORD PTR __Ptr$2[ebp]
  00062	03 55 0c	 add	 edx, DWORD PTR __Count$[ebp]
  00065	52		 push	 edx
  00066	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$2[ebp]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1327 : 			_Eos(_Newsize);

  00072	8b 4d f4	 mov	 ecx, DWORD PTR __Newsize$1[ebp]
  00075	51		 push	 ecx
  00076	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

  0007e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c2 08 00	 ret	 8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

  00009	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000c	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00011	3b 45 0c	 cmp	 eax, DWORD PTR __Roff$[ebp]
  00014	73 08		 jae	 SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00021	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00026	2b 45 0c	 sub	 eax, DWORD PTR __Roff$[ebp]
  00029	89 45 f8	 mov	 DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0002f	3b 45 f8	 cmp	 eax, DWORD PTR __Num$[ebp]
  00032	73 06		 jae	 SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

  00034	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00037	89 4d f8	 mov	 DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

  0003a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	3b 55 08	 cmp	 edx, DWORD PTR __Right$[ebp]
  00040	75 1f		 jne	 SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  00042	8b 45 0c	 mov	 eax, DWORD PTR __Roff$[ebp]
  00045	03 45 f8	 add	 eax, DWORD PTR __Num$[ebp]
  00048	50		 push	 eax
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00051	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  00054	51		 push	 ecx
  00055	6a 00		 push	 0
  00057	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  0005f	eb 42		 jmp	 SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

  00061	6a 00		 push	 0
  00063	8b 55 f8	 mov	 edx, DWORD PTR __Num$[ebp]
  00066	52		 push	 edx
  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  0006f	0f b6 c0	 movzx	 eax, al
  00072	85 c0		 test	 eax, eax
  00074	74 2d		 je	 SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

  00076	8b 4d f8	 mov	 ecx, DWORD PTR __Num$[ebp]
  00079	51		 push	 ecx
  0007a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0007d	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00082	03 45 0c	 add	 eax, DWORD PTR __Roff$[ebp]
  00085	50		 push	 eax
  00086	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  00094	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1117 : 			_Eos(_Num);

  00097	8b 55 f8	 mov	 edx, DWORD PTR __Num$[ebp]
  0009a	52		 push	 edx
  0009b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009e	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

  000a3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c2 0c 00	 ret	 12			; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN2@Xlen:

; 2272 : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

  00007	83 c8 ff	 or	 eax, -1

; 629  : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 762  : 		return (_Al.max_size());

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00006	e8 00 00 00 00	 call	 ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size

; 763  : 		}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
  00010	83 c4 04	 add	 esp, 4

; 915  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

  00009	8d 45 ff	 lea	 eax, DWORD PTR $T1[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
  00015	8b c8		 mov	 ecx, eax
  00017	e8 00 00 00 00	 call	 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
  0001c	89 45 f8	 mov	 DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

  0001f	83 7d f8 01	 cmp	 DWORD PTR __Num$[ebp], 1
  00023	77 09		 ja	 SHORT $LN3@max_size
  00025	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv75[ebp], 1
  0002c	eb 09		 jmp	 SHORT $LN4@max_size
$LN3@max_size:
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR __Num$[ebp]
  00031	83 e9 01	 sub	 ecx, 1
  00034	89 4d f4	 mov	 DWORD PTR tv75[ebp], ecx
$LN4@max_size:
  00037	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]

; 1740 : 		}

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 23   : 	void *_Ptr = 0;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

  0000b	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0000f	75 02		 jne	 SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

  00011	eb 22		 jmp	 SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00013	83 7d 08 ff	 cmp	 DWORD PTR __Count$[ebp], -1
  00017	77 16		 ja	 SHORT $LN1@Allocate
  00019	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	50		 push	 eax
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??2@YAPAXI@Z
  00023	83 c4 04	 add	 esp, 4
  00026	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax
  00029	83 7d fc 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0002d	75 06		 jne	 SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

  00035	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

  00007	6a 00		 push	 0
  00009	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>
  00012	83 c4 08	 add	 esp, 8

; 592  : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate

; 877  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -52						; size = 4
tv203 = -48						; size = 4
tv204 = -44						; size = 4
tv202 = -40						; size = 4
$T2 = -35						; size = 1
$T3 = -34						; size = 1
$T4 = -33						; size = 1
__Newres$ = -32						; size = 4
_this$ = -28						; size = 4
__Ptr$ = -24						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 24	 sub	 esp, 36			; 00000024H
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001f	53		 push	 ebx
  00020	56		 push	 esi
  00021	57		 push	 edi
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002f	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  00032	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00035	83 c8 0f	 or	 eax, 15			; 0000000fH
  00038	89 45 e0	 mov	 DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

  0003b	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00043	3b 45 e0	 cmp	 eax, DWORD PTR __Newres$[ebp]
  00046	73 08		 jae	 SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

  00048	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  0004b	89 4d e0	 mov	 DWORD PTR __Newres$[ebp], ecx
  0004e	eb 52		 jmp	 SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

  00050	8b 45 e0	 mov	 eax, DWORD PTR __Newres$[ebp]
  00053	33 d2		 xor	 edx, edx
  00055	b9 03 00 00 00	 mov	 ecx, 3
  0005a	f7 f1		 div	 ecx
  0005c	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  0005f	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  00062	d1 e9		 shr	 ecx, 1
  00064	3b c8		 cmp	 ecx, eax
  00066	77 02		 ja	 SHORT $LN7@Copy
  00068	eb 38		 jmp	 SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

  0006a	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  0006d	8b 72 14	 mov	 esi, DWORD PTR [edx+20]
  00070	d1 ee		 shr	 esi, 1
  00072	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0007a	2b c6		 sub	 eax, esi
  0007c	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	39 41 14	 cmp	 DWORD PTR [ecx+20], eax
  00082	77 13		 ja	 SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

  00084	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00087	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0008a	d1 e8		 shr	 eax, 1
  0008c	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	03 41 14	 add	 eax, DWORD PTR [ecx+20]
  00092	89 45 e0	 mov	 DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

  00095	eb 0b		 jmp	 SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

  00097	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0009f	89 45 e0	 mov	 DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

  000a2	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

  000a9	8d 55 df	 lea	 edx, DWORD PTR $T4[ebp]
  000ac	52		 push	 edx
  000ad	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
  000b5	89 45 d8	 mov	 DWORD PTR tv202[ebp], eax
  000b8	8b 45 e0	 mov	 eax, DWORD PTR __Newres$[ebp]
  000bb	83 c0 01	 add	 eax, 1
  000be	50		 push	 eax
  000bf	8b 4d d8	 mov	 ecx, DWORD PTR tv202[ebp]
  000c2	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
  000c7	89 45 d0	 mov	 DWORD PTR tv203[ebp], eax
  000ca	8b 4d d0	 mov	 ecx, DWORD PTR tv203[ebp]
  000cd	89 4d e8	 mov	 DWORD PTR __Ptr$[ebp], ecx
  000d0	eb 67		 jmp	 SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

  000d2	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  000d5	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  000d8	89 55 e0	 mov	 DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

  000db	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  000df	8d 45 de	 lea	 eax, DWORD PTR $T3[ebp]
  000e2	50		 push	 eax
  000e3	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000e6	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
  000eb	89 45 d4	 mov	 DWORD PTR tv204[ebp], eax
  000ee	8b 4d e0	 mov	 ecx, DWORD PTR __Newres$[ebp]
  000f1	83 c1 01	 add	 ecx, 1
  000f4	51		 push	 ecx
  000f5	8b 4d d4	 mov	 ecx, DWORD PTR tv204[ebp]
  000f8	e8 00 00 00 00	 call	 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
  000fd	89 45 cc	 mov	 DWORD PTR tv205[ebp], eax
  00100	8b 55 cc	 mov	 edx, DWORD PTR tv205[ebp]
  00103	89 55 e8	 mov	 DWORD PTR __Ptr$[ebp], edx
  00106	eb 1b		 jmp	 SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

  00108	6a 00		 push	 0
  0010a	6a 01		 push	 1
  0010c	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0010f	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

  00114	6a 00		 push	 0
  00116	6a 00		 push	 0
  00118	e8 00 00 00 00	 call	 __CxxThrowException@8

; 2204 : 			_CATCH_END

  0011d	b8 00 00 00 00	 mov	 eax, $LN17@Copy
  00122	c3		 ret	 0
$LN14@Copy:
  00123	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  0012a	eb 07		 jmp	 SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
  0012c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

  00133	b8 00 00 00 00	 mov	 eax, $LN19@Copy
  00138	c3		 ret	 0
$LN12@Copy:
  00139	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00140	eb 07		 jmp	 SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
  00142	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

  00149	83 7d 0c 00	 cmp	 DWORD PTR __Oldlen$[ebp], 0
  0014d	76 19		 jbe	 SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

  0014f	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  00152	50		 push	 eax
  00153	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00156	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0015b	50		 push	 eax
  0015c	8b 4d e8	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0015f	51		 push	 ecx
  00160	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  00165	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

  00168	6a 00		 push	 0
  0016a	6a 01		 push	 1
  0016c	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0016f	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

  00174	8d 55 e8	 lea	 edx, DWORD PTR __Ptr$[ebp]
  00177	52		 push	 edx
  00178	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0017b	50		 push	 eax
  0017c	8d 4d dd	 lea	 ecx, DWORD PTR $T2[ebp]
  0017f	51		 push	 ecx
  00180	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00183	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
  00188	8b c8		 mov	 ecx, eax
  0018a	e8 00 00 00 00	 call	 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

  0018f	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00192	8b 45 e0	 mov	 eax, DWORD PTR __Newres$[ebp]
  00195	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

  00198	8b 4d 0c	 mov	 ecx, DWORD PTR __Oldlen$[ebp]
  0019b	51		 push	 ecx
  0019c	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0019f	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

  001a4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001a7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001ae	59		 pop	 ecx
  001af	5f		 pop	 edi
  001b0	5e		 pop	 esi
  001b1	5b		 pop	 ebx
  001b2	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b5	33 cd		 xor	 ecx, ebp
  001b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001bc	8b e5		 mov	 esp, ebp
  001be	5d		 pop	 ebp
  001bf	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00014	33 c8		 xor	 ecx, eax
  00016	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
  00020	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00014	73 08		 jae	 SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00024	3b 4d 08	 cmp	 ecx, DWORD PTR __Newsize$[ebp]
  00027	73 15		 jae	 SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

  00029	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0002f	50		 push	 eax
  00030	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00033	51		 push	 ecx
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  0003c	eb 4a		 jmp	 SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  0003e	0f b6 55 0c	 movzx	 edx, BYTE PTR __Trim$[ebp]
  00042	85 d2		 test	 edx, edx
  00044	74 32		 je	 SHORT $LN3@Grow
  00046	83 7d 08 10	 cmp	 DWORD PTR __Newsize$[ebp], 16 ; 00000010H
  0004a	73 2c		 jae	 SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

  0004c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00052	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  00055	73 08		 jae	 SHORT $LN9@Grow
  00057	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  0005a	89 55 f8	 mov	 DWORD PTR tv129[ebp], edx
  0005d	eb 09		 jmp	 SHORT $LN10@Grow
$LN9@Grow:
  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00065	89 4d f8	 mov	 DWORD PTR tv129[ebp], ecx
$LN10@Grow:
  00068	8b 55 f8	 mov	 edx, DWORD PTR tv129[ebp]
  0006b	52		 push	 edx
  0006c	6a 01		 push	 1
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  00076	eb 10		 jmp	 SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

  00078	83 7d 08 00	 cmp	 DWORD PTR __Newsize$[ebp], 0
  0007c	75 0a		 jne	 SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

  0007e	6a 00		 push	 0
  00080	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

  00088	83 7d 08 00	 cmp	 DWORD PTR __Newsize$[ebp], 0
  0008c	76 09		 jbe	 SHORT $LN11@Grow
  0008e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv136[ebp], 1
  00095	eb 07		 jmp	 SHORT $LN12@Grow
$LN11@Grow:
  00097	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv136[ebp], 0
$LN12@Grow:
  0009e	8a 45 f4	 mov	 al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c2 08 00	 ret	 8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
  00013	0f b6 c8	 movzx	 ecx, al
  00016	85 c9		 test	 ecx, ecx
  00018	74 20		 je	 SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

  0001a	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0001d	52		 push	 edx
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00026	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00029	2b c8		 sub	 ecx, eax
  0002b	51		 push	 ecx
  0002c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002f	52		 push	 edx
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00038	eb 3d		 jmp	 SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

  0003a	6a 00		 push	 0
  0003c	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0003f	50		 push	 eax
  00040	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  00048	0f b6 c8	 movzx	 ecx, al
  0004b	85 c9		 test	 ecx, ecx
  0004d	74 25		 je	 SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

  0004f	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00052	52		 push	 edx
  00053	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00056	50		 push	 eax
  00057	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1136 : 			_Eos(_Count);

  00068	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0006b	51		 push	 ecx
  0006c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

  00074	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\8.0\include\shared\guiddef.h
;	COMDAT _==
_TEXT	SEGMENT
tv68 = -4						; size = 4
_guidOne$ = 8						; size = 4
_guidOther$ = 12					; size = 4
_==	PROC						; COMDAT

; 193  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 194  :     return !!IsEqualGUID(guidOne,guidOther);

  00004	8b 45 0c	 mov	 eax, DWORD PTR _guidOther$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _guidOne$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 _IsEqualGUID
  00011	83 c4 08	 add	 esp, 8
  00014	85 c0		 test	 eax, eax
  00016	74 09		 je	 SHORT $LN3@
  00018	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  0001f	eb 07		 jmp	 SHORT $LN4@
$LN3@:
  00021	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN4@:
  00028	8a 45 fc	 mov	 al, BYTE PTR tv68[ebp]

; 195  : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
_==	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 500  : 		}

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00004	83 7d 10 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00008	75 08		 jne	 SHORT $LN3@move
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  0000d	89 45 fc	 mov	 DWORD PTR tv69[ebp], eax
  00010	eb 18		 jmp	 SHORT $LN4@move
$LN3@move:
  00012	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00015	51		 push	 ecx
  00016	8b 55 0c	 mov	 edx, DWORD PTR __First2$[ebp]
  00019	52		 push	 edx
  0001a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  0001d	50		 push	 eax
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	89 45 fc	 mov	 DWORD PTR tv69[ebp], eax
$LN4@move:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR tv69[ebp]

; 554  : 		}

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\new.h
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	50		 push	 eax
  0002c	6a 04		 push	 4
  0002e	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00033	83 c4 08	 add	 esp, 8
  00036	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	83 7d f0 00	 cmp	 DWORD PTR $T3[ebp], 0
  00044	74 1b		 je	 SHORT $LN3@construct
  00046	8b 4d 0c	 mov	 ecx, DWORD PTR __V0$[ebp]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>
  0004f	83 c4 04	 add	 esp, 4
  00052	8b 55 f0	 mov	 edx, DWORD PTR $T3[ebp]
  00055	8b 00		 mov	 eax, DWORD PTR [eax]
  00057	89 02		 mov	 DWORD PTR [edx], eax
  00059	8b 4d f0	 mov	 ecx, DWORD PTR $T3[ebp]
  0005c	89 4d ec	 mov	 DWORD PTR tv73[ebp], ecx
  0005f	eb 07		 jmp	 SHORT $LN4@construct
$LN3@construct:
  00061	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN4@construct:
  00068	8b 55 ec	 mov	 edx, DWORD PTR tv73[ebp]
  0006b	89 55 e4	 mov	 DWORD PTR $T2[ebp], edx
  0006e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00075	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00078	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007f	59		 pop	 ecx
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00003	50		 push	 eax
  00004	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX0@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8
  00010	c3		 ret	 0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
  00011	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00015	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00018	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
  00027	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 10	 mov	 eax, DWORD PTR __V0$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>
  0000c	83 c4 04	 add	 esp, 4
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00017	e8 00 00 00 00	 call	 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR __V0$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00017	51		 push	 ecx
  00018	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001b	52		 push	 edx
  0001c	e8 00 00 00 00	 call	 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	e8 00 00 00 00	 call	 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
  00014	83 c4 08	 add	 esp, 8

; 910  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00004	83 7d 10 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00008	75 08		 jne	 SHORT $LN3@copy
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  0000d	89 45 fc	 mov	 DWORD PTR tv69[ebp], eax
  00010	eb 17		 jmp	 SHORT $LN4@copy
$LN3@copy:
  00012	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00015	51		 push	 ecx
  00016	8b 55 0c	 mov	 edx, DWORD PTR __First2$[ebp]
  00019	52		 push	 edx
  0001a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _memcpy
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	89 45 fc	 mov	 DWORD PTR tv69[ebp], eax
$LN4@copy:
  00029	8b 45 fc	 mov	 eax, DWORD PTR tv69[ebp]

; 531  : 		}

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??3@YAXPAX@Z
  00011	83 c4 04	 add	 esp, 4

; 587  : 		}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>

; 831  : 		}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

  00007	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 564  : 		_Left = _Right;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000b	88 10		 mov	 BYTE PTR [eax], dl

; 565  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00010	72 13		 jb	 SHORT $LN3@Myptr
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 11		 mov	 edx, DWORD PTR [ecx]
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>
  0001d	83 c4 04	 add	 esp, 4
  00020	89 45 f8	 mov	 DWORD PTR tv72[ebp], eax
  00023	eb 06		 jmp	 SHORT $LN4@Myptr
$LN3@Myptr:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	89 45 f8	 mov	 DWORD PTR tv72[ebp], eax
$LN4@Myptr:
  0002b	8b 45 f8	 mov	 eax, DWORD PTR tv72[ebp]

; 518  : 		}

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00009	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  0000d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00013	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00016	8d 55 ff	 lea	 edx, DWORD PTR $T1[ebp]
  00019	52		 push	 edx
  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00022	03 45 08	 add	 eax, DWORD PTR __Newsize$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
  0002b	83 c4 08	 add	 esp, 8

; 2219 : 		}

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

  00009	0f b6 45 08	 movzx	 eax, BYTE PTR __Built$[ebp]
  0000d	85 c0		 test	 eax, eax
  0000f	75 02		 jne	 SHORT $LN4@Tidy
  00011	eb 6c		 jmp	 SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00013	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0001a	72 63		 jb	 SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

  0001c	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	8b 02		 mov	 eax, DWORD PTR [edx]
  00021	89 45 f4	 mov	 DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

  00024	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	51		 push	 ecx
  00028	8d 55 ff	 lea	 edx, DWORD PTR $T3[ebp]
  0002b	52		 push	 edx
  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
  00034	8b c8		 mov	 ecx, eax
  00036	e8 00 00 00 00	 call	 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

  0003b	83 7d 0c 00	 cmp	 DWORD PTR __Newsize$[ebp], 0
  0003f	76 1d		 jbe	 SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

  00041	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00044	50		 push	 eax
  00045	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$1[ebp]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>
  0004e	83 c4 04	 add	 esp, 4
  00051	50		 push	 eax
  00052	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00055	52		 push	 edx
  00056	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

  0005e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00061	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00064	83 c1 01	 add	 ecx, 1
  00067	51		 push	 ecx
  00068	8b 55 f4	 mov	 edx, DWORD PTR __Ptr$1[ebp]
  0006b	52		 push	 edx
  0006c	8d 45 fe	 lea	 eax, DWORD PTR $T2[ebp]
  0006f	50		 push	 eax
  00070	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	e8 00 00 00 00	 call	 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
  00078	8b c8		 mov	 ecx, eax
  0007a	e8 00 00 00 00	 call	 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  0007f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH

; 2266 : 		_Eos(_Newsize);

  00089	8b 55 0c	 mov	 edx, DWORD PTR __Newsize$[ebp]
  0008c	52		 push	 edx
  0008d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 963  : 		{	// destroy the string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 964  : 		_Tidy(true);

  00007	6a 00		 push	 0
  00009	6a 01		 push	 1
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 965  : 		}

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 89   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00010	72 13		 jb	 SHORT $LN3@Myptr
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 11		 mov	 edx, DWORD PTR [ecx]
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>
  0001d	83 c4 04	 add	 esp, 4
  00020	89 45 f8	 mov	 DWORD PTR tv72[ebp], eax
  00023	eb 06		 jmp	 SHORT $LN4@Myptr
$LN3@Myptr:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	89 45 f8	 mov	 DWORD PTR tv72[ebp], eax
$LN4@Myptr:
  0002b	8b 45 f8	 mov	 eax, DWORD PTR tv72[ebp]

; 525  : 		}

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\program files\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 1734 : 		}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0IUnknown@@QAE@XZ PROC				; IUnknown::IUnknown, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0IUnknown@@QAE@XZ ENDP				; IUnknown::IUnknown
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\8.0\include\shared\guiddef.h
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT
tv68 = -8						; size = 4
tv70 = -4						; size = 4
_rguid1$ = 8						; size = 4
_rguid2$ = 12						; size = 4
_IsEqualGUID PROC					; COMDAT

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00006	6a 10		 push	 16			; 00000010H
  00008	8b 45 0c	 mov	 eax, DWORD PTR _rguid2$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _rguid1$[ebp]
  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 _memcmp
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH
  00018	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
  0001b	83 7d f8 00	 cmp	 DWORD PTR tv68[ebp], 0
  0001f	75 09		 jne	 SHORT $LN3@IsEqualGUI
  00021	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv70[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@IsEqualGUI
$LN3@IsEqualGUI:
  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN4@IsEqualGUI:
  00031	8b 45 fc	 mov	 eax, DWORD PTR tv70[ebp]

; 162  : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
_IsEqualGUID ENDP
_TEXT	ENDS
END
